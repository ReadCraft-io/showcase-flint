
<!doctype html>
<html
  lang="en"
  data-content_root="./"
  class="scroll-smooth [--header-height:calc(var(--spacing)*18)] [--header-padding:calc(var(--spacing)*12)]"
  id="top"
  
>
  <head>
    <title>acb_theta.h – Riemann theta functions &mdash; FLINT 3.5.0-dev documentation</title>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="generator"
  content="Sphinx 9.1.0, Clarity Theme for Sphinx 0.1.1 (https://readcraft.io/sphinx-clarity-theme/)"
/>


<meta name="viewport" content="width=device-width, initial-scale=1" />



<script src="_static/scripts/dark-mode.js"></script>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=a5519fdd" />
    <link rel="stylesheet" type="text/css" href="_static/styles/output.css?v=71cc70a9" />



    
    
  </head>

  <body >
    
  <!-- ============================================================== -->
  <!-- Primary drawer before markup -->
  <!-- ============================================================== -->
  <div class="drawer">
    <input id="primary-drawer" type="checkbox" class="drawer-toggle" />
    <div class="drawer-content">
      <!-- ========================================================== -->
      <!-- Secondary drawer before markup -->
      <!-- ========================================================== -->
      <div class="drawer drawer-end">
        <input id="secondary-drawer" type="checkbox" class="drawer-toggle" />
        <div class="drawer-content">
          <!-- ====================================================== -->
          <!-- Page content -->
          <!-- ====================================================== -->
          <div class="bg-base-100 divide-base-200 divide-y">
            


<!-- Header -->
<header id="main-header" class="bg-base-100 sticky top-0 z-50">
  <div
    class="container mx-auto flex h-[var(--header-height)] items-center px-4 md:px-0"
  >
    <!-- Left side (logo) -->
    <div class="flex-1">
<a href="index.html">
  
  
    <span class="text-primary-content text-xl font-bold">
      
      FLINT 3.5.0-dev documentation
    </span>
  
</a></div>

    <!-- Right side -->
    <div class="flex flex-1 items-center justify-end">
      <!-- #Header menu (desktop) -->
      <div class="hidden lg:block">
        <!-- `[&_li]:self-center` - If a content of <li> is the button, the "self-center" required to properly vertically align it -->
        <!-- `[&_li>a]:px-2 [&_li>a]:py-3` - Tweaks default menu ugly padding that doesn't match to buttons padding -->
        <ul
          class="menu menu-horizontal text-secondary-content gap-2 [&_li]:self-center [&_li>a]:px-2 [&_li>a]:py-3"
        >
          
        </ul>
      </div>
      <!-- .#Header menu (desktop) -->

      <!-- #Search button -->
      <div class="tooltip tooltip-bottom" data-tip="Search">
        <button
          class="btn btn-ghost btn-secondary"
          onclick="searchModal.showModal()"
        >
          <span class="icon-[prime--search] text-2xl"></span>
        </button>
      </div>
      <!-- .#Search button -->

      
  
  


      
  <!-- #Mode select -->
  <div class="tooltip tooltip-bottom" data-tip="Light/dark mode">
    <button class="btn btn-ghost btn-secondary">
      <label class="swap swap-rotate">
        <!-- this hidden checkbox controls the state -->
        <input type="checkbox" onclick="toggleMode()" />
        <!-- light mode icon -->
        <span class="icon-[prime--sun] swap-on text-2xl"></span>
        <!-- dark mode icon -->
        <span class="icon-[prime--moon] swap-off text-2xl"></span>
      </label>
    </button>
  </div>
  <!-- .#Mode select -->


      <!-- #Header menu (mobile) -->
      <details class="dropdown dropdown-left lg:hidden">
        <summary class="btn btn-secondary aspect-square" aria-label="Menu">
          <span class="icon-[prime--bars]"></span>
          <span class="sr-only">Menu</span>
        </summary>
        <!-- `[&_li>a.btn]:justify-start` - If a content of <li> is the button, it should be aligned to the start (left) -->
        <ul
          class="menu dropdown-content bg-base-100 rounded-box dark:border-base-200 z-1 w-52 p-2 shadow-sm dark:border [&_li>a.btn]:justify-start"
        >
          
        </ul>
      </details>
      <!-- .#Header menu (mobile) -->
    </div>
  </div>
</header>
            
<!-- #Sidebar toggles (mobile) -->
<nav class="p-4 lg:hidden">
  <div class="container mx-auto flex items-center justify-between text-sm">
    <!-- Left side -->
    <div>
      
        <button
          class="btn btn-secondary btn-sm text-secondary-content/80 font-normal"
        >
          <label
            for="primary-drawer"
            class="flex cursor-pointer items-center gap-1"
          >
            <span class="icon-[prime--align-left] text-xl"></span>
            Table of Contents
          </label>
        </button>
      
    </div>
    <!-- .Left side -->
    <!-- Right side -->
    <div>
      
        <button
          class="btn btn-secondary btn-sm text-secondary-content/80 font-normal"
        >
          <label
            for="secondary-drawer"
            class="flex cursor-pointer items-center gap-1"
          >
            This page
            <span class="icon-[prime--align-right] text-xl"></span>
          </label>
        </button>
      
    </div>
    <!-- .Right side -->
  </div>
</nav>
<!-- .#Sidebar toggles (mobile) -->

            <main class="p-4 lg:pt-[var(--header-padding)]">
              <div class="container mx-auto lg:flex lg:items-start">
                <article class="lg:order-2 lg:w-8/12 lg:flex-none lg:px-12">
                  
<!-- #Breadcrumb -->
<nav class="flex flex-wrap items-center gap-1 text-sm">
  
  <a
    href="index.html"
    class="text-secondary-content/80 hover:text-accent-content hover:underline"
  >
    FLINT 3.5.0-dev documentation
  </a>

  

  
  <span
    class="icon-[prime--arrow-right] text-secondary-content/50"
  ></span>
  <span class="text-secondary-content/80"><strong>acb_theta.h</strong> – Riemann theta functions</span>
</nav>
<!-- .#Breadcrumb -->

                  
                  <main role="main">
  <section id="acb-theta-h-riemann-theta-functions">
<span id="acb-theta"></span><h1><strong>acb_theta.h</strong> – Riemann theta functions<a class="headerlink" href="#acb-theta-h-riemann-theta-functions" title="Link to this heading">¶</a></h1>
<p>This module provides methods for the numerical evaluation of theta functions in
any dimension <span class="math notranslate nohighlight">\(g\geq 1\)</span>. The algorithms will be detailed in the forthcoming
paper <a class="reference internal" href="references.html#ek2025" id="id1"><span>[EK2025]</span></a>. In the case <span class="math notranslate nohighlight">\(g=1\)</span>, we rely on, but also improve on
functionality from <a class="reference internal" href="acb_modular.html#acb-modular"><span class="std std-ref">acb_modular.h</span></a>. We also provide
functionality to evaluate derivatives of theta functions, and also to evaluate
Siegel modular forms in terms of theta functions when <span class="math notranslate nohighlight">\(g=2\)</span>.</p>
<p>In this module, <em>tau</em> or <span class="math notranslate nohighlight">\(\tau\)</span> always denotes an element of the Siegel upper
half-space <span class="math notranslate nohighlight">\(\mathcal{H}_g\)</span>, i.e. <span class="math notranslate nohighlight">\(\tau\)</span> is a symmetric <span class="math notranslate nohighlight">\(g\times g\)</span> complex
matrix with positive definite imaginary part, encoded as an <a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_mat_t</span></code></a>,
while <em>z</em> or <em>zs</em> denotes a vector (resp. a tuple of vectors) in
<span class="math notranslate nohighlight">\(\mathbb{C}^g\)</span>, encoded as an <a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_ptr</span></code></a> of length <span class="math notranslate nohighlight">\(g\)</span> (resp. <em>nb</em> times
<span class="math notranslate nohighlight">\(g\)</span>). For each <span class="math notranslate nohighlight">\(a,b\in \{0,1\}^g\)</span>, the Riemann theta function (of level 2) of
characteristic <span class="math notranslate nohighlight">\((a,b)\)</span> is the following analytic function in <span class="math notranslate nohighlight">\(\tau\in
\mathcal{H}_g\)</span> and <span class="math notranslate nohighlight">\(z\in \mathbb{C}^g\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(z,\tau) = \sum_{n\in \mathbb{Z}^{g} + \tfrac a2} \exp(\pi i n^T \tau n + 2\pi i n^T (z + \tfrac b2)),\]</div>
</div></blockquote>
<p>considering <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(z\)</span> as column vectors.</p>
<p>The numerical functions in this module always compute certified error bounds:
for instance, if <span class="math notranslate nohighlight">\(\tau\)</span> is represented by an <a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_mat_t</span></code></a> whose imaginary
part is not certainly positive definite at the chosen working precision, then
the output theta values will have an infinite radius.</p>
<section id="main-user-functions">
<h2>Main user functions<a class="headerlink" href="#main-user-functions" title="Link to this heading">¶</a></h2>
<p>First, if the user knows <span class="math notranslate nohighlight">\((a,b)\)</span> as a vector <em>vec</em> of length <span class="math notranslate nohighlight">\(2g\)</span> with entries
0 or 1, then the function</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_set_slong_vec">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_set_slong_vec</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_set_slong_vec" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>(where <em>len</em> is <span class="math notranslate nohighlight">\(2g\)</span>) computes the <a class="reference internal" href="flint.html#c.ulong" title="ulong"><code class="xref c c-type docutils literal notranslate"><span class="pre">ulong</span></code></a> between 0 and <span class="math notranslate nohighlight">\(2^{2g}-1\)</span> whose
binary expansion is exactly <span class="math notranslate nohighlight">\((a,b)\)</span> (most significant bits first). Throughout,
we order vectors of theta values according to this encoding: in other words,
the computed <a class="reference internal" href="flint.html#c.ulong" title="ulong"><code class="xref c c-type docutils literal notranslate"><span class="pre">ulong</span></code></a> is exactly the index of <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span> inside the
vector of theta values. For instance, the characteristic <span class="math notranslate nohighlight">\((a,b)\)</span> where <span class="math notranslate nohighlight">\(a =
(1,0)\)</span> and <span class="math notranslate nohighlight">\(b = (0,0)\)</span> in dimension <span class="math notranslate nohighlight">\(g=2\)</span> is numbered <span class="math notranslate nohighlight">\(8\)</span>. With these
conventions, the output of <a class="reference internal" href="acb_modular.html#c.acb_modular_theta" title="acb_modular_theta"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_modular_theta()</span></code></a> in dimension 1 is
<span class="math notranslate nohighlight">\((-\theta_3,\theta_2,\theta_0,\theta_1)\)</span>. When we manipulate <span class="math notranslate nohighlight">\(a\)</span> or <span class="math notranslate nohighlight">\(b\)</span>
individually (and hence compute only <span class="math notranslate nohighlight">\(2^g\)</span> theta values), we map them to
integers between 0 and <span class="math notranslate nohighlight">\(2^g-1\)</span> instead, taking <em>len</em> to be <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>There are two main user-facing functions in this modules:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_one">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_one</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ab</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>th</em> to the single value <span class="math notranslate nohighlight">\(\theta_{a,b}(z,\tau)\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_all">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_all</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sqr</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_all" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <em>sqr</em> is zero, this function computes <span class="math notranslate nohighlight">\(\theta_{a,b}(z,\tau)\)</span> for all
<span class="math notranslate nohighlight">\(a,b\in \{0,1\}^g\)</span>; if <em>sqr</em> is nonzero, it computes
<span class="math notranslate nohighlight">\(\theta_{a,b}(z,\tau)^2\)</span> instead using a faster algorithm. In both cases,
the output, stored in <em>th</em>, is a vector of length <span class="math notranslate nohighlight">\(2^{2g}\)</span>, and
<a class="reference internal" href="#c.acb_theta_all" title="acb_theta_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_all()</span></code></a> is only slightly slower than <a class="reference internal" href="#c.acb_theta_one" title="acb_theta_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_one()</span></code></a>.</p>
</dd></dl>

<p>In both <a class="reference internal" href="#c.acb_theta_one" title="acb_theta_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_one()</span></code></a> and <a class="reference internal" href="#c.acb_theta_all" title="acb_theta_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_all()</span></code></a>, we handle the final
argument <em>prec</em> as follows. Barring unexpected cancellations, the absolute
value of <span class="math notranslate nohighlight">\(\theta_{a,b}(z,\tau)\)</span> should be roughly</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\left|\theta_{a,b}(z,\tau)\right| \approx e^{\pi y^T Y^{-1} y} e^{- d^2}\]</div>
</div></blockquote>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(y\)</span> denote the imaginary parts of <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(z\)</span> respectively (we
keep this notation throughout);</p></li>
<li><p><span class="math notranslate nohighlight">\(d\)</span> denotes the distance between the point <span class="math notranslate nohighlight">\(v = -Y^{-1}y \in \mathbb{R}^g\)</span> and the
shifted lattice <span class="math notranslate nohighlight">\(\mathbb{Z}^g + \tfrac{a}{2} \subset \mathbb{R}^g\)</span> for the Euclidean norm
given by the Gram matrix <span class="math notranslate nohighlight">\(\pi Y\)</span>.</p></li>
</ul>
<p>This leads us to define the normalized functions</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\widetilde{\theta}_{a,b}(z,\tau) = e^{-\pi y^T Y^{-1} y} \theta_{a,b}(z,\tau)\]</div>
</div></blockquote>
<p>which are no longer holomorphic, but are uniformly bounded on <span class="math notranslate nohighlight">\(\mathbb{C}^g\)</span>
for a fixed <span class="math notranslate nohighlight">\(\tau\)</span>. We use those internally for easier precision management: an
argument <em>prec</em> means that <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,b}(z,\tau)\)</span> is computed with
an absolute error bound of roughly <span class="math notranslate nohighlight">\(2^{-\mathit{prec}}\)</span>. The expected error
bound on the output of <a class="reference internal" href="#c.acb_theta_all" title="acb_theta_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_all()</span></code></a> and similar functions is
approximately <span class="math notranslate nohighlight">\(\exp(\pi y^T Y^{-1} y) \cdot 2^{-\mathit{prec}}\)</span> to avoid
unreasonable computations when <span class="math notranslate nohighlight">\(y\)</span> is very far from zero. Some internal
functions also take the factor <span class="math notranslate nohighlight">\(\exp(-d^2)\)</span> into account, and are documented as
such.</p>
<p>Both functions <a class="reference internal" href="#c.acb_theta_one" title="acb_theta_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_one()</span></code></a> and <a class="reference internal" href="#c.acb_theta_all" title="acb_theta_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_all()</span></code></a> are in fact
interfaces to the more complete method</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ab</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sqr</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>which allows for several input vectors <em>z</em> (for the same matrix <em>tau</em>) for more
efficiency, and also evaluates derivatives of theta functions. Its parameters
are as follows:</p>
<ul class="simple">
<li><p><em>nb</em> is the number of vectors <span class="math notranslate nohighlight">\(z\)</span> that we consider, and the input vector <em>zs</em>
should have length <em>nb</em> times <span class="math notranslate nohighlight">\(g\)</span>. The output vector <em>th</em> is the
concatenation of the <em>nb</em> individual outputs for each <span class="math notranslate nohighlight">\(z\)</span>.</p></li>
<li><p><em>ord</em> is the order of derivatives to be computed: we compute all the partial
derivatives of theta functions <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span> with respect to the entries of
<span class="math notranslate nohighlight">\(z\)</span> of total order up to <em>ord</em>. (Partial derivatives with respect to the
entries of <span class="math notranslate nohighlight">\(\tau\)</span> are then accounted for by the heat equation.) We refer to
the documentation below for conventions on the normalization and ordering of
those derivatives.</p></li>
<li><p><em>ab</em> indicates the characteristic <span class="math notranslate nohighlight">\((a,b)\)</span> we are interested in. It is ignored
if <em>all</em> is set to true.</p></li>
<li><p><em>all</em> is a boolean: if true (nonzero), then the output is a concatenation of
<span class="math notranslate nohighlight">\(2^{2g}\)</span> vectors of partial derivatives of theta functions, one for each
characteristic. If false (zero), then we evaluate (partial derivatives of) a
single theta function <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span> using a slightly faster algorithm.</p></li>
<li><p><em>sqr</em> is as in <a class="reference internal" href="#c.acb_theta_all" title="acb_theta_all"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_all()</span></code></a>, but is ignored if <em>ord</em> is positive.</p></li>
</ul>
<p>Behind the scenes, <a class="reference internal" href="#c.acb_theta_jet" title="acb_theta_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet()</span></code></a> works as follows: it first reduces the
inputs <span class="math notranslate nohighlight">\((z,\tau)\)</span> using the action of the Siegel modular group
<span class="math notranslate nohighlight">\(\mathrm{Sp}_{2g}(\mathbb{Z})\)</span> (the symplectic group) on <span class="math notranslate nohighlight">\(\mathbb{C}^g\times
\mathcal{H}_g\)</span>, then evaluates (partial derivatives of) theta functions on the
reduced arguments, and finally applies the transformation formula for theta
functions under <span class="math notranslate nohighlight">\(\mathrm{Sp}_{2g}(\mathbb{Z})\)</span>. The second step (evaluating
theta functions) uses an advanced algorithm based on duplication formulas that
has a uniform, quasi-linear complexity in terms of the required precision.</p>
</section>
<section id="example-of-usage">
<h2>Example of usage<a class="headerlink" href="#example-of-usage" title="Link to this heading">¶</a></h2>
<p>The following code snippet constructs the period matrix <span class="math notranslate nohighlight">\(\tau = iI_2\)</span> for <span class="math notranslate nohighlight">\(g =
2\)</span>, computes the associated theta values at <span class="math notranslate nohighlight">\(z = 0\)</span> at 100000 bits of precision
in less than 10 ms, and prints them.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;acb.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;acb_mat.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;acb_theta.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">acb_mat_t</span><span class="w"> </span><span class="n">tau</span><span class="p">;</span>
<span class="w">    </span><span class="n">acb_ptr</span><span class="w"> </span><span class="n">th</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="n">slong</span><span class="w"> </span><span class="n">prec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10000</span><span class="p">;</span>

<span class="w">    </span><span class="n">acb_mat_init</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_acb_vec_init</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">th</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_acb_vec_init</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>

<span class="w">    </span><span class="n">acb_mat_onei</span><span class="p">(</span><span class="n">tau</span><span class="p">);</span>
<span class="w">    </span><span class="n">acb_theta_all</span><span class="p">(</span><span class="n">th</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">tau</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">prec</span><span class="p">);</span>
<span class="w">    </span><span class="n">_acb_vec_printd</span><span class="p">(</span><span class="n">th</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>

<span class="w">    </span><span class="n">acb_mat_clear</span><span class="p">(</span><span class="n">tau</span><span class="p">);</span>
<span class="w">    </span><span class="n">_acb_vec_clear</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">_acb_vec_clear</span><span class="p">(</span><span class="n">th</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span>
<span class="w">    </span><span class="n">flint_cleanup</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mf">1.1803</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">3.34e-3010</span><span class="p">,</span> <span class="mf">2.34e-3010</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.99254</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">3.28e-3010</span><span class="p">,</span> <span class="mf">2.78e-3010</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.99254</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">2.37e-3010</span><span class="p">,</span> <span class="mf">1.87e-3010</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.83463</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">2.73e-3010</span><span class="p">,</span> <span class="mf">2.23e-3010</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.99254</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">1.08e-3010</span><span class="p">,</span> <span class="mf">5.79e-3011</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">1.35e-3009</span><span class="p">,</span> <span class="mf">1.35e-3009</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.83463</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">9.64e-3011</span><span class="p">,</span> <span class="mf">4.63e-3011</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">1.13e-3009</span><span class="p">,</span> <span class="mf">1.13e-3009</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.99254</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">3.20e-3009</span><span class="p">,</span> <span class="mf">3.15e-3009</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.83463</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">3.79e-3009</span><span class="p">,</span> <span class="mf">3.74e-3009</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">4.04e-3011</span><span class="p">,</span> <span class="mf">4.04e-3011</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">4.80e-3011</span><span class="p">,</span> <span class="mf">4.80e-3011</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.83463</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">8.30e-3010</span><span class="p">,</span> <span class="mf">7.80e-3010</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">5.18e-3009</span><span class="p">,</span> <span class="mf">5.18e-3009</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">1.00e-3011</span><span class="p">,</span> <span class="mf">1.00e-3011</span><span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">6.1135e-3020</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span>  <span class="o">+/-</span>  <span class="p">(</span><span class="mf">2.80e-3010</span><span class="p">,</span> <span class="mf">2.80e-3010</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="the-siegel-modular-group">
<h2>The Siegel modular group<a class="headerlink" href="#the-siegel-modular-group" title="Link to this heading">¶</a></h2>
<p>We use the type <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">fmpz_mat_t</span></code></a> to handle matrices in
<span class="math notranslate nohighlight">\(\operatorname{Sp}_{2g}(\mathbb{Z})\)</span>. In addition to the functions in this
section, methods from <a class="reference internal" href="fmpz_mat.html#fmpz-mat"><span class="std std-ref">fmpz_mat.h</span></a> such as
<a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_equal" title="fmpz_mat_equal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_equal()</span></code></a> can thus be used on symplectic matrices directly.</p>
<p>In the following functions (with the exception of <a class="reference internal" href="#c.sp2gz_is_correct" title="sp2gz_is_correct"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_is_correct()</span></code></a>) we
always assume that the input matrix <em>mat</em> is square of even size <span class="math notranslate nohighlight">\(2g\)</span>, and
write it as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}m = \begin{pmatrix} \alpha&amp;\beta\\ \gamma&amp;\delta \end{pmatrix}\end{split}\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\alpha,\beta,\gamma,\delta\)</span> are <span class="math notranslate nohighlight">\(g\times g\)</span> blocks.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_dim">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_dim</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_dim" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(g\)</span>, which is half the number of rows (or columns) of <em>mat</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_set_blocks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_set_blocks</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">beta</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gamma</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_set_blocks" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>mat</em> to <span class="math notranslate nohighlight">\(\bigl(\begin{smallmatrix} \alpha&amp;\beta\\ \gamma&amp;\delta
\end{smallmatrix}\bigr)\)</span>. The dimensions must match.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_j">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_j</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_j" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>mat</em> to the symplectic matrix <span class="math notranslate nohighlight">\(J = \Bigl(\begin{smallmatrix}
0&amp;I_g\\-I_g&amp;0 \end{smallmatrix}\Bigr)\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_block_diag">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_block_diag</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_block_diag" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>mat</em> to the symplectic matrix <span class="math notranslate nohighlight">\(\Bigl(\begin{smallmatrix}
U&amp;0\\0&amp;U^{-T} \end{smallmatrix}\Bigr)\)</span>. We require that <span class="math notranslate nohighlight">\(U\in
\operatorname{GL}_g(\mathbb{Z})\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_trig">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_trig</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">S</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_trig" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>mat</em> to <span class="math notranslate nohighlight">\(\Bigl(\begin{smallmatrix} I_g&amp;S\\0&amp;I_g
\end{smallmatrix}\Bigr)\)</span>, where <em>S</em> is a symmetric <span class="math notranslate nohighlight">\(g\times g\)</span> matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_embed">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_embed</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_embed" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <em>mat</em> is a symplectic matrix of size <span class="math notranslate nohighlight">\(2r\times 2r\)</span> and <em>res</em>
is square of size <span class="math notranslate nohighlight">\(2g\times 2g\)</span> for some <span class="math notranslate nohighlight">\(g\geq r\)</span>, sets <em>res</em> to the symplectic matrix</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix} \alpha &amp;&amp; \beta &amp; \\ &amp; I_{g-r} &amp;&amp; 0_{g-r} \\ \gamma &amp;&amp;\delta &amp;\\ &amp; 0_{g-r} &amp;&amp; I_{g-r} \end{pmatrix}\end{split}\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\alpha,\beta,\gamma,\delta\)</span> are the <span class="math notranslate nohighlight">\(r\times r\)</span> blocks of <em>mat</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_restrict">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_restrict</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_restrict" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <em>mat</em> is a symplectic matrix of size <span class="math notranslate nohighlight">\(2g\times 2g\)</span> and <em>res</em>
is square of size <span class="math notranslate nohighlight">\(2r\times 2r\)</span> for some <span class="math notranslate nohighlight">\(r\leq g\)</span>, sets <em>res</em> to the
matrix whose <span class="math notranslate nohighlight">\(r\times r\)</span> blocks are the upper left corners of the
corresponding <span class="math notranslate nohighlight">\(g\times g\)</span> block of <em>mat</em>. The result may not be a
symplectic matrix in general.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_nb_fundamental">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_nb_fundamental</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_nb_fundamental" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of fundamental symplectic matrices used in the reduction
algorithm on <span class="math notranslate nohighlight">\(\mathcal{H}_g\)</span>. This number is 1 when <span class="math notranslate nohighlight">\(g=1\)</span> (the <span class="math notranslate nohighlight">\(J\)</span> matrix)
and 19 when <span class="math notranslate nohighlight">\(g=2\)</span> <a class="reference internal" href="references.html#got1959" id="id2"><span>[Got1959]</span></a>. When <span class="math notranslate nohighlight">\(g&gt;2\)</span>, a complete set of matrices
defining the boundary of a fundamental domain for the action of
<span class="math notranslate nohighlight">\(\mathrm{Sp}_{2g}(\mathbb{Z})\)</span> is not currently known. As a substitute, we
consider two types of matrices: the <span class="math notranslate nohighlight">\(19 g(g-1)/2\)</span> matrices obtained by
mimicking the <span class="math notranslate nohighlight">\(g=2\)</span> matrices on any pair of indices between 0 and <span class="math notranslate nohighlight">\(g-1\)</span>,
and the <span class="math notranslate nohighlight">\(2^g\)</span> matrices obtained by embedding a copy of a lower-dimensional
<span class="math notranslate nohighlight">\(J\)</span> matrix on any subset of indices.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_fundamental">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_fundamental</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_fundamental" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>mat</em> to the <span class="math notranslate nohighlight">\(j\)</span>-th fundamental symplectic matrix as defined
above.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_is_correct">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_is_correct</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_is_correct" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true (nonzero) iff <em>mat</em> is a symplectic matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_is_j">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_is_j</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_is_j" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true (nonzero) iff the symplectic matrix <em>mat</em> is the <span class="math notranslate nohighlight">\(J\)</span> matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_is_block_diag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_is_block_diag</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_is_block_diag" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true (nonzero) iff the symplectic matrix <em>mat</em> is of block-diagonal
form as in <a class="reference internal" href="#c.sp2gz_block_diag" title="sp2gz_block_diag"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_block_diag()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_is_trig">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_is_trig</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_is_trig" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true (nonzero) iff the sympletic matrix <em>mat</em> is of trigonal form
as in <a class="reference internal" href="#c.sp2gz_trig" title="sp2gz_trig"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_trig()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_is_embedded">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_is_embedded</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_is_embedded" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <em>mat</em> is a <span class="math notranslate nohighlight">\(2g\times 2g\)</span> symplectic matrix and <em>res</em> is
square of size <span class="math notranslate nohighlight">\(2r\)</span> for some <span class="math notranslate nohighlight">\(r\leq g\)</span>, returns true (nonzero) iff <em>mat</em>
can be obtained as the result of <a class="reference internal" href="#c.sp2gz_embed" title="sp2gz_embed"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_embed()</span></code></a> from a <span class="math notranslate nohighlight">\(2r\times 2r\)</span>
symplectic matrix, and store this matrix in <em>res</em>. Otherwise, returns
false (0) and leaves <em>res</em> undefined.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_inv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_inv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_inv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>inv</em> to the inverse of the symplectic matrix <em>mat</em>. In contrast with
<a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_inv" title="fmpz_mat_inv"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_inv()</span></code></a>, this involves no computation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_decompose">
<a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_struct" title="fmpz_mat_struct"><span class="n"><span class="pre">fmpz_mat_struct</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_decompose</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_decompose" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a vector <em>res</em> of symplectic matrices and store its length in <em>nb</em>
such that the following holds: <em>mat</em> is the product of the elements of
<em>res</em> from left to right, and each element of <em>res</em> is block-diagonal,
trigonal, the <span class="math notranslate nohighlight">\(J\)</span> matrix, an embedded <span class="math notranslate nohighlight">\(J\)</span> matrix from a lower dimension, or
an embedded matrix from dimension 1. The output vector <em>res</em> will later
have to be freed by the user as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">slong</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">nb</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">fmpz_mat_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">flint_free</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.sp2gz_randtest">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sp2gz_randtest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.sp2gz_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>mat</em> to a random symplectic matrix whose coefficients have length
approximately <em>bits</em>, obtained as a product of block-diagonal and trigonal
symplectic matrices and the <span class="math notranslate nohighlight">\(J\)</span> matrix.</p>
</dd></dl>

</section>
<section id="the-siegel-half-space">
<h2>The Siegel half space<a class="headerlink" href="#the-siegel-half-space" title="Link to this heading">¶</a></h2>
<p>We continue to denote by <span class="math notranslate nohighlight">\(\alpha,\beta,\gamma,\delta\)</span> the <span class="math notranslate nohighlight">\(g\times g\)</span> blocks of
<em>mat</em>, which is always assumed to be symplectic.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_cocycle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_cocycle</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_cocycle" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>c</em> to <span class="math notranslate nohighlight">\(\gamma\tau + \delta\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_transform_cocycle_inv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_transform_cocycle_inv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_transform_cocycle_inv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>w</em>, <em>c</em> and <em>cinv</em> to <span class="math notranslate nohighlight">\((\alpha\tau + \beta)(\gamma\tau +
\delta)^{-1}\)</span>, <span class="math notranslate nohighlight">\(\gamma\tau + \delta\)</span> and <span class="math notranslate nohighlight">\((\gamma\tau + \delta)^{-1}\)</span>
respectively.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_transform">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_transform</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_transform" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>w</em> to <span class="math notranslate nohighlight">\((\alpha\tau + \beta)(\gamma\tau + \delta)^{-1}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_cho_yinv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_cho_yinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="arb_mat.html#c.arb_mat_t" title="arb_mat_t"><span class="n"><span class="pre">arb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cho</span></span>, <a class="reference internal" href="arb_mat.html#c.arb_mat_t" title="arb_mat_t"><span class="n"><span class="pre">arb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">yinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_cho_yinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>yinv</em> to the inverse of the imaginary part <span class="math notranslate nohighlight">\(Y\)</span> of <em>tau</em>, and sets
<em>cho</em> to an upper-triangular Cholesky matrix for <span class="math notranslate nohighlight">\(\pi Y\)</span>, i.e. to the
upper-triangular matrix <span class="math notranslate nohighlight">\(C\)</span> with positive diagonal entries such that <span class="math notranslate nohighlight">\(\pi Y
= C^T C\)</span>. If one cannot determine that <span class="math notranslate nohighlight">\(Y\)</span> is positive definite at the
current working precision, <em>yinv</em> and <em>cho</em> are set to indeterminate
matrices.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_reduce">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_reduce</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_reduce" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>mat</em> to a symplectic matrix such that <span class="math notranslate nohighlight">\(\mathit{mat}\cdot\tau\)</span> is as
reduced as possible, repeatedly reducing the imaginary and real parts of
<span class="math notranslate nohighlight">\(\tau\)</span> and applying fundamental symplectic matrices. If the coefficients of
<span class="math notranslate nohighlight">\(\tau\)</span> do not have a reasonable size or if <span class="math notranslate nohighlight">\(\det Y\)</span> is vanishingly small,
we simply set <em>mat</em> to the identity.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_is_reduced">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_is_reduced</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">tol_exp</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_is_reduced" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true (nonzero) iff it is certainly true that <span class="math notranslate nohighlight">\(\tau\)</span> belongs to the
reduced domain defined by the tolerance parameter <span class="math notranslate nohighlight">\(\varepsilon =
2^{\mathit{tol\_exp}}\)</span>. This means the following:
<span class="math notranslate nohighlight">\(|\mathrm{Re}(\tau_{j,k})| &lt; \frac12 + \varepsilon\)</span> for all <span class="math notranslate nohighlight">\(0\leq j,k &lt;
g\)</span>; the imaginary part of <span class="math notranslate nohighlight">\(\tau\)</span> passes <a class="reference internal" href="arb_mat.html#c.arb_mat_spd_is_lll_reduced" title="arb_mat_spd_is_lll_reduced"><code class="xref c c-func docutils literal notranslate"><span class="pre">arb_mat_spd_is_lll_reduced()</span></code></a>
with the same parameters; and for every matrix obtained from
<a class="reference internal" href="#c.sp2gz_fundamental" title="sp2gz_fundamental"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_fundamental()</span></code></a>, the determinant of the corresponding cocycle is
at least <span class="math notranslate nohighlight">\(1-\varepsilon\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_kappa">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_kappa</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">sqrtdet</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sqr</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_kappa" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <em>sqr</em> is zero, returns <span class="math notranslate nohighlight">\(0\leq r &lt; 8\)</span> such that <span class="math notranslate nohighlight">\(\kappa(\mathit{mat}) =
\zeta_8^r\)</span> and sets <em>sqrtdet</em> to the corresponding square root of
<span class="math notranslate nohighlight">\(\det(\gamma\tau + \delta)\)</span> in the theta transformation formula. If <em>sqr</em>
is nonzero, the function instead returns <span class="math notranslate nohighlight">\(0\leq r &lt; 4\)</span> such that
<span class="math notranslate nohighlight">\(\kappa(\mathit{mat})^2 = i^r\)</span> and sets <em>sqrtdet</em> to <span class="math notranslate nohighlight">\(\det(\gamma\tau +
\delta)\)</span>.</p>
<p>By <a class="reference internal" href="references.html#igu1972" id="id3"><span>[Igu1972]</span></a>, p. 176 and <a class="reference internal" href="references.html#mum1983" id="id4"><span>[Mum1983]</span></a>, p. 189, for any symplectic matrix
<span class="math notranslate nohighlight">\(m\)</span>, any <span class="math notranslate nohighlight">\((z,\tau)\in \mathbb{C}^g\times \mathcal{H}_g\)</span>, and any
characteristic <span class="math notranslate nohighlight">\((a,b)\)</span>, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(m\cdot(z,\tau)) = \kappa(m) \zeta_8^{e(m, a, b)} \det(\gamma\tau + \delta)^{1/2} e^{\pi i z^T (\gamma\tau + \delta)^{-1} \gamma z} \theta_{a',b'}(z,\tau)\]</div>
</div></blockquote>
<p>where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\gamma,\delta\)</span> are the lower <span class="math notranslate nohighlight">\(g\times g\)</span> blocks of <span class="math notranslate nohighlight">\(m\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(a',b'\)</span> is another characteristic depending on <span class="math notranslate nohighlight">\(m,a,b\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\zeta_8=\exp(i\pi/4)\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(e(m,a,b)\)</span> is an integer given by an explicit formula in terms of <span class="math notranslate nohighlight">\(m,a,b\)</span>
(this is <span class="math notranslate nohighlight">\(\phi_m\)</span> in Igusa’s notation), and</p></li>
<li><p><span class="math notranslate nohighlight">\(\kappa(m)\)</span> is an 8th root of unity, only well-defined up to sign unless
we choose a particular branch of <span class="math notranslate nohighlight">\(\det(\gamma\tau + \delta)^{1/2}\)</span> on
<span class="math notranslate nohighlight">\(\mathcal{H}_g\)</span>. Hence <span class="math notranslate nohighlight">\(\kappa(m)^2\)</span> is a well-defined 4th root of unity.</p></li>
</ul>
<p>We proceed as follows. After applying <a class="reference internal" href="#c.sp2gz_decompose" title="sp2gz_decompose"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_decompose()</span></code></a>, we only have
to consider four special cases for <em>mat</em>. If <em>mat</em> is trigonal or
block-diagonal, one can compute its action on <span class="math notranslate nohighlight">\(\theta_{0,0}\)</span> directly. If
<em>mat</em> is an embedded matrix from <span class="math notranslate nohighlight">\(\mathrm{SL}_2(\mathbb{Z})\)</span>, we rely on
<a class="reference internal" href="acb_modular.html#c.acb_modular_theta_transform" title="acb_modular_theta_transform"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_modular_theta_transform()</span></code></a>. Finally, if <em>mat</em> is an embedded <span class="math notranslate nohighlight">\(J\)</span>
matrix from dimension <span class="math notranslate nohighlight">\(2\leq r\leq g\)</span>, then <span class="math notranslate nohighlight">\(\kappa(m) \zeta_8^{e(m,0,0)}
i^{r/2} \det(\tau_0)^{1/2} = 1\)</span>, where <span class="math notranslate nohighlight">\(\tau_0\)</span> denotes the upper left
<span class="math notranslate nohighlight">\(r\times r\)</span> submatrix of <span class="math notranslate nohighlight">\(\tau\)</span> and the branch of the square root is chosen
such that the result is <span class="math notranslate nohighlight">\(i^{g/2}\det(Y)\)</span> when <span class="math notranslate nohighlight">\(\tau = iY\)</span> is purely
imaginary.</p>
<p>To compute <span class="math notranslate nohighlight">\(\det(\tau_0)^{1/2}\)</span> (assuming that <em>sqr</em> is false), we pick a
purely imaginary matrix <em>A</em> and consider the polynomial <span class="math notranslate nohighlight">\(P(t) = \det(A +
\tfrac{t+1}{2} (\tau_0 - A))\)</span>. Up to choosing another <span class="math notranslate nohighlight">\(A\)</span>, we may assume
that it has degree <span class="math notranslate nohighlight">\(g\)</span> and that its roots (as complex balls) do not
intersect the segment <span class="math notranslate nohighlight">\([-1,1]\subset \mathbb{C}\)</span>. We then find the correct
branch of <span class="math notranslate nohighlight">\(P(t)^{1/2}\)</span> between <span class="math notranslate nohighlight">\(t=-1\)</span> and <span class="math notranslate nohighlight">\(t=1\)</span> following <a class="reference internal" href="references.html#mn2019" id="id5"><span>[MN2019]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_kappa2">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_kappa2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_kappa2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(0\leq r &lt; 3\)</span> such that <span class="math notranslate nohighlight">\(\kappa(\mathit{mat})^2 = i^r\)</span>, which makes
sense without reference to a branch of <span class="math notranslate nohighlight">\(\det(\gamma\tau +
\delta)^{1/2}\)</span>.</p>
<p>This is a simpler interface to <a class="reference internal" href="#c.acb_siegel_kappa" title="acb_siegel_kappa"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_kappa()</span></code></a> when <em>sqr</em> is true.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_randtest">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_randtest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">mag_bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>tau</em> to a random matrix in <span class="math notranslate nohighlight">\(\mathcal{H}_g\)</span>, possibly far from being
reduced.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_randtest_reduced">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_randtest_reduced</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">mag_bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_randtest_reduced" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>tau</em> to a random reduced matrix in <span class="math notranslate nohighlight">\(\mathcal{H}_g\)</span> whose imaginary
part possibly has large entries.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_randtest_compact">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_randtest_compact</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_randtest_compact" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>tau</em> to a random reduced matrix in <span class="math notranslate nohighlight">\(\mathcal{H}_g\)</span> whose imaginary
part has bounded entries. If <em>exact</em> is nonzero, then the entries of <em>tau</em>
are set to exact (dyadic) complex numbers.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_randtest_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_randtest_vec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_randtest_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>z</em> to a random vector of length <em>g</em>, possibly with large entries.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_siegel_randtest_vec_reduced">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_siegel_randtest_vec_reduced</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_siegel_randtest_vec_reduced" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>zs</em> to the concatenation of <em>nb</em> random vectors <em>z</em> sampled from
<span class="math notranslate nohighlight">\([-1,1]^g + \tau[-1,1]^g\)</span>, i.e. close to being reduced with respect to
<span class="math notranslate nohighlight">\(\tau\)</span>. If <em>exact</em> is nonzero, then the entries of <em>zs</em> are set to exact
(dyadic) complex numbers.</p>
</dd></dl>

</section>
<section id="theta-characteristics">
<h2>Theta characteristics<a class="headerlink" href="#theta-characteristics" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_bit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_bit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ch</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_bit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(j\)</span>-th bit of <em>ch</em> seen as an element of <span class="math notranslate nohighlight">\(\{0,1\}^{n}\)</span> with the
above conventions, counting from <span class="math notranslate nohighlight">\(j=0\)</span> to <span class="math notranslate nohighlight">\(n-1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_get_arb">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_get_arb</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="arb.html#c.arb_ptr" title="arb_ptr"><span class="n"><span class="pre">arb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_get_arb" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_get_acb">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_get_acb</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_get_acb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>v</em> to <span class="math notranslate nohighlight">\(a/2\)</span> seen as an element of <span class="math notranslate nohighlight">\(\mathbb{R}^g\)</span> or <span class="math notranslate nohighlight">\(\mathbb{C}^g\)</span>
respectively.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_dot">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_dot</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_dot" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\sum_{i=0}^{g-1} a_i b_i\)</span> modulo 4 as an integer between 0 and 3,
where <span class="math notranslate nohighlight">\(a_i, b_i\)</span> for <span class="math notranslate nohighlight">\(0\leq i &lt; g\)</span> denote the bits of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>
respectively.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_dot_slong">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_dot_slong</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_dot_slong" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\sum_{i=0}^{g-1} a_i n_i\)</span> modulo 4 as an integer between 0 and 3.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_is_even">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_is_even</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ab</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_is_even" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true iff the characteristic <span class="math notranslate nohighlight">\((a,b)\)</span> is even, i.e. <span class="math notranslate nohighlight">\(a^T b\)</span> is
divisible by 2. Odd characteristics <span class="math notranslate nohighlight">\((a,b)\)</span> have the property that
<span class="math notranslate nohighlight">\(\theta_{a,b}(0,\tau)\)</span> is identically zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_table">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_table</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ch</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">e</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ab</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_table" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <em>all</em> is false, sets <em>ch</em> to the theta characteristic <span class="math notranslate nohighlight">\((a',b')\)</span> and sets
<em>e</em> to <span class="math notranslate nohighlight">\(e(\mathit{mat},a,b)\)</span> as in the transformation formula (see
<a class="reference internal" href="#c.acb_siegel_kappa" title="acb_siegel_kappa"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_kappa()</span></code></a>). If <em>all</em> is true, then <em>ab</em> is ignored, and <em>ch</em>
and <em>e</em> are set to vectors of length <span class="math notranslate nohighlight">\(2^{2g}\)</span> containing this output for
all characteristics from 0 to <span class="math notranslate nohighlight">\(2^{2g}-1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_char_shuffle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_char_shuffle</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sqr</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_char_shuffle" title="Link to this definition">¶</a><br /></dt>
<dd><p>Partially applies the theta transformation formula to the given vector <em>th</em>
for the symplectic matrix <em>mat</em> and stores the output in <em>res</em>. This omits
the <span class="math notranslate nohighlight">\(\kappa\)</span>, determinant, and exponential factors from the formula. If
<em>sqr</em> is nonzero, then <span class="math notranslate nohighlight">\(\zeta_8\)</span> is replaced by <span class="math notranslate nohighlight">\(i\)</span> in the formula to mimic
the transformation formula on squared theta values. This is only used for
testing.</p>
</dd></dl>

</section>
<section id="toolbox-for-derivatives">
<h2>Toolbox for derivatives<a class="headerlink" href="#toolbox-for-derivatives" title="Link to this heading">¶</a></h2>
<p>In this module, we only consider the successive partial derivatives of
<span class="math notranslate nohighlight">\(\theta_{a,b}(z,\tau)\)</span> with respect to the <span class="math notranslate nohighlight">\(g\)</span> coordinates of <span class="math notranslate nohighlight">\(z\)</span>, because
derivatives with respect to <span class="math notranslate nohighlight">\(\tau\)</span> are accounted for by the heat equation</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{\partial\theta_{a,b}}{\partial \tau_{j,k}} = \frac{1}{2\pi i(1 +\delta_{j,k})}
\frac{\partial^2\theta_{a,b}}{\partial z_j \partial z_k}.\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\delta\)</span> is the Kronecker symbol. We encode tuples of derivation orders,
henceforth called “derivation tuples”, as vectors of type <a class="reference internal" href="flint.html#c.slong" title="slong"><code class="xref c c-type docutils literal notranslate"><span class="pre">slong</span></code></a> and
length <span class="math notranslate nohighlight">\(g\)</span>. In agreement with <a class="reference internal" href="acb_modular.html#acb-modular"><span class="std std-ref">acb_modular.h</span></a>, we also
normalize derivatives in the same way as in the Taylor expansion, so that the
tuple <span class="math notranslate nohighlight">\((k_0,\ldots,k_{g-1})\)</span> corresponds to the differential operator</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{1}{k_0!}\cdots\frac{1}{k_{g-1}!} \cdot \frac{\partial^{|k|}}{\partial z_0^{k_0}\cdots \partial z_{g-1}^{k_{g-1}}}\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(|k|:=\sum k_i\)</span>. We always consider all derivation tuples up to a total
order <em>ord</em>, and order them first by their total order, then
reverse-lexicographically. For example, in the case <span class="math notranslate nohighlight">\(g=2\)</span>, the sequence of
orders is <span class="math notranslate nohighlight">\((0,0)\)</span>, <span class="math notranslate nohighlight">\((1,0)\)</span>, <span class="math notranslate nohighlight">\((0,1)\)</span>, <span class="math notranslate nohighlight">\((2,0)\)</span>, <span class="math notranslate nohighlight">\((1,1)\)</span>, etc.</p>
<p>This sections gathers methods to work with partial derivatives of holomorphic
functions in general.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_nb">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_nb</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_nb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of derivation tuples with total order at most <em>ord</em>. The
result is zero if <em>ord</em> is negative.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_total_order">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_total_order</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tup</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_total_order" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the total derivation order for the given tuple <em>tup</em> of length <em>g</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_tuples">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_tuples</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tups</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_tuples" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>tups</em> to the concatenation of all derivation tuples up to total order
<em>ord</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_index">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_index</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tup</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_index" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <em>n</em> such that <em>tup</em> is the <span class="math notranslate nohighlight">\(n\)</span>-th derivation tuple of
length <em>g</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_mul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v1</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v2</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_mul" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the vector of derivatives of the product <span class="math notranslate nohighlight">\(fg\)</span>, assuming that
<em>v1</em> and <em>v2</em> contains the derivatives of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> respectively.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_compose">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_compose</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_compose" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the vector of derivatives of the composition <span class="math notranslate nohighlight">\(f(Nz)\)</span>,
assuming that <em>v</em> contains the derivatives of <em>f</em> at the point <span class="math notranslate nohighlight">\(Nz\)</span>. The
dimension <span class="math notranslate nohighlight">\(g\)</span> is obtained as the size of the square matrix <span class="math notranslate nohighlight">\(N\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_exp_pi_i">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_exp_pi_i</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="arb.html#c.arb_srcptr" title="arb_srcptr"><span class="n"><span class="pre">arb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_exp_pi_i" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the vector of derivatives of the function <span class="math notranslate nohighlight">\(\exp(\pi i (a_0
z_1 + \cdots + a_{g-1} z_{g-1}))\)</span> at <span class="math notranslate nohighlight">\(z = 0\)</span>, where <span class="math notranslate nohighlight">\(a_0,\ldots a_{g-1}\)</span> are
the entries of <em>a</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_exp_qf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_exp_qf</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_exp_qf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the vector of derivatives of the function <span class="math notranslate nohighlight">\(\exp(\pi i z^T N
z)\)</span> at the chosen point <span class="math notranslate nohighlight">\(z\)</span>. The dimension <span class="math notranslate nohighlight">\(g\)</span> is obtained as the size of
the square matrix <span class="math notranslate nohighlight">\(N\)</span>.</p>
</dd></dl>

</section>
<section id="ellipsoids">
<h2>Ellipsoids<a class="headerlink" href="#ellipsoids" title="Link to this heading">¶</a></h2>
<p>The most direct way of evaluating Riemann theta functions consists in
evaluating a partial sum of the exponential series defining them, then adding
an error bound coming from the tail of the series. We refer to this strategy as
the <em>summation algorithms</em>.</p>
<p>The upper bound on the tail is obtained from the triangle inequality. First, we
use the relation</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(z,\tau) = \exp(\pi i a^T (z + \tfrac b2) + \pi i a^T \tau a/4) \theta_{0,b}(z + \tau\tfrac{a}{2},\tau)\]</div>
</div></blockquote>
<p>to avoid summing over <span class="math notranslate nohighlight">\(\mathbb{Z}^g + \tfrac{a}{2}\)</span> with a nonzero <span class="math notranslate nohighlight">\(a\)</span>. Next,
to analyze the absolute value of each term in the sum defining
<span class="math notranslate nohighlight">\(\theta_{0,b}(z,\tau)\)</span>, we write:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\bigl| \exp(i\pi n^T \tau n + 2n^T (z + \tfrac{b}{2}) \bigr| = \exp(\pi y^T Y^{-1} y) \exp (-\lVert n + Y^{-1}y \rVert_\tau^2)\]</div>
</div></blockquote>
<p>(notation as in the introduction). Thus, the exponential terms whose absolute
values are less than a given threshold correspond to lattice points <span class="math notranslate nohighlight">\(n\in
\mathbb{Z}^g\)</span> lying outside a certain ball centered in <span class="math notranslate nohighlight">\(v = -Y^{-1}y\)</span> for
<span class="math notranslate nohighlight">\(\lVert\cdot\rVert_\tau\)</span>; in other words, we should be computing partial sums
over points <span class="math notranslate nohighlight">\(n\in \mathbb{Z}^g\)</span> lying in certain ellipsoids, as in
<a class="reference internal" href="references.html#dhbhs2004" id="id6"><span>[DHBHS2004]</span></a>. This section gathers methods to manipulate such ellipsoids
directly.</p>
<p>Fix an upper-triangular matrix <span class="math notranslate nohighlight">\(C\)</span> with positive diagonal entries (henceforth
called a “Cholesky matrix”), a radius <span class="math notranslate nohighlight">\(R\geq 0\)</span>, a vector <span class="math notranslate nohighlight">\(v\in \mathbb{R}^g\)</span>,
and <span class="math notranslate nohighlight">\(1\leq d\leq g\)</span>. Consider the ellipsoid <span class="math notranslate nohighlight">\(E\)</span> consisting of points <span class="math notranslate nohighlight">\(n =
(n_0,\ldots,n_{g-1})\)</span> satisfying <span class="math notranslate nohighlight">\((v + Cn)^T (v + Cn)\leq R^2\)</span> and such that
their last coordinates <span class="math notranslate nohighlight">\(n_{d},\ldots, n_{g-1}\)</span> are fixed. We encode <span class="math notranslate nohighlight">\(E\)</span> as
follows: we store the endpoints and midpoint of the interval of allowed values
for <span class="math notranslate nohighlight">\(n_{d-1}\)</span> as <a class="reference internal" href="flint.html#c.slong" title="slong"><code class="xref c c-type docutils literal notranslate"><span class="pre">slong</span></code></a>’s, and if <span class="math notranslate nohighlight">\(d\geq 1\)</span>, we store a
<span class="math notranslate nohighlight">\((d-1)\)</span>-dimensional “child” of <span class="math notranslate nohighlight">\(E\)</span> for each value of <span class="math notranslate nohighlight">\(n_{d-1}\)</span> as another
ellipsoid in a recursive way. Children are partitioned between left and right
children depending on the position of <span class="math notranslate nohighlight">\(n_{d-1}\)</span> relative to the midpoint. When
<span class="math notranslate nohighlight">\(d=g\)</span> and for a fixed Cholesky matrix <span class="math notranslate nohighlight">\(C\)</span>, this representation uses
<span class="math notranslate nohighlight">\(O(R^{g-1})\)</span> space for an ellipsoid of radius <span class="math notranslate nohighlight">\(R\)</span> containing approximately
<span class="math notranslate nohighlight">\(O(R^{g})\)</span> points.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.acb_theta_eld_struct">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_struct</span></span></span><a class="headerlink" href="#c.acb_theta_eld_struct" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.acb_theta_eld_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_t</span></span></span><a class="headerlink" href="#c.acb_theta_eld_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>An <a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_eld_t</span></code></a> is an array of length one of type
<a class="reference internal" href="#c.acb_theta_eld_struct" title="acb_theta_eld_struct"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_eld_struct</span></code></a> encoding an ellipsoid as described above,
alllowing it to be passed by reference.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initializes <em>E</em> as a <em>d</em>-dimensional ellipsoid in ambient dimension <em>g</em>. We
require <span class="math notranslate nohighlight">\(1\leq d\leq g\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears <em>E</em> as well as any recursive data contained in it.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_set">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="arb_mat.html#c.arb_mat_t" title="arb_mat_t"><span class="n"><span class="pre">arb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="arf.html#c.arf_t" title="arf_t"><span class="n"><span class="pre">arf_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R2</span></span>, <a class="reference internal" href="arb.html#c.arb_srcptr" title="arb_srcptr"><span class="n"><span class="pre">arb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <em>C</em> is upper-triangular with positive diagonal entries,
attempts to set <em>E</em> to represent an ellipsoid as defined above, where <em>R2</em>
indicates <span class="math notranslate nohighlight">\(R^2\)</span>, and returns 1 upon success. If the ellipsoid points do not
fit in <a class="reference internal" href="flint.html#c.slong" title="slong"><code class="xref c c-type docutils literal notranslate"><span class="pre">slong</span></code></a>’s or if the ellipsoid is unreasonably large, returns 0
instead and leaves <em>E</em> undefined.</p>
</dd></dl>

<p>The following functions are available after <em>E</em> has been initialized and then
computed using <a class="reference internal" href="#c.acb_theta_eld_init" title="acb_theta_eld_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_init()</span></code></a> and <a class="reference internal" href="#c.acb_theta_eld_set" title="acb_theta_eld_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_set()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_nb_pts">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_nb_pts</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_nb_pts" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of points contained in <span class="math notranslate nohighlight">\(E\)</span>, which is stored in the data
structure.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_points">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_points</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_points" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>pts</em> to the list of all the points in <span class="math notranslate nohighlight">\(E\)</span>, as a concatenation of
vectors of length <em>g</em>. The vector <em>pts</em> must be pre-allocated to the
correct length.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_box">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_box</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_box" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns an upper bound on the absolute value of the <span class="math notranslate nohighlight">\(j\)</span>-th coordinate of any
point stored in <em>E</em>. We require <span class="math notranslate nohighlight">\(0\leq j &lt; g\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_nb_border">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_nb_border</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_nb_border" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of points in the “border” of <span class="math notranslate nohighlight">\(E\)</span>, a certain set of
points lying just outside <span class="math notranslate nohighlight">\(E\)</span>. This number is stored in the data structure.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_border">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_border</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_border" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>pts</em> to the list of all the points in the border of <span class="math notranslate nohighlight">\(E\)</span>. The vector
<em>pts</em> must be pre-allocated to the correct length. This is only used for
testing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_contains">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_contains</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_contains" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true (nonzero) iff <em>pt</em> is contained in <span class="math notranslate nohighlight">\(E\)</span>. The vector <em>pt</em> must
be of length <em>g</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_print">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_print</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints a faithful description of <span class="math notranslate nohighlight">\(E\)</span>. This may be unwieldy in high
dimensions.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_eld_distances">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_eld_distances</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="arb.html#c.arb_ptr" title="arb_ptr"><span class="n"><span class="pre">arb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">ds</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_eld_distances" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>ds</em> to the concatenation of the following <em>nb</em> vectors of length
<span class="math notranslate nohighlight">\(2^g\)</span>: for each input vector <span class="math notranslate nohighlight">\(z\)</span>, we compute <span class="math notranslate nohighlight">\(\mathrm{Dist}_\tau(-Y^{-1}y,
\mathbb{Z}^g + \tfrac a2)^2\)</span> for all <span class="math notranslate nohighlight">\(a\in \{0,1\}^g\)</span>, where
<span class="math notranslate nohighlight">\(\mathrm{Dist}_\tau\)</span> denotes the distance attached to <span class="math notranslate nohighlight">\(\lVert \cdot
\rVert_\tau\)</span>.</p>
<p>We first round the coordinates of <span class="math notranslate nohighlight">\(-Y^{-1}y\)</span> to obtain an element of
<span class="math notranslate nohighlight">\(\mathbb{Z}^g + \tfrac{a}{2}\)</span> providing an upper bound on the distance,
then enumerate all the points in the ellipsoid of that radius to find all
the closer points, if any.</p>
</dd></dl>

</section>
<section id="error-bounds-in-summation-algorithms">
<h2>Error bounds in summation algorithms<a class="headerlink" href="#error-bounds-in-summation-algorithms" title="Link to this heading">¶</a></h2>
<p>To compute the correct ellipsoids in summation algorithms for a target working
precision, we use the following upper bound on the tail of the series: by
<a class="reference internal" href="references.html#ek2025" id="id7"><span>[EK2025]</span></a>, for any <span class="math notranslate nohighlight">\(v\in \mathbb{R}^g\)</span>, any upper-triangular Cholesky matrix
<span class="math notranslate nohighlight">\(C\)</span>, any nonnegative <em>ord</em>, and any <span class="math notranslate nohighlight">\(R\geq 0\)</span>, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\sum_{n\in C\mathbb{Z}^g + Cv,\ \lVert n\rVert^2 \geq R^2} \lVert n\rVert^{\mathit{ord}} e^{-\lVert n\rVert^2}
\leq (1 + \sqrt{\tfrac{8}{\pi}}) \max\{2,R\}^{g-1} R^{p} e^{-R^2} \prod_{j=0}^{g-1} (1 + \tfrac{\sqrt{2\pi}}{\gamma_j})\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\gamma_0,\ldots, \gamma_{g-1}\)</span> are the diagonal coefficients of
<span class="math notranslate nohighlight">\(C\)</span>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum_radius">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum_radius</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="arf.html#c.arf_t" title="arf_t"><span class="n"><span class="pre">arf_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R2</span></span>, <a class="reference internal" href="arf.html#c.arf_t" title="arf_t"><span class="n"><span class="pre">arf_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">eps</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="arb_mat.html#c.arb_mat_t" title="arb_mat_t"><span class="n"><span class="pre">arb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cho</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum_radius" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>eps</em> to <span class="math notranslate nohighlight">\(2^{-\mathit{prec}}\)</span> and chooses <em>R2</em> such that the above
upper bound for <em>R2</em> and the given <em>ord</em> is at most <em>eps</em>, where <span class="math notranslate nohighlight">\(C\)</span> is
<em>cho</em>. When <em>ord = 0</em>, the square root of <em>R2</em> is a suitable ellipsoid
radius for a partial sum of the theta series, and <em>eps</em> is an upper bound
on the absolute value of the tail of the series defining
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,b}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum_jet_radius">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum_jet_radius</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="arf.html#c.arf_t" title="arf_t"><span class="n"><span class="pre">arf_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R2</span></span>, <a class="reference internal" href="arf.html#c.arf_t" title="arf_t"><span class="n"><span class="pre">arf_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">eps</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="arb_mat.html#c.arb_mat_t" title="arb_mat_t"><span class="n"><span class="pre">arb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cho</span></span>, <a class="reference internal" href="arb.html#c.arb_srcptr" title="arb_srcptr"><span class="n"><span class="pre">arb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum_jet_radius" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes a suitable squared radius <em>R2</em> and error bound <em>eps</em> on the tail
of the theta series as in <a class="reference internal" href="#c.acb_theta_sum_radius" title="acb_theta_sum_radius"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_radius()</span></code></a>, but in the context
of evaluating partial derivatives of theta functions up to order <em>ord</em>. The
input vector <em>v</em> should be <span class="math notranslate nohighlight">\(-C Y^{-1}y\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is the Cholesky matrix
for <span class="math notranslate nohighlight">\(\pi Y\)</span>.</p>
<p>We can rewrite the the differentiated series as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 \frac{\partial^{|k|}\theta_{a,b}}{\partial z_0^{k_0}\cdots \partial z_{g-1}^{k_{g-1}}}(z,\tau)
 &amp; = (2\pi i)^{|k|} \sum_{n\in \mathbb{Z}^g + \tfrac a2} n_0^{k_0} \cdots n_{g-1}^{k_{g-1}}
 e^{\pi i n^T \tau n + 2\pi i n^T (z + \tfrac b2)}\\
 &amp;= (2\pi i)^{|k|} e^{\pi y^T Y^{-1} y} \sum_{n\in \mathbb{Z}^g + \tfrac a2}
 n_0^{k_0} \cdots n_{g-1}^{k_{g-1}} \xi_n e^{-\pi (n + Y^{-1}y)^T Y (n + Y^{-1}y)}.
 \end{aligned}\end{split}\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(|\xi_n| = 1\)</span>. We ignore the leading multiplicative factor. Writing <span class="math notranslate nohighlight">\(m = C n + v\)</span>, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[n_0^{k_0}\cdots n_{g-1}^{k_{g-1}}\leq
(\lVert C^{-1}\rVert_\infty \lVert n\rVert_2 + \lVert Y^{-1}y\rVert_\infty)^{|k|}.\]</div>
</div></blockquote>
<p>Using the upper bound from <a class="reference internal" href="#c.acb_theta_sum_radius" title="acb_theta_sum_radius"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_radius()</span></code></a>, we see that the
absolute value of the tail of the series, when summing outside the
ellipsoid centered in <span class="math notranslate nohighlight">\(v\)</span> of radius <span class="math notranslate nohighlight">\(R\)</span>, is bounded above by</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[(\lVert C^{-1} \rVert_\infty R + \lVert Y^{-1}y \rVert_\infty)^{|k|}
 2^{2g+2} R^{g-1} e^{-R^2} \prod_{j=0}^{g-1} (1 + \gamma_j^{-1}).\]</div>
</div></blockquote>
<p>The output values <em>R2</em> and <em>eps</em> are such that this upper bound is at most
<em>eps</em> when <span class="math notranslate nohighlight">\(R\)</span> is the square root of <em>R2</em>.</p>
<p>To obtain them, we first compute <em>R2</em> and <em>eps</em> using
<a class="reference internal" href="#c.acb_theta_sum_radius" title="acb_theta_sum_radius"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_radius()</span></code></a> with <em>ord</em> = 0. If <span class="math notranslate nohighlight">\(R\leq \lVert
Y^{-1}y\rVert_\infty/\lVert C^{-1}\rVert_\infty\)</span>, we simply multiply <em>eps</em>
by <span class="math notranslate nohighlight">\(\max\{1, 2 \lVert Y^{-1}y \rVert_\infty\}^{\mathit{ord}}\)</span>. Otherwise,
we compute <em>R2</em> and <em>eps</em> using <a class="reference internal" href="#c.acb_theta_sum_radius" title="acb_theta_sum_radius"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_radius()</span></code></a> with the given
value of <em>ord</em>. We can then set <em>R2</em> to the maximum of <em>R2</em> and <span class="math notranslate nohighlight">\(\lVert
Y^{-1}y \rVert_\infty /\lVert C^{-1} \rVert_\infty\)</span>, and multiply <em>eps</em> by
<span class="math notranslate nohighlight">\(\max\{1, 2\lVert C^{-1}\rVert_\infty\}^{\mathit{ord}}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum_term">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum_term</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tup</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum_term" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to <span class="math notranslate nohighlight">\(n_0^{k_0} \cdots n_{g-1}^{k_{g-1}}\exp(\pi i(n^T \tau n + 2
n^T z))\)</span>, where the <span class="math notranslate nohighlight">\(k_j\)</span> and <span class="math notranslate nohighlight">\(n_j\)</span> denotes the <span class="math notranslate nohighlight">\(j\)</span>-th entry in <em>tup</em> and
<em>n</em> respectively. The vector <em>tup</em> may be <em>NULL</em>, which is understood to
mean the zero tuple. This is only used for testing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum_addprec">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum_addprec</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="arb.html#c.arb_t" title="arb_t"><span class="n"><span class="pre">arb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum_addprec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns an integer that is close to <span class="math notranslate nohighlight">\(d/\log(2)\)</span> if <em>d</em> is
finite and of reasonable size, and otherwise returns 0.</p>
</dd></dl>

</section>
<section id="context-structures-in-summation-algorithms">
<h2>Context structures in summation algorithms<a class="headerlink" href="#context-structures-in-summation-algorithms" title="Link to this heading">¶</a></h2>
<p>After the relevant ellipsoid has been computed, summation algorithms only
involve exponential terms in <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(z\)</span>. Sometimes, especially in the
setting of the quasi-linear algorithms below, these exponentials can be
computed once, and then used for several calls to summation functions. This
section introduces context structures to make these manipulations easier.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.acb_theta_ctx_tau_struct">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_tau_struct</span></span></span><a class="headerlink" href="#c.acb_theta_ctx_tau_struct" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.acb_theta_ctx_tau_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></span><a class="headerlink" href="#c.acb_theta_ctx_tau_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>An <a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_t</span></code></a> is an array of length one of type
<a class="reference internal" href="#c.acb_theta_ctx_tau_struct" title="acb_theta_ctx_tau_struct"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_struct</span></code></a> containing all the necessary data to run
the summation algorithm on a given matrix <span class="math notranslate nohighlight">\(\tau\in\mathcal{H}_g\)</span>. In
particular, it contains a matrix <em>exp_tau_div_4</em> whose <span class="math notranslate nohighlight">\((j,k)\)</span> entry (when
<span class="math notranslate nohighlight">\(j\leq k\)</span>) is <span class="math notranslate nohighlight">\(\exp(\pi i (2 - \delta_{j,k}) \tau_{j,k}/4)\)</span>, where <span class="math notranslate nohighlight">\(\delta\)</span>
denotes the Kronecker symbol. It also contains the Cholesky matrix for <span class="math notranslate nohighlight">\(\pi
Y\)</span> if <span class="math notranslate nohighlight">\(g&gt;1\)</span>.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_struct">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_struct</span></span></span><a class="headerlink" href="#c.acb_theta_ctx_z_struct" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></span><a class="headerlink" href="#c.acb_theta_ctx_z_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>An <a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_z_t</span></code></a> is an array of length one of type
<a class="reference internal" href="#c.acb_theta_ctx_z_struct" title="acb_theta_ctx_z_struct"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_z_struct</span></code></a> containing all the necessary data to run the
summation algorithm on a given vector <span class="math notranslate nohighlight">\(z\)</span> (provided that an element of type
<a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_t</span></code></a> is also given.) In particular, it contains the
values <span class="math notranslate nohighlight">\(\exp(2\pi i z_j)\)</span> for all <span class="math notranslate nohighlight">\(1\leq j\leq g\)</span>. If <span class="math notranslate nohighlight">\(g&gt;1\)</span>, it also
contains the center of the ellipsoids used in summation algorithms at <span class="math notranslate nohighlight">\(z\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_tau_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_tau_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">allow_shift</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_tau_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initializes <em>ctx</em> for use in dimension <em>g</em>. If <em>allow_shift</em> is nonzero,
then additional fields in <em>ctx</em> are initialized to allow for the evaluation
of theta functions <span class="math notranslate nohighlight">\(\theta_{a,0}\)</span> for nonzero <span class="math notranslate nohighlight">\(a\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_tau_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_tau_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_tau_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears <em>ctx</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initializes <em>ctx</em> for use in dimension <em>g</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears <em>ctx</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_vec_init">
<a class="reference internal" href="#c.acb_theta_ctx_z_struct" title="acb_theta_ctx_z_struct"><span class="n"><span class="pre">acb_theta_ctx_z_struct</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_vec_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_vec_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to a vector of <em>nb</em> initialized elements of type
<a class="reference internal" href="#c.acb_theta_ctx_z_struct" title="acb_theta_ctx_z_struct"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_z_struct</span></code></a> in dimension <span class="math notranslate nohighlight">\(g\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_vec_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_vec_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_z_struct" title="acb_theta_ctx_z_struct"><span class="n"><span class="pre">acb_theta_ctx_z_struct</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_vec_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears the elements of type <a class="reference internal" href="#c.acb_theta_ctx_z_struct" title="acb_theta_ctx_z_struct"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_z_struct</span></code></a> pointed to by
<em>vec</em> as well as the pointer itself.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_exp_inv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_exp_inv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp_inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">is_real</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_exp_inv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a complex value <em>x</em> and given <em>exp</em> containing <span class="math notranslate nohighlight">\(\exp(\pi i x)\)</span>, sets
<em>exp_inv</em> to <span class="math notranslate nohighlight">\(\exp(-\pi i x)\)</span>.</p>
<p>This is computed by complex conjugation from <em>exp</em> if the boolean <em>is_real</em>
is nonzero. Otherwise, it is computed by inverting <em>exp</em>, except if the
result is indeterminate, in which case we recompute <em>exp_inv</em> from <em>x</em>
directly.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_sqr_inv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_sqr_inv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">sqr_inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">sqr</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">is_real</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_sqr_inv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <em>inv</em> and <em>sqr</em> containing complex values <span class="math notranslate nohighlight">\(\exp(-\pi i x)\)</span> and
<span class="math notranslate nohighlight">\(\exp(2\pi i x)\)</span> respectively, sets <em>sqr_inv</em> to <span class="math notranslate nohighlight">\(\exp(-2\pi i x)\)</span>.</p>
<p>This uses complex conjugation from <em>sqr</em> if <em>is_real</em> is nonzero, and
otherwise a complex squaring from <em>inv</em>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_tau_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_tau_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_tau_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes and stores in <em>ctx</em> the required data for the input matrix
<span class="math notranslate nohighlight">\(\tau\)</span>. The dimensions must match.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_tau_dupl">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_tau_dupl</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_tau_dupl" title="Link to this definition">¶</a><br /></dt>
<dd><p>Modifies <em>ctx</em> in place to correspond to the matrix <span class="math notranslate nohighlight">\(2\tau\)</span> instead of
<span class="math notranslate nohighlight">\(\tau\)</span>. This is much cheaper than calling <a class="reference internal" href="#c.acb_theta_ctx_tau_set" title="acb_theta_ctx_tau_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_set()</span></code></a>
again.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_tau_overlaps">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_tau_overlaps</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_tau_overlaps" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true iff the data contained in <em>ctx1</em> and <em>ctx2</em> overlap in the
sense of <a class="reference internal" href="acb.html#c.acb_overlaps" title="acb_overlaps"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_overlaps()</span></code></a>. This is only used for testing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx_tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes and stores in <em>ctx</em> the required data for the complex vector
<em>z</em>. Here <em>ctx_tau</em> should contain context data for the matrix <span class="math notranslate nohighlight">\(\tau\)</span>. The
dimensions must match.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_dupl">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_dupl</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_dupl" title="Link to this definition">¶</a><br /></dt>
<dd><p>Modifies <em>ctx</em> in place to correspond to the pair <span class="math notranslate nohighlight">\((2z,2\tau)\)</span> instead of
<span class="math notranslate nohighlight">\((z,\tau)\)</span>. This is much cheaper than calling <a class="reference internal" href="#c.acb_theta_ctx_z_set" title="acb_theta_ctx_z_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ctx_z_set()</span></code></a>
again.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_add_real">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_add_real</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx_real</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_add_real" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <em>ctx</em> and <em>ctx_real</em> correspond to pairs <span class="math notranslate nohighlight">\((z,\tau)\)</span> and <span class="math notranslate nohighlight">\((t,
\tau)\)</span> respectively where <span class="math notranslate nohighlight">\(t\)</span> is a real vector, sets <em>res</em> to a valid
context for the pair <span class="math notranslate nohighlight">\((z + t,\tau)\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_common_v">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_common_v</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="arb.html#c.arb_ptr" title="arb_ptr"><span class="n"><span class="pre">arb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_z_struct" title="acb_theta_ctx_z_struct"><span class="n"><span class="pre">acb_theta_ctx_z_struct</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_common_v" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a vector <em>vec</em> of valid contexts for pairs
<span class="math notranslate nohighlight">\((z_1,\tau),\ldots,(z_n,\tau)\)</span>, sets <em>v</em> to a valid ellipsoid center for
use in <a class="reference internal" href="#c.acb_theta_eld_set" title="acb_theta_eld_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_set()</span></code></a> when running the summation algorithm for
all these pairs, constructed using <a class="reference internal" href="arb.html#c.arb_union" title="arb_union"><code class="xref c c-func docutils literal notranslate"><span class="pre">arb_union()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ctx_z_overlaps">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ctx_z_overlaps</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><span class="n"><span class="pre">acb_theta_ctx_z_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ctx_z_overlaps" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true iff the data contained in <em>ctx1</em> and <em>ctx2</em> overlap in the
sense of <a class="reference internal" href="acb.html#c.acb_overlaps" title="acb_overlaps"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_overlaps()</span></code></a>. This is only used for testing.</p>
</dd></dl>

</section>
<section id="summation-algorithms">
<h2>Summation algorithms<a class="headerlink" href="#summation-algorithms" title="Link to this heading">¶</a></h2>
<p>In this module, summation algorithms are mainly used for low to moderate
precisions due to their higher asymptotic complexity. Since summations at low
precisions are a key step in the quasi-linear algorithms, the summation
functions below optimized in many ways and should already compare favorably to
other software packages that evaluate theta functions.</p>
<p>We always assume in this section that the inpits <span class="math notranslate nohighlight">\((z,\tau)\)</span> have been
reduced. In particular, this allows us to use only one ellipsoid when several
vectors <span class="math notranslate nohighlight">\(z\)</span> are given.</p>
<p>After the relevant ellipsoid <em>E</em> has been computed, the main worker inside each
version of the summation algorithm processes one line (i.e. 1-dimensional
ellipsoid) in <em>E</em>. Before calling this worker, for fixed <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(z\)</span> and
fixed coordinates <span class="math notranslate nohighlight">\(n_1,\ldots n_{g-1}\)</span> defining a line inside the ellipsoid, if
<span class="math notranslate nohighlight">\(n_{\mathrm{min}}\)</span> are <span class="math notranslate nohighlight">\(n_{\mathrm{max}}\)</span> are the endpoints of the interval of
allowed values for <span class="math notranslate nohighlight">\(n_0\)</span>, we (efficiently) compute:</p>
<ul>
<li><p>the vector <span class="math notranslate nohighlight">\(v_1\)</span> with entries <span class="math notranslate nohighlight">\(\exp(\pi i j^2 \tau_{0,0})\)</span> for
<span class="math notranslate nohighlight">\(n_{\mathrm{min}}\leq j\leq n_{\mathrm{max}}\)</span>,</p></li>
<li><p>the vector <span class="math notranslate nohighlight">\(v_2\)</span> with entries <span class="math notranslate nohighlight">\(x^j\)</span> for <span class="math notranslate nohighlight">\(n_{\mathrm{min}}\leq j\leq
n_{\mathrm{max}}\)</span>, where</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[x = \exp(2 \pi i z_0) \prod_{k = 1}^{g-1} \exp(2 \pi i n_k \tau_{0,k}),\]</div>
</div></blockquote>
</li>
<li><p>the cofactor <span class="math notranslate nohighlight">\(c\in \mathbb{C}\)</span> given by</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[c = \prod_{k = 1}^{g-1} \exp(2 \pi i n_k z_k) \cdot
\prod_{1\leq j\leq k &lt; g} \exp(\pi i (2 - \delta_{j,k}) n_j n_k \tau_{j,k}).\]</div>
</div></blockquote>
</li>
</ul>
<p>This allow us to use <a class="reference internal" href="acb.html#c.acb_dot" title="acb_dot"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_dot()</span></code></a> in the workers while maintaining
reasonable memory costs, and to use an average of strictly less than two
complex multiplications per lattice point as <span class="math notranslate nohighlight">\(R\to \infty\)</span>. Moreover, these
multiplications are performed at only a fraction of the full precision for
lattice points far from the ellipsoid center. The different versions of the
summation algorithm rely on slightly different workers, so introducing a
function pointer type is helpful to avoid code duplication.</p>
<p>When <span class="math notranslate nohighlight">\(g=1\)</span>, the code does not rely on ellipsoids and worker functions, and
calls <a class="reference internal" href="acb_modular.html#c.acb_modular_theta_sum" title="acb_modular_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_modular_theta_sum()</span></code></a> from <a class="reference internal" href="acb_modular.html#acb-modular"><span class="std std-ref">acb_modular.h</span></a>
instead.</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.acb_theta_sum_worker_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum_worker_t</span></span></span><a class="headerlink" href="#c.acb_theta_sum_worker_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>A function pointer type. A function <em>worker</em> of this type has the
following signature:</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum_worker_t.worker">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">worker</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v1</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">v2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">precs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coords</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">fullprec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum_worker_t.worker" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>where:</p>
<ul class="simple">
<li><p><em>th</em> denotes the output vector of theta values to which terms are added,</p></li>
<li><p><em>v1</em>, <em>v2</em> and <em>c</em> are precomputed as above,</p></li>
<li><p><em>precs</em> contains working precisions for each term <span class="math notranslate nohighlight">\(n_{\mathrm{min}}\leq
j\leq n_{\mathrm{max}}\)</span>,</p></li>
<li><p><em>len</em> <span class="math notranslate nohighlight">\(= n_{\mathrm{max}} - n_{\mathrm{min}} + 1\)</span> is the common length of
<em>v1</em>, <em>v2</em> and <em>precs</em>,</p></li>
<li><p><em>coords</em> is <span class="math notranslate nohighlight">\((n_{\mathrm{min}}, n_1, \ldots, n_{g-1})\)</span>,</p></li>
<li><p><em>ord</em> is the maximal derivation order,</p></li>
<li><p><em>prec</em> is the working precision for this line inside the ellipsoid, and
finally</p></li>
<li><p><em>fullprec</em> is the working precision for summing into <em>th</em>.</p></li>
</ul>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum_sqr_pow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum_sqr_pow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sqr_pow</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp_tau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum_sqr_pow" title="Link to this definition">¶</a><br /></dt>
<dd><p>For each <span class="math notranslate nohighlight">\(0\leq j\leq g-1\)</span>, sets <em>sqr_pow[j]</em> to a vector of length <span class="math notranslate nohighlight">\(B_j +
1\)</span> containing <span class="math notranslate nohighlight">\(e_j^{n^2}\)</span> for <span class="math notranslate nohighlight">\(0\leq n \leq B_j\)</span>, where <span class="math notranslate nohighlight">\(B_j\)</span> is an upper
bound on the absolute values of <span class="math notranslate nohighlight">\(j\)</span>-th coordinates of points in <em>E</em>
(obtained by <a class="reference internal" href="#c.acb_theta_eld_box" title="acb_theta_eld_box"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_box()</span></code></a>) and <span class="math notranslate nohighlight">\(e_{j}\)</span> is the <span class="math notranslate nohighlight">\(j\)</span>-th diagonal
entry of <em>exp_tau</em>. The entries of <em>sqr_pow</em> need to be preallocated to the
correct lengths.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum_work">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum_work</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp_z</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp_z_inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp_tau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp_tau_inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sqr_pow</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_eld_t" title="acb_theta_eld_t"><span class="n"><span class="pre">acb_theta_eld_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">E</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span>, <a class="reference internal" href="#c.acb_theta_sum_worker_t" title="acb_theta_sum_worker_t"><span class="n"><span class="pre">acb_theta_sum_worker_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">worker</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum_work" title="Link to this definition">¶</a><br /></dt>
<dd><p>Runs the summation algorithm on the ellipsoid <em>E</em>, assuming <span class="math notranslate nohighlight">\(g\geq 2\)</span>. The input is as follows:</p>
<ul class="simple">
<li><p>for each <span class="math notranslate nohighlight">\(1\leq j\leq k\leq g\)</span>, the <span class="math notranslate nohighlight">\((j,k)\)</span> entries of the matrices <em>exp_tau</em>
and <em>exp_tau_inv</em> whose should contain <span class="math notranslate nohighlight">\(\exp(\pi i (2 -
\delta_{j,k}) \tau_{j,k})\)</span> and its inverse, respectively.</p></li>
<li><p><em>E</em> is the ellipsoid we want to sum on.</p></li>
<li><p><em>sqr_pow</em> should be as output by <a class="reference internal" href="#c.acb_theta_sum_sqr_pow" title="acb_theta_sum_sqr_pow"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_sqr_pow()</span></code></a> on
<em>exp_tau</em> and <em>E</em>.</p></li>
<li><p>the vectors <em>exp_zs</em> and <em>exp_zs_inv</em> should have length <em>nb</em> times
<em>g</em>. For each <span class="math notranslate nohighlight">\(z\)</span> stored in <em>zs</em>, the corresponding pieces of <em>exp_zs</em>
and <em>exp_zs_inv</em> should contain <span class="math notranslate nohighlight">\(\exp(\pi i z_j)\)</span> for <span class="math notranslate nohighlight">\(1\leq j\leq g\)</span> and
their inverses, respectively.</p></li>
<li><p>the parameters <em>len</em>, <em>ord</em> and the output vector <em>th</em> are passed to
<em>worker</em> when processing each individual line in <em>E</em>.</p></li>
</ul>
<p>The data associated with <em>zs</em> and <span class="math notranslate nohighlight">\(\tau\)</span> is typically stored in contexts of
type <a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_t</span></code></a> and <a class="reference internal" href="#c.acb_theta_ctx_z_t" title="acb_theta_ctx_z_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">acb_theta_ctx_z_t</span></code></a>
respectively. No error bound coming from the tail of the theta series is
added.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_z_struct" title="acb_theta_ctx_z_struct"><span class="n"><span class="pre">acb_theta_ctx_z_struct</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx_tau</span></span>, <a class="reference internal" href="arb.html#c.arb_srcptr" title="arb_srcptr"><span class="n"><span class="pre">arb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">distances</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all_a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all_b</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">tilde</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates theta functions at each of the <em>nb</em> pairs <span class="math notranslate nohighlight">\((z,\tau)\)</span>
corresponding to a context stored in <em>vec</em> together with <em>ctx_tau</em> using
summation. Precisely what we compute depends on the parameters <em>all_a</em>,
<em>all_b</em> and <em>tilde</em>:</p>
<ul class="simple">
<li><p>if <em>all_a</em> is false (zero), we only compute <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span> for <span class="math notranslate nohighlight">\(a=0\)</span>,
otherwise <span class="math notranslate nohighlight">\(a\)</span> varies from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(2^g - 1\)</span>.</p></li>
<li><p>if <em>all_b</em> is false (zero), we only compute <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span> for <span class="math notranslate nohighlight">\(b=0\)</span>,
otherwise <span class="math notranslate nohighlight">\(b\)</span> varies from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(2^g - 1\)</span>.</p></li>
<li><p>if <em>tilde</em> is true (nonzero), then we compute <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,b}\)</span>
instead of <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span>.</p></li>
</ul>
<p>In this function, the absolute error radius we add from the tail of the
exponential series depend on <span class="math notranslate nohighlight">\(a\)</span>. The amount of precision added is
controlled by <em>distances</em>, a vector of length <span class="math notranslate nohighlight">\(2^g\)</span> (the same for all
vectors <em>z</em>). One could for instance set <em>distances</em> to zero, or compute it
as in <a class="reference internal" href="#c.acb_theta_eld_distances" title="acb_theta_eld_distances"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a>, which makes sense when the different
values of <em>z</em> differ by real vectors.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_sum_jet">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_sum_jet</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_z_struct" title="acb_theta_ctx_z_struct"><span class="n"><span class="pre">acb_theta_ctx_z_struct</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.acb_theta_ctx_tau_t" title="acb_theta_ctx_tau_t"><span class="n"><span class="pre">acb_theta_ctx_tau_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx_tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all_a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all_b</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_sum_jet" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>th</em> to the vector of derivatives of theta functions up to total order
<em>ord</em>, at each of the <em>nb</em> pairs <span class="math notranslate nohighlight">\((z,\tau)\)</span> specified by the contexts,
using summation. Precisely which characteristics <span class="math notranslate nohighlight">\((a,b)\)</span> we consider is
controlled by the parameters <em>all_a</em> and <em>all_b</em> as in
<a class="reference internal" href="#c.acb_theta_sum" title="acb_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a>.</p>
</dd></dl>

</section>
<section id="agm-steps">
<h2>AGM steps<a class="headerlink" href="#agm-steps" title="Link to this heading">¶</a></h2>
<p>The quasi-linear algorithm to evaluate theta functions uses the following
<em>duplication formula</em>: for all <span class="math notranslate nohighlight">\(z,z'\in \mathbb{C}^g\)</span> and <span class="math notranslate nohighlight">\(\tau\in
\mathcal{H}_g\)</span>,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,0}(z,\tau) \theta_{a,0}(z',\tau) = \sum_{a'\in(\mathbb{Z}/2\mathbb{Z})^g}
\theta_{a',0}(z+z',2\tau) \theta_{a+a',0}(z-z',2\tau).\]</div>
</div></blockquote>
<p>Applying the duplication formula amounts to taking a step in a (generalized)
AGM sequence. Note that the formula still holds if we replace <span class="math notranslate nohighlight">\(\theta_{a,0}\)</span> by
the normalized version <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,0}\)</span>.</p>
<p>This section gathers methods to apply duplication formulas efficiently while
minimizing precision losses. In the case <span class="math notranslate nohighlight">\(z = z'\)</span>, the duplication formula is
typically followed by an extraction of square roots using low-precision
approximations to make the correct choice.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_agm_sqrt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_agm_sqrt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">roots</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_agm_sqrt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets each of the <em>nb</em> entries of <em>res</em> to a square root of the
corresponding entry of <span class="math notranslate nohighlight">\(a\)</span>. The choice of sign is determined by <em>roots</em>:
each entry of <em>res</em> will overlap the corresponding entry of <em>roots</em> but not
its opposite. When this is not possible, we set the corresponding entry of
<em>res</em> to the <a class="reference internal" href="acb.html#c.acb_union" title="acb_union"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_union()</span></code></a> of both square roots (when both overlap
<em>roots</em>) or an indeterminate value (when none overlap <em>roots</em>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_agm_mul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_agm_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">a1</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">a2</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_agm_mul" title="Link to this definition">¶</a><br /></dt>
<dd><p>For each <span class="math notranslate nohighlight">\(0\leq k &lt; 2^g\)</span>, sets the <span class="math notranslate nohighlight">\(k\)</span>-th entry of <em>res</em> to</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\sum_{b\in \{0,1\}^g} a_{1,b}\, a_{2, b + k}\]</div>
</div></blockquote>
<p>where addition is meant in <span class="math notranslate nohighlight">\((\mathbb{Z}/2\mathbb{Z}^g)\)</span> (a bitwise xor). If
<em>all</em> is nonzero, then we additionally compute, for each <span class="math notranslate nohighlight">\(1\leq a \leq
2^g-1\)</span>, the vector of length <span class="math notranslate nohighlight">\(2^g\)</span> whose <span class="math notranslate nohighlight">\(k\)</span>-th entry contains</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\sum_{b\in \{0,1\}^g} (-1)^{a^T b} a_{1,b} a_{2, b+k},\]</div>
</div></blockquote>
<p>so <em>res</em> has total length <span class="math notranslate nohighlight">\(2^{2g}\)</span> in that case.</p>
<p>Following <a class="reference internal" href="references.html#lt2016" id="id8"><span>[LT2016]</span></a>, we apply the Hadamard matrix twice with
multiplications in-between. This causes precision losses when the absolute
values of the entries in <em>a1</em> and/or <em>a2</em> are of different orders of
magnitude. This function is faster when <em>a1</em> and <em>a2</em> are equal as
pointers, as we can use squarings instead of multiplications.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_agm_mul_tight">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_agm_mul_tight</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">a0</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="arb.html#c.arb_srcptr" title="arb_srcptr"><span class="n"><span class="pre">arb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">d0</span></span>, <a class="reference internal" href="arb.html#c.arb_srcptr" title="arb_srcptr"><span class="n"><span class="pre">arb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_agm_mul_tight" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <em>d0</em> and <em>d</em> are obtained as the result of
<a class="reference internal" href="#c.acb_theta_eld_distances" title="acb_theta_eld_distances"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a> on pairs <span class="math notranslate nohighlight">\((0,\tau)\)</span> and <span class="math notranslate nohighlight">\((z,\tau)\)</span>
respectively, performs the same computation as <a class="reference internal" href="#c.acb_theta_agm_mul" title="acb_theta_agm_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_agm_mul()</span></code></a> on
the vectors <em>a0</em> and <em>a</em> (and the parameter <em>all</em>) with a different
management of error bounds. The resulting error bounds on <em>res</em> is tighter
when the absolute value of <span class="math notranslate nohighlight">\(a_k\)</span> is roughly <span class="math notranslate nohighlight">\(e^{-d_k}\)</span> for each <span class="math notranslate nohighlight">\(0\leq k &lt;
2^g\)</span>, and similarly for <em>a0</em> and <em>d0</em>, for instance when applying the
duplication formula on normalized theta values.</p>
<p>We first compute <span class="math notranslate nohighlight">\(m, \varepsilon\)</span> such that the following holds: for each
<span class="math notranslate nohighlight">\(0\leq k &lt; \mathit{nb}\)</span>, if <span class="math notranslate nohighlight">\(d_k\)</span> (resp. <span class="math notranslate nohighlight">\(a_k\)</span>) denotes the <span class="math notranslate nohighlight">\(k\)</span>-th entry of
<em>d</em> (resp. <em>a</em>), then the absolute value of <span class="math notranslate nohighlight">\(a_k\)</span> is at most <span class="math notranslate nohighlight">\(m \cdot
e^{-d_k}\)</span> and the radius of the complex ball <span class="math notranslate nohighlight">\(a_k\)</span> is at most
<span class="math notranslate nohighlight">\(\mathit{eps}\cdot e^{-d_k}\)</span>. We proceed similarly on <em>a0</em> and <em>d0</em> to
obtain <span class="math notranslate nohighlight">\(m_0, \varepsilon_0\)</span>. Then we call <a class="reference internal" href="#c.acb_theta_agm_mul" title="acb_theta_agm_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_agm_mul()</span></code></a> on the
midpoints of <em>a0</em> and <em>a</em> at a higher working precision, and finally add
<span class="math notranslate nohighlight">\(2^g e^{-d_k} (m_0 \varepsilon + m \varepsilon_0 +
\varepsilon\varepsilon_0)\)</span> to the error bound on the <span class="math notranslate nohighlight">\(k\)</span>-th entry of
<em>res</em>. This is valid because of the parallelogram identity: keeping
notation from <a class="reference internal" href="#c.acb_theta_eld_distances" title="acb_theta_eld_distances"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a>, for each <span class="math notranslate nohighlight">\(b\in \{0,1\}^g\)</span>,
we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathrm{Dist}_\tau(-Y^{-1}y, \mathbb{Z}^g + \tfrac b2)^2
+ \mathrm{Dist}_\tau(-Y^{-1} y, \mathbb{Z}^g + \tfrac{b + k}{2})^2
\leq \mathrm{Dist}_\tau(-Y^{-1}y, \mathbb{Z}^g + \tfrac{k}{2})^2.\]</div>
</div></blockquote>
</dd></dl>

</section>
<section id="quasilinear-algorithms-on-reduced-input">
<h2>Quasilinear algorithms on reduced input<a class="headerlink" href="#quasilinear-algorithms-on-reduced-input" title="Link to this heading">¶</a></h2>
<p>The general duplication formula specializes to the three following equalities:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\theta_{a,0}(z,\tau)^2 &amp;= \sum_{a'\in (\mathbb{Z}/2\mathbb{Z})^g}
\theta_{a',0}(2z,2\tau) \theta_{a+a',0}(0,2\tau),\\
\theta_{a,0}(0,\tau)\theta_{a,0}(z,\tau) &amp;= \sum_{a'\in(\mathbb{Z}/2\mathbb{Z})^g}
\theta_{a',0}(z,2\tau) \theta_{a+a',0}(z,2\tau), \\
\theta_{a,0}(0,\tau)^2 &amp;= \sum_{a'\in (\mathbb{Z}/2\mathbb{Z})^g}
\theta_{a',0}(0,2\tau) \theta_{a+a',0}(0,2\tau).
\end{aligned}\end{split}\]</div>
</div></blockquote>
<p>Suppose that we wish to compute <span class="math notranslate nohighlight">\(\theta_{a,0}(0,\tau)\)</span> for all <span class="math notranslate nohighlight">\(a\in \{0,1\}^g\)</span>
and a reduced matrix <span class="math notranslate nohighlight">\(\tau\in \mathcal{H}_g\)</span>. Applying the last of the above
duplication formulas <span class="math notranslate nohighlight">\(n\)</span> times, we reduce to evaluating
<span class="math notranslate nohighlight">\(\theta_{a,0}(0,2^n\tau)\)</span>. We expect that the absolute value of this complex
number is roughly <span class="math notranslate nohighlight">\(\exp(-d^2)\)</span> for <span class="math notranslate nohighlight">\(d = 2^n\mathrm{Dist}_\tau(0, \mathbb{Z}^g +
\tfrac a2)\)</span>, where <span class="math notranslate nohighlight">\(\mathrm{Dist}_\tau\)</span> denotes the distance in <span class="math notranslate nohighlight">\(\mathbb{R}^g\)</span>
attached to the quadratic form <span class="math notranslate nohighlight">\(\pi Y\)</span>. Provided that <span class="math notranslate nohighlight">\(2^n\)</span> is roughly <em>prec</em>,
we have to sum only <span class="math notranslate nohighlight">\(O_g(1)\)</span> terms in the summation algorithm to evaluate
<span class="math notranslate nohighlight">\(\theta_{a,0}(0,2^n\tau)\)</span> at “shifted absolute precision” <em>prec</em>, i.e. absolute
precision <em>prec</em> <span class="math notranslate nohighlight">\(+\ d^2/\log(2)\)</span>.</p>
<p>In order to recover <span class="math notranslate nohighlight">\(\theta_{a,0}(0,\tau)\)</span>, we then perform <span class="math notranslate nohighlight">\(n\)</span> AGM
steps. <em>Assuming</em> that each <span class="math notranslate nohighlight">\(|\theta_{a,0}(0, 2^k\tau)|\)</span> is indeed of the
expected order of magnitude, we can ensure that the precision loss is <span class="math notranslate nohighlight">\(O_g(1)\)</span>
bits at each step in terms of shifted absolute precision, and we can make the
correct choices of square roots at each step by computing low-precision
approximations with the summation algorithm. However, depending on the choice
of <span class="math notranslate nohighlight">\(\tau\)</span>, this assumption may not always hold.</p>
<p>We make the following adjustments to make the algorithm work for all <span class="math notranslate nohighlight">\(\tau\)</span>,
for theta values at <span class="math notranslate nohighlight">\(z\neq 0\)</span>, and for all characteristics:</p>
<ul>
<li><p>If we discover that some value <span class="math notranslate nohighlight">\(\theta_{a,0}(0,2^k\tau)\)</span> is too small, we
introduce an auxiliary real vector <span class="math notranslate nohighlight">\(t\)</span>. At each step, starting from
<span class="math notranslate nohighlight">\(\theta_{a,0}(0,2^{k+1}\tau)\)</span>, <span class="math notranslate nohighlight">\(\theta_{a,0}(2^{k+1}t, 2^{k+1}\tau)\)</span> and
<span class="math notranslate nohighlight">\(\theta_{a,0}(2^{k+2}t, 2^{k+1}\tau)\)</span>, we compute <span class="math notranslate nohighlight">\(\theta_{a,0}(2^{k}t,
2^k\tau)\)</span> and <span class="math notranslate nohighlight">\(\theta_{a,0}(2^{k+1}t, 2^k\tau)\)</span> using square roots (first
formula above), then <span class="math notranslate nohighlight">\(\theta_{a,0}(0, 2^k\tau)\)</span> using divisions (second
formula). For a huge majority of such <span class="math notranslate nohighlight">\(t\)</span>, none of the values
<span class="math notranslate nohighlight">\(\theta_{a,0}(2^kt, 2^k\tau)\)</span> and <span class="math notranslate nohighlight">\(\theta_{a,0}(2^{k+1}t, 2^k\tau)\)</span> are
too small. In practice, we choose <span class="math notranslate nohighlight">\(t\)</span> at random and obtain a probabilistic
algorithm with a negligible failure probability.</p></li>
<li><p>When computing <span class="math notranslate nohighlight">\(\theta_{a,0}(z,\tau)\)</span> for a nonzero <span class="math notranslate nohighlight">\(z\)</span>, we compute
<span class="math notranslate nohighlight">\(\theta_{a,0}(0, 2^k\tau)\)</span> and <span class="math notranslate nohighlight">\(\theta_{a,0}(2^k z,
2^k\tau)\)</span> using the first and third formulas at each step.</p></li>
<li><p>These two techniques can be combined by evaluating theta values at the six
vectors <span class="math notranslate nohighlight">\(2^k v\)</span> for <span class="math notranslate nohighlight">\(v = 0, t, 2t, z, z + t, z + 2t\)</span>. Note that we only have
to compute <span class="math notranslate nohighlight">\(\theta_{a,0}(2^kz, 2^k\tau)\)</span> at the last step <span class="math notranslate nohighlight">\(k=0\)</span>.</p></li>
<li><p>To simplify the precision management, we use <a class="reference internal" href="#c.acb_theta_agm_mul_tight" title="acb_theta_agm_mul_tight"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_agm_mul_tight()</span></code></a>
and work with normalized theta values throughout, which also satisfy the
duplication formulas.</p></li>
<li><p>If the eigenvalues of <span class="math notranslate nohighlight">\(Y\)</span> have different orders of magnitude, then as we
consider <span class="math notranslate nohighlight">\(\tau\)</span>, <span class="math notranslate nohighlight">\(2\tau\)</span>, <span class="math notranslate nohighlight">\(4\tau\)</span>, etc., the ellipsoids we would consider in
the summation algorithm become very thin in one direction while still being
thick in other directions. In such a case, we can rewrite theta values as a
sum of <span class="math notranslate nohighlight">\(O(1)\)</span> theta values in lower dimensions. This increases the efficiency
of the algorithm while ensuring that the absolute precisions we consider are
always of the order of <em>prec</em>.</p></li>
<li><p>Finally, we note that the duplication formulas also have analogues for all
theta values, not just <span class="math notranslate nohighlight">\(\theta_{a,0}\)</span>: for instance, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(0,\tau)^2 = \sum_{a'\in (\mathbb{Z}/2\mathbb{Z})^g} (-1)^{a'^T b}
\theta_{a',0}(0,2\tau)\theta_{a+a',0}(0,2\tau).\]</div>
</div></blockquote>
<p>We use those generalized formulas for the very last duplication step when
needed.</p>
</li>
</ul>
<p>We always assume in this section that the inputs <span class="math notranslate nohighlight">\((z,\tau)\)</span> have been
reduced.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_nb_steps">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_nb_steps</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pattern</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cst</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_nb_steps" title="Link to this definition">¶</a><br /></dt>
<dd><p>Determines how many duplication steps we should perform to evaluate theta
functions at <span class="math notranslate nohighlight">\(\tau\)</span> at precision <em>prec</em>, and at which steps we should fall
back to lower dimensions, if any. The flag <em>cst</em> should be set to nonzero
iff theta functions at <span class="math notranslate nohighlight">\(z\neq 0\)</span> are to be computed.</p>
<p>The output is stored in <em>pattern</em>, a vector of length <span class="math notranslate nohighlight">\(g\)</span>. Roughly
speaking, the <span class="math notranslate nohighlight">\(j\)</span>-th entry of <em>pattern</em> is a nonnegative integer <span class="math notranslate nohighlight">\(m\)</span> such
that <span class="math notranslate nohighlight">\(2^m \gamma_j^2\)</span> is of the order of <em>prec</em>, where <span class="math notranslate nohighlight">\(\gamma_j\)</span> denotes
the <span class="math notranslate nohighlight">\(j\)</span>-th diagonal coefficient of the Cholesky matrix for <span class="math notranslate nohighlight">\(\pi Y\)</span>. In other
words, the ellipsoid we need to consider in the summation algorithm at
<span class="math notranslate nohighlight">\(2^m\tau\)</span> has width <span class="math notranslate nohighlight">\(O(1)\)</span> in the direction of the <span class="math notranslate nohighlight">\(j\)</span>-th canonical basis
vector in <span class="math notranslate nohighlight">\(\mathbb{R}^g\)</span>. Because <span class="math notranslate nohighlight">\(\tau\)</span> is assumed to be reduced, we
expect <em>pattern</em> to be a roughly decreasing vector.</p>
<p>If some entries of the Cholesky matrix are interminate or too extreme for a
reasonable <span class="math notranslate nohighlight">\(m\)</span> to be computed, then the output is 0, and otherwise 1.</p>
<p>Modifying this function is the main way to tune the behavior of the
quasi-linear algorithms to evaluate theta functions.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_lower_dim">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_lower_dim</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">new_zs</span></span>, <a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cofactors</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">nb</span></span>, <a class="reference internal" href="arf.html#c.arf_t" title="arf_t"><span class="n"><span class="pre">arf_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">err</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fullprec</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="arb.html#c.arb_srcptr" title="arb_srcptr"><span class="n"><span class="pre">arb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">distances</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_lower_dim" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements the dimension-lowering strategy for evaluating theta functions. The input is as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\((z,\tau)\)</span> should be an exact element of <span class="math notranslate nohighlight">\(\mathbb{C}^g\times
\mathcal{H}_g\)</span> (ideally reduced).</p></li>
<li><p><em>distances</em> should be the output of <a class="reference internal" href="#c.acb_theta_eld_distances" title="acb_theta_eld_distances"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a> on
this pair.</p></li>
<li><p><em>s</em> should be an integer between <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(g-1\)</span>; we will reduce the
evaluation of theta functions from dimension <span class="math notranslate nohighlight">\(g\)</span> to dimension <span class="math notranslate nohighlight">\(s\)</span>.</p></li>
<li><p><em>a</em> should be an integer between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{g-s}-1\)</span> included; we only
decompose <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a',0}(z,\tau)\)</span> when the last <span class="math notranslate nohighlight">\(g - s\)</span> bits
of <span class="math notranslate nohighlight">\(a'\)</span> correspond to those of <em>a</em>.</p></li>
</ul>
<p>We then proceed as follows:</p>
<ul>
<li><p><em>fullprec</em> is set to the binary precision at which those theta values
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a',0}(z,\tau)\)</span> should be computed. We take
distances into account, so <em>fullprec</em> is <em>prec</em> plus additional guard
bits derived from the maximum of the entries in <em>distances</em> corresponding
to the possible characteristics <em>a’</em>.</p></li>
<li><p><em>R2</em> and <em>err</em> are set as in <a class="reference internal" href="#c.acb_theta_sum_radius" title="acb_theta_sum_radius"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_radius()</span></code></a> for this choice
of <em>fullprec</em>. (<em>R2</em> is not part of the output.) Thus,
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a',0}(z,\tau)\)</span> can be obtained by summing over an
ellipsoid of squared radius <em>R2</em> and adding an error <em>err</em> coming from
the tail. We do <em>not</em> compute that possibly huge ellipsoid.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(n\in \mathbb{Z}^g + \tfrac{a'}{2}\)</span> be a point in that
ellipsoid. Write <span class="math notranslate nohighlight">\(a' = (a_0,a)\)</span> and <span class="math notranslate nohighlight">\(n = (n_0,n_1)\)</span> where <span class="math notranslate nohighlight">\(n_0\in
\mathbb{Z}^s + \tfrac{a_0}{2}\)</span> and <span class="math notranslate nohighlight">\(n_1\in \mathbb{Z}^{g - s} +
\tfrac{a}{2}\)</span>. By the Pythagorean theorem, the possible values for <span class="math notranslate nohighlight">\(n_1\)</span>
all lie in an ellipsoid of radius <em>R2</em> in dimension <span class="math notranslate nohighlight">\(g-s\)</span>, whose Cholesky
matrix is the lower-right part of a Cholesky matrix for <span class="math notranslate nohighlight">\(\pi Y\)</span>. This new
ellipsoid is meant to contain very few points. We list all possible
values for <span class="math notranslate nohighlight">\(n_1 - \tfrac{a}{2}\)</span> (which lies in <span class="math notranslate nohighlight">\(\mathbb{Z}^g\)</span>) in <em>pts</em>,
and set <em>nb</em> to the number of those points. Note that <em>pts</em> will have to
be freed by the user afterwards.</p></li>
<li><p>For each <span class="math notranslate nohighlight">\(n_1 - \tfrac{a}{2}\)</span> listed in <em>pts</em>, then the sum of the
corresponding terms in the theta series is</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[e^{\pi i \bigl(n_1^T \tau_1 n_1 + 2 n_1^T z_1 + \pi y_0^T Y_0 y_0 - \pi y^T Y y \bigr)}
\widetilde{\theta}_{a_0,0}(z_0 + x n_1, \tau_0).\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(\tau = \Bigl(\begin{smallmatrix} \tau_0 &amp; x\\x^T &amp;
\tau_1\end{smallmatrix}\Bigr)\)</span> and <span class="math notranslate nohighlight">\(z = (z_0,z_1)\)</span>. Thus, we allocate
<em>new_zs</em> to contain <em>nb</em> vectors of length <span class="math notranslate nohighlight">\(g\)</span> and set the corresponding
entry to <span class="math notranslate nohighlight">\(z_0 + x n_1\)</span> (which is still exact). We also allocate
<em>cofactors</em> to be a vector of length <em>nb</em> and set its corresponding entry
to the above exponential factor. Both <em>new_zs</em> and <em>cofactors</em> will have
to be freed by the user.</p>
</li>
</ul>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_recombine">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_recombine</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th0</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">cofactors</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pts</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="arf.html#c.arf_t" title="arf_t"><span class="n"><span class="pre">arf_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">err</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">fullprec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_recombine" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the converse to <a class="reference internal" href="#c.acb_theta_ql_lower_dim" title="acb_theta_ql_lower_dim"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a>, namely recovers
normalized theta values <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a',0}(z,\tau)\)</span> from the output
of <a class="reference internal" href="#c.acb_theta_ql_lower_dim" title="acb_theta_ql_lower_dim"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a> and theta values in dimension <span class="math notranslate nohighlight">\(s\)</span>. The
input is as follows:</p>
<ul class="simple">
<li><p><em>cofactors</em>, <em>pts</em>, <em>nb</em>, <em>err</em>, <em>fullprec</em>, <em>s</em>, <em>a</em>, <em>g</em>, <em>prec</em> should
be as output by <a class="reference internal" href="#c.acb_theta_ql_lower_dim" title="acb_theta_ql_lower_dim"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a>.</p></li>
<li><p>If <em>all</em> is true (nonzero), then <em>th0</em> should be a concatenation of <em>nb</em>
vectors of length <span class="math notranslate nohighlight">\(2^{2s}\)</span> containing
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a_0,b_0}(z_0,\tau_0)\)</span> for all characteristics
<span class="math notranslate nohighlight">\((a_0,b_0)\)</span> in dimension <span class="math notranslate nohighlight">\(s\)</span>, where <span class="math notranslate nohighlight">\(z_0\)</span> runs through <em>new_zs</em> as output
by <a class="reference internal" href="#c.acb_theta_ql_lower_dim" title="acb_theta_ql_lower_dim"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a>, and <span class="math notranslate nohighlight">\(\tau_0\)</span> is defined as above. If
<em>all</em> is false (zero), then <em>th0</em> should be a concatenation of <em>nb</em>
vectors of length <span class="math notranslate nohighlight">\(2^{s}\)</span> containing
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a_0,0}(z_0,\tau_0)\)</span> only.</p></li>
</ul>
<p>The output, stored in <em>th</em>, is either the vector containing
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,b}(z,\tau)\)</span> for all <span class="math notranslate nohighlight">\(g\)</span>-dimensional characteristics
<span class="math notranslate nohighlight">\((a,b)\)</span> (if <em>all</em> is true) or only <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,0}(z,\tau)\)</span> for
all <span class="math notranslate nohighlight">\(a\)</span> (if <em>all</em> is false), where <span class="math notranslate nohighlight">\((z,\tau)\)</span> was the initial input to
<a class="reference internal" href="#c.acb_theta_ql_lower_dim" title="acb_theta_ql_lower_dim"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_setup">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_setup</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">rts</span></span>, <a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">rts_all</span></span>, <a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">t</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">guard</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">easy_steps</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="arb.html#c.arb_srcptr" title="arb_srcptr"><span class="n"><span class="pre">arb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">distances</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb_steps</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_setup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets up the structure of AGM steps to evaluate theta functions at the given
<em>nb</em> pairs <span class="math notranslate nohighlight">\((z,\tau)\)</span> where <span class="math notranslate nohighlight">\(z\)</span> runs through <em>zs</em>, which are assumed to be
exact and reduced, using <em>nb_steps</em> duplication steps. The parameters <em>nb</em>
and <em>nb_steps</em> must be at least one, and <em>zs</em> must begin with the zero
vector in <span class="math notranslate nohighlight">\(\mathbb{C}^g\)</span>. If <span class="math notranslate nohighlight">\((z,\tau)\)</span> are not exact, then the output is
still mathematically correct, but NaN values or undesired precision losses
might occur.</p>
<p>The rest of the input is as follows:</p>
<ul class="simple">
<li><p><em>distances</em> should be the concatenation of <em>nb</em> vectors of length <span class="math notranslate nohighlight">\(2^g\)</span>
computed by <a class="reference internal" href="#c.acb_theta_eld_distances" title="acb_theta_eld_distances"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a> for each pair <span class="math notranslate nohighlight">\((z,\tau)\)</span>.</p></li>
<li><p><em>nb_steps</em> should be the number of times we wish to apply the duplication
formulas before falling back to either the summation algorithms or the
dimension-lowering strategy.</p></li>
<li><p>if <em>all</em> is nonzero, then we compute <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,b}(z,\tau)\)</span>
for all characteristics <span class="math notranslate nohighlight">\((a,b)\)</span>, and otherwise only
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,0}(z,\tau)\)</span>.</p></li>
</ul>
<p>The vectors <em>rts</em>, <em>rts_all</em>, <em>t</em>, and <em>easy_steps</em> should be
preinitialized with lengths <span class="math notranslate nohighlight">\(2^g \times 3\times
\mathit{nb}\times\mathit{nb\_steps}\)</span>, <span class="math notranslate nohighlight">\(2^{2g}\times\mathit{nb}\)</span> (only used
if <em>all</em> is true), <span class="math notranslate nohighlight">\(g\)</span> and <em>nb</em> respectively, while <em>guard</em> is a pointer to
one <a class="reference internal" href="flint.html#c.slong" title="slong"><code class="xref c c-type docutils literal notranslate"><span class="pre">slong</span></code></a>.</p>
<p>We proceed as follows. Initially, we work at a very low precision such as 8.</p>
<ol class="arabic simple">
<li><p>For each <span class="math notranslate nohighlight">\(z\)</span>, we use the summation algorithms to obtain approximations
of <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,b}(z,\tau)\)</span> (if <em>all</em> is true) or
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,0}(z,\tau)\)</span> (if <em>all</em> is false), and store them
in <em>rts_all</em> or <em>rts</em> respectively. We adjust the error bounds in terms
of <em>distances</em>, so that the computed approximations do not contain zero
with a good probability. If none of the computed approximations contains
zero, it means that we can successfully apply the last (and simplest)
duplication formula for the last step of the quasi-linear algorithm. In
that case, we go on and compute approximations of
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,0}(2^k z,2^k\tau)\)</span>, for <span class="math notranslate nohighlight">\(k = 1,2,\)</span> etc., up to
<em>nb_steps</em>-1 or until one of the approximations we compute contains
zero, taking distances into account at each step. We store the computed
values in <em>rts</em>, and set the corresponding entry of <em>easy_steps</em> to be
the number of steps for which the simplest duplication formula can be
applied.</p></li>
<li><p>At that point, if the entries of <em>easy_steps</em> are all equal to <em>nb_steps</em>,
we are done. Otherwise, we pick an auxiliary vector <span class="math notranslate nohighlight">\(t\)</span> at
random. The 1st entry of <em>easy_steps</em>, corresponding to <span class="math notranslate nohighlight">\(z=0\)</span>, is set to
the minimal value in <em>easy_steps</em> (this is necessary to be able to apply
the duplication formulas.)</p></li>
<li><p>For each <span class="math notranslate nohighlight">\(z\)</span>, if <span class="math notranslate nohighlight">\(m\)</span> denotes the corresponding entry of <em>easy_steps</em>, we
use the summation algorithms to compute approximations of
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,0}(2^k (z + t), 2^k\tau)\)</span> and
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,0}(2^k(z + 2t), 2^k\tau)\)</span> for each <span class="math notranslate nohighlight">\(k\)</span> between
<span class="math notranslate nohighlight">\(m\)</span> and <em>nb_steps</em>-1 included at low precision. (We only need the second
vector for <span class="math notranslate nohighlight">\(k=0\)</span>.) If one of these values contains zero, we restart step
3 with another <span class="math notranslate nohighlight">\(t\)</span> (we allow a small number of such retries, such as
4). We store those approximations in <em>rts</em>. If <span class="math notranslate nohighlight">\(k=0\)</span> and <em>all</em> is true,
then the values we need are <span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,b}(z+2t,\tau)\)</span> for
all <span class="math notranslate nohighlight">\((a,b)\)</span> instead; those are stored in <em>rts_all</em>.</p></li>
<li><p>If no suitable <span class="math notranslate nohighlight">\(t\)</span> was found in step 4, then we double the working
precision and go back to step 1. We allow this until the working
precision reaches <em>prec</em>. After that, if <span class="math notranslate nohighlight">\(t\)</span> still cannot be found, then
we declare failure and output 0. This should only happen with negligible
probability for well-formed input. The output value if 1 if a suitable
<span class="math notranslate nohighlight">\(t\)</span> was found.</p></li>
</ol>
<p>Finally, we set <em>guard</em> to the total number of bits of precision we expect
to lose when actually performing the suggested duplication steps later on.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_exact">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_exact</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pattern</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">shifted_prec</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_exact" title="Link to this definition">¶</a><br /></dt>
<dd><p>Runs the full quasi-linear algorithm to evaluate theta functions at the
given <em>nb</em> pairs <span class="math notranslate nohighlight">\((z,\tau)\)</span> where <span class="math notranslate nohighlight">\(z\)</span> runs through <em>zs</em>, which are assumed
to be exact and reduced. If <span class="math notranslate nohighlight">\((z,\tau)\)</span> are not exact, then the function is
still correct, but NaN values or undesired precision losses might occur.</p>
<p>The output is either the collection of theta values
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,b}(z,\tau)\)</span> for all <span class="math notranslate nohighlight">\(a,b\)</span> or
<span class="math notranslate nohighlight">\(\widetilde{\theta}_{a,0}(z,\tau)\)</span> for all <span class="math notranslate nohighlight">\(a\)</span> (depending on whether <em>all</em>
is true or not) for each vector <span class="math notranslate nohighlight">\(z\)</span> in <em>zs</em>, and is stored in <em>th</em>. If
<em>shifted_prec</em> is nonzero, then the precision to which these values are
computed takes distances into account similarly to <a class="reference internal" href="#c.acb_theta_sum" title="acb_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a>.</p>
<p>The input <em>pattern</em> conditions how many duplication steps are performed and
when to apply the dimension-lowering strategy (if at all). If zero
duplication steps are needed, we call <a class="reference internal" href="#c.acb_theta_sum" title="acb_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a>
directly. Otherwise, we call <a class="reference internal" href="#c.acb_theta_ql_setup" title="acb_theta_ql_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_setup()</span></code></a>, which we expect to
succeed with overwhelming probability. The initial theta values required in
the duplication formulas are computed either by the summation algorithms
or, if the dimension-lowering strategy is used, by calling
<a class="reference internal" href="#c.acb_theta_ql_lower_dim" title="acb_theta_ql_lower_dim"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a>, making a recursive call to
<a class="reference internal" href="#c.acb_theta_ql_exact" title="acb_theta_ql_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_exact()</span></code></a> in a lower dimension but (possibly) a longer
list of vectors <em>zs</em>, and finally recombining the values with
<a class="reference internal" href="#c.acb_theta_ql_recombine" title="acb_theta_ql_recombine"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_recombine()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_local_bound">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_local_bound</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="arb.html#c.arb_t" title="arb_t"><span class="n"><span class="pre">arb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <a class="reference internal" href="arb.html#c.arb_t" title="arb_t"><span class="n"><span class="pre">arb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rho</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_local_bound" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>c</em> and <em>rho</em> such that on every ball centered at (a point contained
in) <em>z</em> of radius <em>rho</em>, the functions <span class="math notranslate nohighlight">\(|\theta_{a,b}(\cdot,\tau)|\)</span> for all
characteristics <span class="math notranslate nohighlight">\((a,b)\)</span> are uniformly bounded by <span class="math notranslate nohighlight">\(c\)</span>. The choice of <em>rho</em>
is tuned to get interesting upper bounds on derivatives of <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span>
up to order <em>ord</em> in the context of finite differences (see
<a class="reference internal" href="#c.acb_theta_ql_jet_fd" title="acb_theta_ql_jet_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_jet_fd()</span></code></a> below). We always ensure that <em>rho</em> is at most
1 and <em>c</em> is at least 1.</p>
<p>We proceed as follows. First, we compute <span class="math notranslate nohighlight">\(c_0\)</span>, <span class="math notranslate nohighlight">\(c_1\)</span>, <span class="math notranslate nohighlight">\(c_2\)</span> such that for
any choice of <span class="math notranslate nohighlight">\(\rho\)</span>, one can take <span class="math notranslate nohighlight">\(c = c_0\exp((c_1 + c_2\rho)^2)\)</span>
above. We can take</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[c_0 = 2^g \prod_{j=0}^{g-1} (1 + 2\gamma_j^{-1}),\]</div>
<div class="math notranslate nohighlight">
\[c_1 = \sqrt{\pi y^T Y^{-1} y},\]</div>
<div class="math notranslate nohighlight">
\[c_2 = \sup_{\lVert x \rVert_\infty\leq 1} \sqrt{\pi x^T Y^{-1} x}.\]</div>
</div></blockquote>
<p>One can easily compute an upper bound on <span class="math notranslate nohighlight">\(c_2\)</span> from the Cholesky
decomposition of <span class="math notranslate nohighlight">\(\pi Y^{-1}\)</span>. We then look for a value of <span class="math notranslate nohighlight">\(\rho\)</span> that
minimizes <span class="math notranslate nohighlight">\(\exp((c_1 + c_2\rho)^2)/\rho^{2\mathit{ord}+1}\)</span>, i.e. we set
<span class="math notranslate nohighlight">\(\rho\)</span> to minimum of 1 and the positive root of <span class="math notranslate nohighlight">\(2c_2\rho (c_1 + c_2\rho) =
2\mathit{ord}+1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_jet_error">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_jet_error</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="arb.html#c.arb_ptr" title="arb_ptr"><span class="n"><span class="pre">arb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">err</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">dth</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_jet_error" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <em>dth</em> contains (approximations of) the derivatives of a theta
function <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span> up to total order <span class="math notranslate nohighlight">\(\mathit{ord} + 2\)</span> at <span class="math notranslate nohighlight">\((z,\tau)\)</span>,
sets <em>err</em> to a vector with the following property. Let <span class="math notranslate nohighlight">\((z_0,\tau_0)\)</span> be
the midpoint of <span class="math notranslate nohighlight">\((z,\tau)\)</span>, and let <span class="math notranslate nohighlight">\((z_1,\tau_1)\)</span> be any point inside the
ball specified by the given <em>z</em> and <em>tau</em>. Then the vectors of derivatives
of <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span> at <span class="math notranslate nohighlight">\((z_0,\tau_0)\)</span> and <span class="math notranslate nohighlight">\((z_1,\tau_1)\)</span> up to total order
<em>ord</em> differ by at most <em>err</em> elementwise. This uses the heat equation and
a Lipschitz-type inequality.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_jet_fd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_jet_fd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_jet_fd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates partial derivatives of theta functions <span class="math notranslate nohighlight">\(\theta_{a,b}\)</span> with
respect to <span class="math notranslate nohighlight">\(z\)</span> at the given <em>nb</em> points <span class="math notranslate nohighlight">\((z,\tau)\)</span>. The characteristic <span class="math notranslate nohighlight">\(a\)</span>
varies from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(2^g-1\)</span>, and so does <em>b</em> if <em>all</em> is true (nonzero). If
<em>all</em> is false, then we only consider <span class="math notranslate nohighlight">\(b=0\)</span>. The result is a concatenation
of <em>nb</em> times <span class="math notranslate nohighlight">\(2^{2g}\)</span> (or <span class="math notranslate nohighlight">\(2^g\)</span>) vectors of derivatives.</p>
<p>We rely on finite differences on the output of <a class="reference internal" href="#c.acb_theta_ql_exact" title="acb_theta_ql_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_exact()</span></code></a>,
as follows. Consider the Taylor expansion:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(z + h, \tau)
= \sum_{k\in \mathbb{Z}^g,\ k\geq 0} a_k\, h_0^{k_0}\cdots h_{g-1}^{k_{g-1}}.\]</div>
</div></blockquote>
<p>If one chooses <span class="math notranslate nohighlight">\(h = h_n = (\varepsilon \zeta^{n_0},\ldots, \varepsilon
\zeta^{n_{g-1}})\)</span> where <span class="math notranslate nohighlight">\(\varepsilon &gt; 0\)</span> and <span class="math notranslate nohighlight">\(\zeta\)</span> is a primitive <span class="math notranslate nohighlight">\(m\)</span>-th
root of unity and lets <span class="math notranslate nohighlight">\(n\)</span> run through all vectors in <span class="math notranslate nohighlight">\(\{0,\ldots, m -
1\}^g\)</span>, then taking a discrete Fourier transform of the resulting values
yields the individual Taylor coefficient for each derivation tuple that is
bounded by <span class="math notranslate nohighlight">\(m-1\)</span> elementwise. (A constant proportion, for fixed <span class="math notranslate nohighlight">\(g\)</span>, of
this set consists of all tuples of total order at most <span class="math notranslate nohighlight">\(m-1\)</span>.) More
precisely, fix <span class="math notranslate nohighlight">\(p\in \mathbb{Z}^g\)</span>. Then</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\sum_{n\in \{0,\ldots,m-1\}^g} \zeta^{-p^T n} \theta_{a,b}(z + h_n, \tau)
= m^g \sum_{\substack{k\in \mathbb{Z}^g,\ k\geq 0,\\ k = p\ (\text{mod } m)}}
a_k\,\varepsilon^{|k|}.\end{split}\]</div>
</div></blockquote>
<p>We obtain an upper bound on the tail of this series from the Cauchy
integration formula: if <span class="math notranslate nohighlight">\(|\theta_{a,b}(z,\tau)|\leq c\)</span> uniformly on a ball
of radius <span class="math notranslate nohighlight">\(\rho\)</span> centered in <span class="math notranslate nohighlight">\(z\)</span> for <span class="math notranslate nohighlight">\(\lVert\cdot\rVert_\infty\)</span>, then the
sum is <span class="math notranslate nohighlight">\(m^g (a_p\,\varepsilon^{|p|} + T)\)</span> with</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[|T|\leq 2c g\,\frac{\varepsilon^{|p|+m}}{\rho^m}.\]</div>
</div></blockquote>
<p>Since we divide by <span class="math notranslate nohighlight">\(\varepsilon^{|p|}\)</span> to get <span class="math notranslate nohighlight">\(a_p\)</span>, we add an error of <span class="math notranslate nohighlight">\(2c
g \varepsilon^m/\rho^{m+|p|}\)</span> to the result of the discrete Fourier
transform.</p>
<p>The algorithm based on finite differences computes <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(\rho\)</span> using
<a class="reference internal" href="#c.acb_theta_ql_local_bound" title="acb_theta_ql_local_bound"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_local_bound()</span></code></a>, chooses a suitable <span class="math notranslate nohighlight">\(\varepsilon\)</span>, strips
<span class="math notranslate nohighlight">\((z,\tau)\)</span> of their error bounds, increases the working precision to
account for division by <span class="math notranslate nohighlight">\(\varepsilon^{\mathit{ord}}\cdot
(\mathit{ord}+1)^g\)</span>, calls <a class="reference internal" href="#c.acb_theta_ql_exact" title="acb_theta_ql_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_exact()</span></code></a> on all the auxiliary
points for <span class="math notranslate nohighlight">\(m = \mathit{ord} + 1\)</span> at a higher working precision, performs
the relevant discrete Fourier transforms, and finally restores provably
correct error bounds on the results using <a class="reference internal" href="#c.acb_theta_ql_jet_error" title="acb_theta_ql_jet_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_jet_error()</span></code></a>
and derivatives to order <em>ord</em> + 2 computed at low precision. This
algorithm runs in quasi-linear time in <span class="math notranslate nohighlight">\(\mathit{prec}\cdot
\mathit{ord}^{\,g}\)</span> for any fixed <span class="math notranslate nohighlight">\(g\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_ql_jet">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_ql_jet</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_ql_jet" title="Link to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#c.acb_theta_ql_jet_fd" title="acb_theta_ql_jet_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_jet_fd()</span></code></a>, but makes an automatic choice of
algorithm between finite differences and direct summation depending on the
working precision.</p>
</dd></dl>

</section>
<section id="reduction-and-main-functions">
<h2>Reduction and main functions<a class="headerlink" href="#reduction-and-main-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_jet_notransform">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_jet_notransform</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ab</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">all</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sqr</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_jet_notransform" title="Link to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#c.acb_theta_jet" title="acb_theta_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet()</span></code></a>, but does not attempt to reduce the input
pairs <span class="math notranslate nohighlight">\((z,\tau)\)</span>. This function should only be used when the input is
already known to be reduced.</p>
<p>Depending on the cases, we use the following formulas before calling
<a class="reference internal" href="#c.acb_theta_ql_jet" title="acb_theta_ql_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_jet()</span></code></a>:</p>
<ul>
<li><p>if <em>ord</em> is zero and <em>all</em> and <em>sqr</em> are both true, we use the
duplication formula</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(z,\tau)^2 = \sum_{a'\in (\mathbb{Z}/2\mathbb{Z})^g}
\theta_{a',0}(0,2\tau) \theta_{a+a',0}(2z,2\tau).\]</div>
</div></blockquote>
</li>
<li><p>if <em>all</em> is false and <em>ab</em> is zero, we use the formula</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{0,0}(z,\tau) = \sum_{a \in (\mathbb{Z}/2\mathbb{Z})^g}
\theta_{a,0}(2z, 4\tau).\]</div>
</div></blockquote>
</li>
<li><p>if <em>all</em> is false and <em>ab</em> is not zero, we use the formula</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(z,\tau) = e^{\pi i (a^T \tau a/4 + a^T b + 2 a^T z)}
\theta_{0,0}(z + \tau\tfrac{a}{2} + \tfrac{b}{2}, \tau).\]</div>
</div></blockquote>
<p>to fall back to the case where <em>ab</em> is zero.</p>
</li>
</ul>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_reduce_tau">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_reduce_tau</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">new_zs</span></span>, <a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">new_tau</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ct</span></span>, <a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">exps</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_reduce_tau" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reduces the input matrix <span class="math notranslate nohighlight">\(\tau\)</span> under the action of the modular group
<span class="math notranslate nohighlight">\(\mathrm{Sp}_{2g}(\mathbb{Z})\)</span> and modifies the <em>nb</em> input vectors stored
in <em>zs</em> according to the theta transformation formula.</p>
<p>The output is as follows:</p>
<ul class="simple">
<li><p><em>new_tau</em> is the reduced matrix,</p></li>
<li><p><em>mat</em> is the symplectic matrix such that <em>new_tau</em> is the result of <em>mat</em>
acting on <em>tau</em>,</p></li>
<li><p><em>ct</em> is the transpose of <span class="math notranslate nohighlight">\((\gamma \tau + \delta)^{-1}\)</span> where
<span class="math notranslate nohighlight">\(\gamma,\delta\)</span> are the lower <span class="math notranslate nohighlight">\(g\times g\)</span> blocks of <em>mat</em>,</p></li>
<li><p><em>N</em> is the matrix <span class="math notranslate nohighlight">\(i \pi \gamma \cdot \mathit{ct}\)</span> that appears in the
transformation formula,</p></li>
<li><p>and finally <em>new_zs</em> is the list of <em>nb</em> vectors in <span class="math notranslate nohighlight">\(\mathbb{C}^g\)</span>
corresponding to the elements in <em>zs</em> multiplied by <em>ct</em> on the left.</p></li>
</ul>
<p>If reduction was unsuccessful (usually indicating that the input is
malformed or that the working precision is insufficient to detect that <span class="math notranslate nohighlight">\(Y\)</span>
is positive definite), the return value is 0 and the above output is left
undefined. Otherwise, the return value is 1.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_reduce_z">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_reduce_z</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">new_zs</span></span>, <a class="reference internal" href="arb.html#c.arb_ptr" title="arb_ptr"><span class="n"><span class="pre">arb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">rs</span></span>, <a class="reference internal" href="acb.html#c.acb_ptr" title="acb_ptr"><span class="n"><span class="pre">acb_ptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">cs</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">zs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_reduce_z" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reduces the <em>nb</em> vectors stored in <em>zs</em> in the context of evaluating theta
functions with <em>tau</em> as a second argument.</p>
<p>The output vectors <em>new_zs</em>, <em>rs</em> and <em>cs</em> should have lengths <em>nb</em> times
<span class="math notranslate nohighlight">\(g\)</span>, <em>nb</em> times <span class="math notranslate nohighlight">\(g\)</span>, and <em>nb</em> respectively. For a given vector <em>z</em>
appearing in <em>zs</em>, we round <span class="math notranslate nohighlight">\(Y^{-1}y\)</span> to the nearest even, integral vector
<span class="math notranslate nohighlight">\(r\)</span>, and store it in <em>rs</em>. Then, we consider the vector <span class="math notranslate nohighlight">\(z - \tau r\)</span>,
substract the nearest even integral vector from its real part, and store
the result <span class="math notranslate nohighlight">\(z'\)</span> into <em>new_zs</em>. For all characteristics <span class="math notranslate nohighlight">\(a,b\)</span>, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(z',\tau) = e^{- i \pi r^T (z + z')} \theta_{a,b}(z,\tau).\]</div>
</div></blockquote>
<p>Finally, we store this exponential factor as the corresponding entry of <em>cs</em>.</p>
<p>If rounding the imaginary part to integers does not succeed due to extreme
values, then the return value is 0 and the output vectors are left
undefined. Otherwise, the return value is 1.</p>
</dd></dl>

<p>We then assemble the main function <a class="reference internal" href="#c.acb_theta_jet" title="acb_theta_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet()</span></code></a> as follows. If
<a class="reference internal" href="#c.acb_theta_reduce_tau" title="acb_theta_reduce_tau"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_reduce_tau()</span></code></a>, then <a class="reference internal" href="#c.acb_theta_reduce_z" title="acb_theta_reduce_z"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_reduce_z()</span></code></a> succeed, we call
<a class="reference internal" href="#c.acb_theta_jet_notransform" title="acb_theta_jet_notransform"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet_notransform()</span></code></a> on the reduced pairs <span class="math notranslate nohighlight">\((z,\tau)\)</span>. We finally
apply the transformation formula with the help of <a class="reference internal" href="#c.acb_theta_char_table" title="acb_theta_char_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_char_table()</span></code></a>
and <a class="reference internal" href="#c.acb_siegel_kappa" title="acb_siegel_kappa"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_kappa()</span></code></a>. If reduction does not succeed, then the
output is set to indeterminate values.</p>
</section>
<section id="dimension-2-specifics">
<h2>Dimension 2 specifics<a class="headerlink" href="#dimension-2-specifics" title="Link to this heading">¶</a></h2>
<p>In the <span class="math notranslate nohighlight">\(g=2\)</span> case, one can use theta functions to evaluate many fundamental
Siegel modular forms. This section contains methods to do so, in analogy with
<a class="reference internal" href="acb_modular.html#c.acb_modular_delta" title="acb_modular_delta"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_modular_delta()</span></code></a> or <a class="reference internal" href="acb_modular.html#c.acb_modular_eisenstein" title="acb_modular_eisenstein"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_modular_eisenstein()</span></code></a> when <span class="math notranslate nohighlight">\(g=1\)</span>.</p>
<p>We use the following notation. Fix <span class="math notranslate nohighlight">\(k,j\geq 0\)</span>. A Siegel modular form of weight
<span class="math notranslate nohighlight">\(\det^k\otimes \mathrm{Sym}^j\)</span> is by definition an analytic function
<span class="math notranslate nohighlight">\(f: \mathcal{H}_g\to \mathbb{C}_j[X]\)</span> (the vector space of polynomials of degree
at most <span class="math notranslate nohighlight">\(j\)</span>) such that for any <span class="math notranslate nohighlight">\(\tau\in \mathcal{H}_g\)</span> and
<span class="math notranslate nohighlight">\(m\in \mathrm{Sp}_4(\mathbb{Z})\)</span>, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[f((\alpha\tau + \beta)(\gamma\tau + \delta)^{-1}) = \det(\gamma\tau +
\delta)^k\cdot \mathrm{Sym}^j(\gamma\tau + \delta)(f(\tau)).\]</div>
</div></blockquote>
<p>Here <span class="math notranslate nohighlight">\(\alpha,\beta,\gamma,\delta\)</span> are the <span class="math notranslate nohighlight">\(g\times g\)</span> blocks of <span class="math notranslate nohighlight">\(m\)</span>, and the
notation <span class="math notranslate nohighlight">\(\mathrm{Sym}^j(r)\)</span> where <span class="math notranslate nohighlight">\(r = \bigl(\begin{smallmatrix} a &amp; b\\ c &amp;
d\end{smallmatrix}\bigr)\in \mathrm{GL}_2(\mathbb{C})\)</span> stands for the map</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[P(X) \mapsto (b X + d)^j P\bigl(\tfrac{a X + c}{b X + d}\bigr).\]</div>
</div></blockquote>
<p>For a nonzero <span class="math notranslate nohighlight">\(f\)</span> to exist, <span class="math notranslate nohighlight">\(j\)</span> must be even.</p>
<p>Siegel modular forms generate a bi-graded ring which is not finitely
generated. However, if we relax the definition of a Siegel modular form and
allow them to have a pole along the diagonal <span class="math notranslate nohighlight">\(\mathcal{H}_1^2 =
\bigl\{\bigl(\begin{smallmatrix} \tau_1 &amp; 0 \\ 0 &amp;
\tau_2\end{smallmatrix}\bigr)\bigr\}\subset \mathcal{H}_2\)</span> of a certain order
(depending on the weight), we indeed find a finitely generated ring
corresponding to classical “covariants” of a binary sextic. Historically,
covariants are classified in terms of their degree <span class="math notranslate nohighlight">\(k\)</span> and index <span class="math notranslate nohighlight">\(j\)</span>,
corresponding to Siegel modular functions of weight <span class="math notranslate nohighlight">\(\det^{k - j/2}\otimes
\mathrm{Sym}^j\)</span>. See <a class="reference internal" href="references.html#cfg2017" id="id9"><span>[CFG2017]</span></a> for more details on the correspondence between
modular forms and covariants.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_detk_symj">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_detk_symj</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_poly.html#c.acb_poly_t" title="acb_poly_t"><span class="n"><span class="pre">acb_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_poly.html#c.acb_poly_t" title="acb_poly_t"><span class="n"><span class="pre">acb_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_detk_symj" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to <span class="math notranslate nohighlight">\(\det(m)^k \mathrm{Sym}^j(m)(f)\)</span>. The polynomial <span class="math notranslate nohighlight">\(f\)</span> should
be of degree at most <span class="math notranslate nohighlight">\(j\)</span> (any coefficients of larger degree are ignored).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_transvectant">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_transvectant</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_poly.html#c.acb_poly_t" title="acb_poly_t"><span class="n"><span class="pre">acb_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_poly.html#c.acb_poly_t" title="acb_poly_t"><span class="n"><span class="pre">acb_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_poly.html#c.acb_poly_t" title="acb_poly_t"><span class="n"><span class="pre">acb_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lead</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_transvectant" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the <span class="math notranslate nohighlight">\(k\)</span>-th transvectant of the polynomials <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> of
degrees <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>. If <em>lead</em> is true (nonzero), we instead set <em>res</em> to
the constant polynomial containing the leading coefficient of this
transvectant.</p>
<p>Considering <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> as homogeneous polynomials of degree <span class="math notranslate nohighlight">\(m\)</span>
(resp. <span class="math notranslate nohighlight">\(n\)</span>) in <span class="math notranslate nohighlight">\(x_1,x_2\)</span>, this sets <em>res</em> to (the leading coefficient of)
the polynomial</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[(g,h)_k := \frac{(m-k)!(n-k)!}{m!n!}  \sum_{j=0}^{k} (-1)^{k-j} \binom{k}{j}
\frac{\partial^k g}{\partial x_1^{k-j}\partial x_2^j}
\frac{\partial^k h}{\partial x_1^{j}\partial x_2^{k-j}}.\]</div>
</div></blockquote>
<p>Any coefficients of <span class="math notranslate nohighlight">\(g\)</span> or <span class="math notranslate nohighlight">\(h\)</span> of larger degree than <span class="math notranslate nohighlight">\(m\)</span> (resp. <span class="math notranslate nohighlight">\(n\)</span>) are
ignored.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_character">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_character</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_character" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the value in <span class="math notranslate nohighlight">\(\mathbb{Z}/2\mathbb{Z}\)</span> (0 or 1) of the unique
nontrivial character of <span class="math notranslate nohighlight">\(\mathrm{Sp}_4(\mathbb{Z})\)</span> at <em>mat</em>, following
<a class="reference internal" href="references.html#cfg2019" id="id10"><span>[CFG2019]</span></a>, §12.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_even_weight">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_even_weight</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">psi4</span></span>, <a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">psi6</span></span>, <a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">chi10</span></span>, <a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">chi12</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th2</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_even_weight" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>psi4</em>, <em>psi6</em>, <em>chi10</em>, and <em>chi12</em> to the value of the Eisenstein
series <span class="math notranslate nohighlight">\(\psi_4\)</span>, <span class="math notranslate nohighlight">\(\psi_6\)</span> and cusp forms <span class="math notranslate nohighlight">\(\chi_{10}, \chi_{12}\)</span>
corresponding to the given vector <em>th2</em> of squared theta values (of length
16).</p>
<p>We use the formulas from §7.1 in <a class="reference internal" href="references.html#str2014" id="id11"><span>[Str2014]</span></a>, with the following normalizations:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\psi_4 = h_4/4, \quad \psi_6 = h_6/4,\quad \chi_{10} = -2^{-12} h_{10},
\quad \chi_{12} = 2^{-15}h_{12}.\]</div>
</div></blockquote>
<p>We warn that <span class="math notranslate nohighlight">\(\chi_{10}\)</span> and <span class="math notranslate nohighlight">\(\chi_{12}\)</span> differ from the classical notation
of Igusa <a class="reference internal" href="references.html#igu1979" id="id12"><span>[Igu1979]</span></a> by scalar factors. Writing <span class="math notranslate nohighlight">\(\tau =
\bigl(\begin{smallmatrix} \tau_1 &amp; \tau_2 \\ \tau_2 &amp;
\tau_3\end{smallmatrix}\bigr)\)</span> and <span class="math notranslate nohighlight">\(q_j = \exp(2\pi i \tau_j)\)</span>, the Fourier
expansions of these modular forms begin as follows:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned} \psi_4(\tau) &amp;= 1 + 240(q_1 + q_3) + \cdots\\
\psi_6(\tau) &amp;= 1 - 504(q_1 + q_3) + \cdots\\
\chi_{10}(\tau) &amp;= (q_2 - 2 + q_2^{-1}) q_1 q_3 + \cdots\\
\chi_{12}(\tau) &amp;= (q_2 + 10 + q_2^{-1}) q_1 q_3 + \cdots.
\end{aligned}\end{split}\]</div>
</div></blockquote>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_chi5">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_chi5</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_chi5" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the value of <span class="math notranslate nohighlight">\(\chi_5 = - 2^{-6} \prod_{(a,b)\text{ even}}
\theta_{a,b}\)</span> corresponding to the given theta values <em>th</em>. The form
<span class="math notranslate nohighlight">\(\chi_5\)</span> is a Siegel cusp form with character: see <a class="reference internal" href="references.html#cfg2019" id="id13"><span>[CFG2019]</span></a> for more
details.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_chi35">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_chi35</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">th</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_chi35" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the value of the cusp form <span class="math notranslate nohighlight">\(\chi_{35}\)</span> corresponding to the vector
of theta values <em>th</em>. The form <span class="math notranslate nohighlight">\(\chi_{35}\)</span> is the unique scalar-valued Siegel
modular form of weight <span class="math notranslate nohighlight">\(\det^{35}\otimes \mathrm{Sym}^0\)</span> up to scalars, and is
normalized as follows:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\chi_{35}(\tau) = q_1^2 q_3^2 (q_1 - q_3 )(q_2 - q_2^{-1}) + \cdots\]</div>
</div></blockquote>
<p>An explicit formula for <span class="math notranslate nohighlight">\(\chi_{35}\)</span> in terms of theta values is given in
<a class="reference internal" href="references.html#bol1887" id="id14"><span>[Bol1887]</span></a>. See also <a class="reference internal" href="references.html#mum1984" id="id15"><span>[Mum1984]</span></a>, Prop. 6.2 p. 98 for how to translate
Bolza’s notation in terms of theta characteristics.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_chi3_6">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_chi3_6</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_poly.html#c.acb_poly_t" title="acb_poly_t"><span class="n"><span class="pre">acb_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_srcptr" title="acb_srcptr"><span class="n"><span class="pre">acb_srcptr</span></span></a><span class="w"> </span><span class="n"><span class="pre">dth</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_chi3_6" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the value of the vector-valued cusp form with character
<span class="math notranslate nohighlight">\(\chi_{6,3}\)</span> of weight <span class="math notranslate nohighlight">\(\det^3\otimes \mathrm{Sym}^6\)</span> corresponding to the
given values of <em>dth</em>, computed as in e.g. <a class="reference internal" href="#c.acb_theta_jet" title="acb_theta_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet()</span></code></a> with
<span class="math notranslate nohighlight">\(\mathit{ord}=1\)</span> and <em>all</em> set to true. We have by <a class="reference internal" href="references.html#cfg2017" id="id16"><span>[CFG2017]</span></a>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\chi_{3,6}(\tau) = \frac{1}{64\pi^6} \prod_{(a,b) \text{ odd}}
\left(\frac{\partial \theta_{a,b}}{\partial z_1}(0,\tau) x_1 +
\frac{\partial\theta_{a,b}}{\partial z_2}(0,\tau) x_2\right).\]</div>
</div></blockquote>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_sextic_chi5">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_sextic_chi5</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_poly.html#c.acb_poly_t" title="acb_poly_t"><span class="n"><span class="pre">acb_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="acb.html#c.acb_t" title="acb_t"><span class="n"><span class="pre">acb_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">chi5</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_mat.html#c.acb_mat_t" title="acb_mat_t"><span class="n"><span class="pre">acb_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">tau</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_sextic_chi5" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> and <em>chi5</em> to the values of <span class="math notranslate nohighlight">\(\chi_{-2,6}\)</span> and <span class="math notranslate nohighlight">\(\chi_5\)</span> at
<span class="math notranslate nohighlight">\(\tau\)</span>. We reduce <span class="math notranslate nohighlight">\(\tau\)</span> to the Siegel fundamental domain, call
<a class="reference internal" href="#c.acb_theta_jet_notransform" title="acb_theta_jet_notransform"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet_notransform()</span></code></a>, then apply the transformation formula
for Siegel modular forms (which is simpler than the transformation formula
on derivatives of theta functions.) Under the correspondence between Siegel
modular functions and covariants of binary sextics, <span class="math notranslate nohighlight">\(\chi_{-2,6}\)</span>
corresponds to the binary sextic itself, hence the name.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.acb_theta_g2_covariants">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">acb_theta_g2_covariants</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="acb_poly.html#c.acb_poly_struct" title="acb_poly_struct"><span class="n"><span class="pre">acb_poly_struct</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="acb_poly.html#c.acb_poly_t" title="acb_poly_t"><span class="n"><span class="pre">acb_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">lead</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.acb_theta_g2_covariants" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <em>res</em> to the vector of 26 generators of the ring of covariants (or
their leading coefficients, when <em>lead</em> is true) evaluated at the sextic
<em>f</em> (any terms of degree <span class="math notranslate nohighlight">\(&gt;6\)</span> are ignored). We use the following ordering:</p>
<ol class="arabic simple" start="0">
<li><p><span class="math notranslate nohighlight">\(C_{1,6}=f\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{2,0}= 60(f,f)_6\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{2,4}= 75(f,f)_4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{2,8}= 90(f,f)_2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{3,2}= 30(f,C_{2,4})_4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{3,6}= 30(f,C_{2,4})_2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{3,8}= 6(f,C_{2,4})_1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{3,12}= 6 (f,C_{2,8})_1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{4,0}= 2 (C_{2,4},C_{2,4})_4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{4,4}= 30 (f,C_{3,2})_2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{4,6}= 6(f,C_{3,2})_1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{4,10}= 2(C_{2,8},C_{2,4})_1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{5,2}=(C_{2,4},C_{3,2})_2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{5,4}=\frac 25 (C_{2,4},C_{3,2})_1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{5,8}= 2(C_{2,8},C_{3,2})_1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{6,0}= 2(C_{3,2},C_{3,2})_2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{6,6}^{(1)}= \frac 25(C_{3,6},C_{3,2})_1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{6,6}^{(2)}= \frac 83(C_{3,8},C_{3,2})_2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{7,2}= 30(f,C_{3,2}^2)_4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{7,4}= 12(f,C_{3,2}^2)_3\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{8,2}= \frac 25(C_{2,4},C_{3,2}^2)_3\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{9,4}= 4(C_{3,8},C_{3,2}^2)_4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{10,0}= 20(f,C_{3,2}^3)_6\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{10,2}= \frac 65(f,C_{3,2}^3)_5\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{12,2}= \frac 85(C_{3,8},C_{3,2}^3)_6\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C_{15,0}= \frac{1}{30000} (C_{3,8},C_{3,2}^4)_8\)</span>.</p></li>
</ol>
<p>The scalar factors are chosen so that when evaluated at a formal sextic <span class="math notranslate nohighlight">\(f
= \sum a_i x_1^{6-i}x_2^i\)</span>, the covariants are integral and primitive as
multivariate polynomials in <span class="math notranslate nohighlight">\(a_0,\ldots,a_6,x_1,x_2\)</span>.</p>
</dd></dl>

</section>
<section id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Link to this heading">¶</a></h2>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_sp2gz_set_blocks
</pre></div>
</div>
<p>Generates a random <span class="math notranslate nohighlight">\(2g\times 2g\)</span> matrix, calls <a class="reference internal" href="#c.sp2gz_set_blocks" title="sp2gz_set_blocks"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_set_blocks()</span></code></a> on its
four <span class="math notranslate nohighlight">\(g\times g\)</span> windows, and checks that the result equals the original
matrix.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_sp2gz_is_correct
</pre></div>
</div>
<p>Checks that the return value of <a class="reference internal" href="#c.sp2gz_is_correct" title="sp2gz_is_correct"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_is_correct()</span></code></a> is 1 on matrices
generated by <a class="reference internal" href="#c.sp2gz_j" title="sp2gz_j"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_j()</span></code></a>, <a class="reference internal" href="#c.sp2gz_block_diag" title="sp2gz_block_diag"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_block_diag()</span></code></a>, <a class="reference internal" href="#c.sp2gz_trig" title="sp2gz_trig"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_trig()</span></code></a> and
<a class="reference internal" href="#c.sp2gz_fundamental" title="sp2gz_fundamental"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_fundamental()</span></code></a>, and 0 on the identity matrix if it is not square of
even size.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_sp2gz_inv
</pre></div>
</div>
<p>Checks that the result of <a class="reference internal" href="#c.sp2gz_inv" title="sp2gz_inv"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_inv()</span></code></a> agrees with <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_inv" title="fmpz_mat_inv"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_inv()</span></code></a> on
random input.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_sp2gz_decompose
</pre></div>
</div>
<p>Checks that the result of <a class="reference internal" href="#c.sp2gz_decompose" title="sp2gz_decompose"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_decompose()</span></code></a> on random input only consists
of symplectic matrices of the allowed types, and that their product equals the
original matrix.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_siegel_cocycle
./build/acb_theta/test/main<span class="w"> </span>acb_theta_siegel_transform
</pre></div>
</div>
<p>Checks that the chain rules hold: if <span class="math notranslate nohighlight">\(m'' = m'm\)</span> is a product of two symplectic
matrices and <span class="math notranslate nohighlight">\(\tau\in \mathcal{H}_g\)</span>, then <span class="math notranslate nohighlight">\(\gamma''\tau + \delta'' =
(\gamma'\tau' + \delta')(\gamma\tau+\delta)\)</span> where <span class="math notranslate nohighlight">\(\tau' = m\tau\)</span>, and
<span class="math notranslate nohighlight">\(m''\tau = m'\tau'\)</span>. These quantities are computed using
<a class="reference internal" href="#c.acb_siegel_cocycle" title="acb_siegel_cocycle"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_cocycle()</span></code></a> and <a class="reference internal" href="#c.acb_siegel_transform" title="acb_siegel_transform"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_transform()</span></code></a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_siegel_reduce
</pre></div>
</div>
<p>Generates an input matrix <span class="math notranslate nohighlight">\(\tau\)</span> at a working precision that is not too low
compared to the size of its coefficients, and calls <a class="reference internal" href="#c.acb_siegel_reduce" title="acb_siegel_reduce"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_reduce()</span></code></a>.
Checks that the resulting matrix <span class="math notranslate nohighlight">\(m\)</span> is symplectic and that <span class="math notranslate nohighlight">\(m\tau\)</span> is reduced
with a tolerance of <span class="math notranslate nohighlight">\(2^{-10}\)</span> using <a class="reference internal" href="#c.acb_siegel_is_reduced" title="acb_siegel_is_reduced"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_is_reduced()</span></code></a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_siegel_is_reduced
</pre></div>
</div>
<p>Checks that <a class="reference internal" href="#c.acb_siegel_is_reduced" title="acb_siegel_is_reduced"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_is_reduced()</span></code></a> returns 1 on the matrix <span class="math notranslate nohighlight">\(i I_g\)</span>, but
0 on other matrices specially constructed to not be reduced.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_siegel_kappa
</pre></div>
</div>
<p>Checks that the results of <a class="reference internal" href="#c.acb_siegel_kappa" title="acb_siegel_kappa"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_kappa()</span></code></a> are compatible under matrix
multiplication, and when varying the <em>sqr</em> parameter.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_char_set_slong_vec
</pre></div>
</div>
<p>Checks that the functions <a class="reference internal" href="#c.acb_theta_char_set_slong_vec" title="acb_theta_char_set_slong_vec"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_char_set_slong_vec()</span></code></a> and
<a class="reference internal" href="#c.acb_theta_char_bit" title="acb_theta_char_bit"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_char_bit()</span></code></a> are inverses of each other on random input.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_char_dot
</pre></div>
</div>
<p>Checks that dot products computed by <a class="reference internal" href="#c.acb_theta_char_dot" title="acb_theta_char_dot"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_char_dot()</span></code></a>, and
<a class="reference internal" href="#c.acb_theta_char_dot_slong" title="acb_theta_char_dot_slong"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_char_dot_slong()</span></code></a> agree on random input.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_char_table
</pre></div>
</div>
<p>Checks that the <span class="math notranslate nohighlight">\(a\)</span> part of characteristics remains invariant when calling
<a class="reference internal" href="#c.acb_theta_char_table" title="acb_theta_char_table"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_char_table()</span></code></a> on trigonal symplectic matrices as in
<a class="reference internal" href="#c.sp2gz_trig" title="sp2gz_trig"><code class="xref c c-func docutils literal notranslate"><span class="pre">sp2gz_trig()</span></code></a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_char_shuffle
</pre></div>
</div>
<p>Checks that calling <a class="reference internal" href="#c.acb_theta_char_shuffle" title="acb_theta_char_shuffle"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_char_shuffle()</span></code></a> on a random matrix and its
inverse yields inverse transformations.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_jet_tuples
</pre></div>
</div>
<p>For random <em>g</em> and <em>ord</em>, generates the list of derivation tuples using
<a class="reference internal" href="#c.acb_theta_jet_tuples" title="acb_theta_jet_tuples"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet_tuples()</span></code></a>, picks an index <span class="math notranslate nohighlight">\(i\)</span> at random, and checks that the
result of <a class="reference internal" href="#c.acb_theta_jet_index" title="acb_theta_jet_index"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet_index()</span></code></a> on the <span class="math notranslate nohighlight">\(i\)</span>-th tuple is indeed
<span class="math notranslate nohighlight">\(i\)</span>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_jet_mul
</pre></div>
</div>
<p>Checks that the results of <a class="reference internal" href="#c.acb_theta_jet_mul" title="acb_theta_jet_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet_mul()</span></code></a> agrees with the result of
<a class="reference internal" href="fmpz_mpoly.html#c.fmpz_mpoly_mul" title="fmpz_mpoly_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mpoly_mul()</span></code></a> on any input with integral entries.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_jet_compose
</pre></div>
</div>
<p>Checks that the chain rule holds: if <span class="math notranslate nohighlight">\(N_3 = N_2 N_1\)</span>, then applying
<a class="reference internal" href="#c.acb_theta_jet_compose" title="acb_theta_jet_compose"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet_compose()</span></code></a> with <span class="math notranslate nohighlight">\(N_2\)</span>, then <span class="math notranslate nohighlight">\(N_1\)</span> corresponds to applying
<a class="reference internal" href="#c.acb_theta_jet_compose" title="acb_theta_jet_compose"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet_compose()</span></code></a> with <span class="math notranslate nohighlight">\(N_3\)</span> directly.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_eld_points
</pre></div>
</div>
<p>Generates a random ellipsoid <em>E</em> using <a class="reference internal" href="#c.acb_theta_eld_set" title="acb_theta_eld_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_set()</span></code></a>. Then,
generates random points <em>pt</em>: if <em>pt</em> is in <em>E</em> according to
<a class="reference internal" href="#c.acb_theta_eld_contains" title="acb_theta_eld_contains"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_contains()</span></code></a>, then <em>pt</em> must appear in the list of points and
be contained in exactly one child of <em>E</em>; otherwise the norm of <em>pt</em> according
to the chosen Cholesky matrix must be at least the radius of <em>E</em>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_eld_border
</pre></div>
</div>
<p>Generates a random ellipsoid <em>E</em>, computes its border using
<a class="reference internal" href="#c.acb_theta_eld_border" title="acb_theta_eld_border"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_border()</span></code></a>, and checks that none of these border points lie
in <em>E</em>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_eld_distances
</pre></div>
</div>
<p>Checks that when <span class="math notranslate nohighlight">\(y = Y \tfrac{a}{2}\)</span> for some theta characteristic <span class="math notranslate nohighlight">\(a\)</span>, the
result of <a class="reference internal" href="#c.acb_theta_eld_distances" title="acb_theta_eld_distances"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a> on <span class="math notranslate nohighlight">\((z,\tau)\)</span> contains zero in its
<span class="math notranslate nohighlight">\(a\)</span>-th entry.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_sum_radius
./build/acb_theta/test/main<span class="w"> </span>acb_theta_sum_jet_radius
</pre></div>
</div>
<p>Generates a reduced matrix <span class="math notranslate nohighlight">\(\tau\)</span> in <span class="math notranslate nohighlight">\(\mathcal{H}_g\)</span> and vector <span class="math notranslate nohighlight">\(z\in
\mathbb{C}^g\)</span>, calls the tested function, constructs the associated ellipsoid
<em>E</em>, and checks that the sums of absolute values of terms of the theta series
(differentiated or not) on the border of <em>E</em> is at most the specified bound.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_ctx_exp_inv
./build/acb_theta/test/main<span class="w"> </span>acb_theta_ctx_sqr_inv
</pre></div>
</div>
<p>Checks that the output of both functions, even at low precision, contains the
expected values and are never indeterminate.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_ctx_tau_dupl
./build/acb_theta/test/main<span class="w"> </span>acb_theta_ctx_z_dupl
./build/acb_theta/test/main<span class="w"> </span>acb_theta_ctx_z_add_real
</pre></div>
</div>
<p>Checks that the result of those functions overlaps with new contexts
constructed with <a class="reference internal" href="#c.acb_theta_ctx_tau_set" title="acb_theta_ctx_tau_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_set()</span></code></a> and/or
<a class="reference internal" href="#c.acb_theta_ctx_z_set" title="acb_theta_ctx_z_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ctx_z_set()</span></code></a> at <span class="math notranslate nohighlight">\(2\tau\)</span>, <span class="math notranslate nohighlight">\((2z,2\tau)\)</span>, and <span class="math notranslate nohighlight">\((z+t,\tau)\)</span>
respectively.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_sum
</pre></div>
</div>
<p>Checks that the results of <a class="reference internal" href="#c.acb_theta_sum" title="acb_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a> agree with
<a class="reference internal" href="acb_modular.html#c.acb_modular_theta" title="acb_modular_theta"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_modular_theta()</span></code></a> as follows: if the input matrix <span class="math notranslate nohighlight">\(\tau\)</span> is diagonal
with coefficients <span class="math notranslate nohighlight">\(\tau_0,\ldots, \tau_{g-1}\)</span>, then for all characteristics
<span class="math notranslate nohighlight">\((a,b)\)</span> and vectors <span class="math notranslate nohighlight">\(z\)</span>, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\theta_{a,b}(z,\tau) = \prod_{j=0}^{g-1} \theta_{a_j,b_j}(z_j,\tau_j).\]</div>
</div></blockquote>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_sum_jet
</pre></div>
</div>
<p>Checks that the results of <a class="reference internal" href="#c.acb_theta_sum_jet" title="acb_theta_sum_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_jet()</span></code></a> agree with
<a class="reference internal" href="acb_modular.html#c.acb_modular_theta_jet" title="acb_modular_theta_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_modular_theta_jet()</span></code></a> as follows: if the input matrix <span class="math notranslate nohighlight">\(\tau\)</span> is
diagonal with coefficients <span class="math notranslate nohighlight">\(\tau_0,\ldots, \tau_{g-1}\)</span>, then for all
characteristics <span class="math notranslate nohighlight">\((a,b)\)</span>, any vector <span class="math notranslate nohighlight">\(z\)</span>, and any derivation tuple
<span class="math notranslate nohighlight">\((k_0,\ldots,k_{g-1})\)</span>, we have</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\frac{\partial^{|k|} \theta_{a,b}} {\partial z_0^{k_0}\cdots \partial
z_{g-1}^{k-1}}(z,\tau) = \prod_{j=0}^{g-1}
\frac{\partial^{k_j}\theta_{a_j,b_j}}{\partial z^{k_j}}(z_j,\tau_j).\]</div>
</div></blockquote>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_agm_sqrt
</pre></div>
</div>
<p>Generates a random complex number <em>t</em>, sets <em>roots</em> to a low-precision rounding
of <em>t</em> (possibly containing zero), and sets <em>a</em> to the square of <em>t</em>. Checks
that the result of <a class="reference internal" href="#c.acb_theta_agm_sqrt" title="acb_theta_agm_sqrt"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_agm_sqrt()</span></code></a> on this input is finite, contains
<em>t</em>, and that the precision loss is small when <em>roots</em> does not contain zero.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_agm_mul
</pre></div>
</div>
<p>Checks that the duplication formula holds: the result of
<a class="reference internal" href="#c.acb_theta_agm_mul" title="acb_theta_agm_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_agm_mul()</span></code></a> on vectors containing <span class="math notranslate nohighlight">\(\theta_{0,b}(0,\tau)\)</span> and
<span class="math notranslate nohighlight">\(\theta_{0,b}(z,\tau)\)</span> for all <span class="math notranslate nohighlight">\(b\in\{0,1\}^g\)</span> and any choice of <span class="math notranslate nohighlight">\((z,\tau)\)</span>
contains the squared theta values <span class="math notranslate nohighlight">\(\theta_{0,b}^2(2z,2\tau)\)</span>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_agm_mul_tight
</pre></div>
</div>
<p>Generates random <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(z\)</span> at working precision <em>prec</em>, computes the
associated vectors of distances <em>d0</em> and <em>d</em> using
<a class="reference internal" href="#c.acb_theta_eld_distances" title="acb_theta_eld_distances"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a>, and constructs vectors <em>a0</em> and <em>a</em> with
entries of the form <span class="math notranslate nohighlight">\(x e^{-t}\)</span> where <span class="math notranslate nohighlight">\(x\)</span> is uniformly random with <span class="math notranslate nohighlight">\(|x|\leq 1\)</span>
(generated by <a class="reference internal" href="acb.html#c.acb_urandom" title="acb_urandom"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_urandom()</span></code></a>) and <em>t</em> is the corresponding entry of <em>d0</em>
(resp. <em>d</em>). Calls <a class="reference internal" href="#c.acb_theta_agm_mul_tight" title="acb_theta_agm_mul_tight"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_agm_mul_tight()</span></code></a> at a lower precision
<em>mprec</em>. For each <span class="math notranslate nohighlight">\(0\leq k&lt; 2^g\)</span>, checks that the absolute value of the <span class="math notranslate nohighlight">\(k\)</span>-th
entry of the result <em>res</em> is at most <span class="math notranslate nohighlight">\(e^{-d_k}\)</span>, and that the error bound on
that entry is at most <span class="math notranslate nohighlight">\(2^{-\mathit{mprec} + \delta} e^{-d_k}\)</span> for a reasonable
value of <span class="math notranslate nohighlight">\(\delta\)</span> (e.g. 25).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_ql_lower_dim
</pre></div>
</div>
<p>Checks that applying <a class="reference internal" href="#c.acb_theta_ql_lower_dim" title="acb_theta_ql_lower_dim"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a>, computing
lower-dimensional theta values using <a class="reference internal" href="#c.acb_theta_sum" title="acb_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a>, then recombining
them using <a class="reference internal" href="#c.acb_theta_ql_recombine" title="acb_theta_ql_recombine"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_recombine()</span></code></a> agrees with a call to summation
algorithms in dimension <span class="math notranslate nohighlight">\(g\)</span>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_ql_setup
</pre></div>
</div>
<p>Calls <a class="reference internal" href="#c.acb_theta_ql_setup" title="acb_theta_ql_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_setup()</span></code></a> on random input, checks that the output value
is 1, then checks that all the computed low-precision approximations of theta
values are indeed nonzero.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_ql_exact
</pre></div>
</div>
<p>Checks that the result of <a class="reference internal" href="#c.acb_theta_ql_exact" title="acb_theta_ql_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_exact()</span></code></a> agrees with
<a class="reference internal" href="#c.acb_theta_sum" title="acb_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a> on random input, and is not indeterminate.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_ql_local_bound
</pre></div>
</div>
<p>Generates random <span class="math notranslate nohighlight">\((z,\tau)\)</span> at a working precision that is not too low and
calls <a class="reference internal" href="#c.acb_theta_ql_local_bound" title="acb_theta_ql_local_bound"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_local_bound()</span></code></a> to compute the bounds <em>c</em> and
<em>rho</em>. Checks that they are finite and that their definition is satisfied by
sampling theta values on the corresponding neighborhood of <span class="math notranslate nohighlight">\(z\)</span> at low
precisions with <a class="reference internal" href="#c.acb_theta_sum" title="acb_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_ql_jet_error
</pre></div>
</div>
<p>Generates two pairs <span class="math notranslate nohighlight">\((z_1,\tau_1)\)</span> and <span class="math notranslate nohighlight">\((z_2,\tau_2)\)</span> close to each other but
not overlapping, sets <span class="math notranslate nohighlight">\((z,\tau)\)</span> to be their reunion (as complex balls on each
coefficient), and calls <a class="reference internal" href="#c.acb_theta_ql_jet_error" title="acb_theta_ql_jet_error"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_jet_error()</span></code></a> on <span class="math notranslate nohighlight">\((z,\tau)\)</span> for some
choice of derivation order. The difference between the results of
<a class="reference internal" href="#c.acb_theta_sum_jet" title="acb_theta_sum_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_jet()</span></code></a> on <span class="math notranslate nohighlight">\((z_1,\tau_1)\)</span> and <span class="math notranslate nohighlight">\((z_2,\tau_2)\)</span> must then be at
most two times the computed error.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_ql_jet_fd
./build/acb_theta/test/main<span class="w"> </span>acb_theta_jet_notransform
</pre></div>
</div>
<p>Checks that the output of these functions agrees with <a class="reference internal" href="#c.acb_theta_sum_jet" title="acb_theta_sum_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_jet()</span></code></a>
on random input, and is not indeterminate.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_reduce_z
</pre></div>
</div>
<p>Checks that on random input, the entries of the output <em>r</em> always consist of
even integers, and the imaginary part of <em>new_zs</em> is indeed <span class="math notranslate nohighlight">\(y - Yr\)</span>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_jet
</pre></div>
</div>
<p>Checks that the output of <a class="reference internal" href="#c.acb_theta_jet" title="acb_theta_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet()</span></code></a> and
<a class="reference internal" href="#c.acb_theta_jet_notransform" title="acb_theta_jet_notransform"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_jet_notransform()</span></code></a> agree. The matrix <span class="math notranslate nohighlight">\(\tau\)</span> is chosen to be a
priori non-reduced but still reasonably close to the reduced domain.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_detk_symj
</pre></div>
</div>
<p>Checks that the chain rule holds for the representation <span class="math notranslate nohighlight">\(\det^k \mathrm{Sym}^j\)</span>
of <span class="math notranslate nohighlight">\(\mathrm{GL}_2(\mathbb{C})\)</span> as computed by <a class="reference internal" href="#c.acb_theta_g2_detk_symj" title="acb_theta_g2_detk_symj"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_detk_symj()</span></code></a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_transvectant
</pre></div>
</div>
<p>Checks that on any sextic polynomial <span class="math notranslate nohighlight">\(f = \sum_{j=0}^6 a_j x^{6-j}\)</span>, the
transvectant <span class="math notranslate nohighlight">\((f,f)_6\)</span> as computed by <a class="reference internal" href="#c.acb_theta_g2_transvectant" title="acb_theta_g2_transvectant"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_transvectant()</span></code></a> is
<span class="math notranslate nohighlight">\(-3a_2^3 + 8a_2 a_4 - 20a_1 a_5 + 120a_0 a_6\)</span>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_character
</pre></div>
</div>
<p>Checks that the results of <a class="reference internal" href="#c.acb_theta_g2_character" title="acb_theta_g2_character"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_character()</span></code></a> and
<a class="reference internal" href="#c.acb_siegel_kappa2" title="acb_siegel_kappa2"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_kappa2()</span></code></a> for <span class="math notranslate nohighlight">\(g=2\)</span> are compatible, using the fact that the
product <span class="math notranslate nohighlight">\(\chi_5\)</span> of the ten even theta constants is a Siegel modular form with
character.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_even_weight
./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_chi35
</pre></div>
</div>
<p>Checks that the computed values of those modular forms are either invariant,
multiplied by <span class="math notranslate nohighlight">\(\pm 1\)</span>, or by a power of <span class="math notranslate nohighlight">\(i\)</span> (depending on the weight modulo 4)
when applying <a class="reference internal" href="#c.acb_theta_char_shuffle" title="acb_theta_char_shuffle"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_char_shuffle()</span></code></a> on any input vector. The
multiplicative factor is given by <a class="reference internal" href="#c.acb_siegel_kappa2" title="acb_siegel_kappa2"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_kappa2()</span></code></a>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_chi5
</pre></div>
</div>
<p>Checks that the result of <a class="reference internal" href="#c.acb_theta_g2_chi5" title="acb_theta_g2_chi5"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_chi5()</span></code></a> squares to <span class="math notranslate nohighlight">\(\chi_{10}\)</span> on
any input vector.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_chi3_6
</pre></div>
</div>
<p>Checks that the product <span class="math notranslate nohighlight">\(\chi_{8,6} = \chi_{5}\chi_{3,6}\)</span>, computed using
<a class="reference internal" href="#c.acb_theta_g2_chi5" title="acb_theta_g2_chi5"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_chi5()</span></code></a> and <a class="reference internal" href="#c.acb_theta_g2_chi3_6" title="acb_theta_g2_chi3_6"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_chi3_6()</span></code></a>, indeed defines a
modular form of weight <span class="math notranslate nohighlight">\(\det^8\mathrm{Sym}^6\)</span> by evaluating both sides of the
transformation law on random input.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_sextic_chi5
</pre></div>
</div>
<p>Checks that the discriminant of the computed sextic on a random matrix <span class="math notranslate nohighlight">\(\tau\)</span>
is <span class="math notranslate nohighlight">\(2^{12}\chi_{10}(\tau)\)</span>, as computed by <a class="reference internal" href="#c.acb_theta_g2_even_weight" title="acb_theta_g2_even_weight"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_even_weight()</span></code></a>,
and also that <span class="math notranslate nohighlight">\(\chi_5(\tau)^2 = \chi_{10}(\tau)\)</span>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/test/main<span class="w"> </span>acb_theta_g2_covariants
</pre></div>
</div>
<p>Checks that the output of <a class="reference internal" href="#c.acb_theta_g2_covariants" title="acb_theta_g2_covariants"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_covariants()</span></code></a> agrees with that of
<a class="reference internal" href="#c.acb_theta_g2_even_weight" title="acb_theta_g2_even_weight"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_even_weight()</span></code></a> using the relation <span class="math notranslate nohighlight">\(20\psi_4 = - C_{2,0} + 3
C_{4,0})\)</span>. Also checks that each covariant, when evaluated on the result of
<a class="reference internal" href="#c.acb_theta_g2_sextic_chi5" title="acb_theta_g2_sextic_chi5"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_g2_sextic_chi5()</span></code></a>, defines a Siegel modular function of the
correct weight by evaluating the transformation law, and that covariants take
integral values when the input polynomial is integral.</p>
</section>
<section id="profiling">
<h2>Profiling<a class="headerlink" href="#profiling" title="Link to this heading">¶</a></h2>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/profile/p-sum<span class="w"> </span>g<span class="w"> </span>prec<span class="w"> </span>all_a<span class="w"> </span>all_b<span class="w"> </span>tilde<span class="w"> </span>skew
</pre></div>
</div>
<p>Profiles <a class="reference internal" href="#c.acb_theta_sum" title="acb_theta_sum"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a> for the given parameters on a random pair
<span class="math notranslate nohighlight">\((z,\tau)\)</span> generated by <a class="reference internal" href="#c.acb_siegel_randtest_compact" title="acb_siegel_randtest_compact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_randtest_compact()</span></code></a> and
<a class="reference internal" href="#c.acb_siegel_randtest_vec_reduced" title="acb_siegel_randtest_vec_reduced"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_randtest_vec_reduced()</span></code></a>, except that the last line and last
column of <span class="math notranslate nohighlight">\(\tau\)</span> are multiplied by the integer <em>skew</em> (which should be at least
1).</p>
<p>This is to observe how the performance of different steps in the summation
algorithm (computing distances, setting contexts, and summation itself)
behaves, especially as <span class="math notranslate nohighlight">\(g\)</span> grows and at low precisions.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/profile/p-ql_setup<span class="w"> </span>g<span class="w"> </span>nb_steps<span class="w"> </span>all<span class="w"> </span>skew
</pre></div>
</div>
<p>Profiles <a class="reference internal" href="#c.acb_theta_ql_setup" title="acb_theta_ql_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_setup()</span></code></a> for the given parameters on random pairs
<span class="math notranslate nohighlight">\((0,\tau)\)</span> and <span class="math notranslate nohighlight">\((z,\tau)\)</span>, generated using <em>skew</em> as above.</p>
<p>This is to check that <a class="reference internal" href="#c.acb_theta_ql_setup" title="acb_theta_ql_setup"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_setup()</span></code></a> continues to succeed and to be
cheap even as <em>prec</em> or <em>nb_steps</em> grow, thus validating how precisions are
managed internally.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/profile/p-ql_exact<span class="w"> </span>g<span class="w"> </span>pmin<span class="w"> </span>pmax<span class="w"> </span>cst<span class="w"> </span>s<span class="w"> </span>exp
</pre></div>
</div>
<p>Profiles <a class="reference internal" href="#c.acb_theta_ql_exact" title="acb_theta_ql_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_exact()</span></code></a> on random pairs <span class="math notranslate nohighlight">\((0,\tau)\)</span> and <span class="math notranslate nohighlight">\((z,\tau)\)</span>
in dimension <span class="math notranslate nohighlight">\(g\)</span>. The input is generated by <a class="reference internal" href="#c.acb_siegel_randtest_compact" title="acb_siegel_randtest_compact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_randtest_compact()</span></code></a>
and <a class="reference internal" href="#c.acb_siegel_randtest_vec_reduced" title="acb_siegel_randtest_vec_reduced"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_randtest_vec_reduced()</span></code></a>, except that the last <em>s</em> lines and
columns of <em>tau</em> are multiplied by <span class="math notranslate nohighlight">\(2^{\mathit{exp}}\)</span>.</p>
<p>For growing precisions from <em>pmin</em> to <em>pmax</em> (by exponential steps), we call
<a class="reference internal" href="#c.acb_theta_ql_nb_steps" title="acb_theta_ql_nb_steps"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_nb_steps()</span></code></a> to get a suggested <em>pattern</em>, then measure how
<a class="reference internal" href="#c.acb_theta_ql_exact" title="acb_theta_ql_exact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_exact()</span></code></a> performs on this pattern and neighboring
ones. Ideally, the suggested pattern should be the optimal one, indicating that
<a class="reference internal" href="#c.acb_theta_ql_nb_steps" title="acb_theta_ql_nb_steps"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_nb_steps()</span></code></a> gives an optimal answer for the given input.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./build/acb_theta/profile/p-ql_jet_fd<span class="w"> </span>g<span class="w"> </span>prec<span class="w"> </span>ord<span class="w"> </span>all
</pre></div>
</div>
<p>Profiles <a class="reference internal" href="#c.acb_theta_ql_jet_fd" title="acb_theta_ql_jet_fd"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_jet_fd()</span></code></a> and compares it with
<a class="reference internal" href="#c.acb_theta_sum_jet" title="acb_theta_sum_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_sum_jet()</span></code></a> for the given parameters on random input <span class="math notranslate nohighlight">\((z,\tau)\)</span>
generated by <a class="reference internal" href="#c.acb_siegel_randtest_compact" title="acb_siegel_randtest_compact"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_randtest_compact()</span></code></a> and
<a class="reference internal" href="#c.acb_siegel_randtest_vec_reduced" title="acb_siegel_randtest_vec_reduced"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_siegel_randtest_vec_reduced()</span></code></a>. This is to gain information on which
algorithm <a class="reference internal" href="#c.acb_theta_ql_jet" title="acb_theta_ql_jet"><code class="xref c c-func docutils literal notranslate"><span class="pre">acb_theta_ql_jet()</span></code></a> should use.</p>
</section>
</section>

</main>

                  
<!-- #Article navigation -->
<nav class="my-8">
  <ul
    class="text-secondary-content flex justify-between gap-4"
  >
    
      <li class="flex flex-col gap-1">
        <span class="flex items-center text-xs font-light">
          <span class="icon-[prime--angle-left]"></span>
          Previous
        </span>
        <a
          class="hover:text-accent-content text-sm underline"
          href="acb_modular.html"
          title="Previous article"
          ><strong>acb_modular.h</strong> – modular forms of complex variables</a
        >
      </li>
    
    
      <li class="flex flex-col gap-1 lg:items-end">
        <span class="flex items-center text-xs font-light">
          Next
          <span class="icon-[prime--angle-right]"></span>
        </span>
        <a
          class="hover:text-accent-content text-sm underline"
          href="acb_dirichlet.html"
          title="Next article"
          ><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a
        >
      </li>
    
  </ul>
</nav>
<!-- .#Article navigation -->
                  
<!-- #Article footer -->
<footer
  class="article-footer border-base-200 text-secondary-content/80 my-4 border-t pt-8 text-sm"
>
  <div class="flex flex-col justify-between gap-4 lg:flex-row">
    <div class="article-footer__left">
      
      
    </div>
    <div class="article-footer__right">
      
      
    </div>
  </div>
</footer>
<!-- .#Article footer -->
                </article>

                <!-- #Primary drawer (desktop) -->
                <nav
                  class="lg:sticky lg:top-[calc(var(--header-height)+var(--header-padding))] lg:h-[calc(100vh-var(--header-height)-calc(var(--header-padding)*2))] lg:overflow-y-auto scrollbar-overlay hidden lg:order-1 lg:block lg:w-2/12 lg:flex-none"
                >
                  


  <div class="global-toc">
    <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html"><strong>Building, testing and installing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="bug_reporting.html"><strong>Bug reporting</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing to FLINT</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html"><strong>Contributors</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html"><strong>Memory management</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="portability.html"><strong>Portability</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="threading.html"><strong>Threading</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flint.html"><strong>flint.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html"><strong>profiler.h</strong> – performance profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread_pool.html"><strong>thread_pool.h</strong> – thread pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpoly.html"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_vectors.html"><strong>machine_vectors.h</strong> – SIMD-accelerated operations on fixed-length vectors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generic rings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gr.html"><strong>gr.h</strong> – generic structures and their elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_implementing.html"><strong>gr.h (continued)</strong> – implementing rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_domains.html"><strong>gr.h (continued)</strong> – builtin domains and types</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_generic.html"><strong>gr_generic.h</strong> – basic algorithms and fallback implementations for generic elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_special.html"><strong>gr_special.h</strong> – special arithmetic and transcendental functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_vec.html"><strong>gr_vec.h</strong> – vectors over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mat.html"><strong>gr_mat.h</strong> – dense matrices over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_poly.html"><strong>gr_poly.h</strong> – dense univariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mpoly.html"><strong>gr_mpoly.h</strong> – sparse multivariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_series.html"><strong>gr_series.h</strong> – formal power series over generic rings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_generic.html"><strong>Generic rings</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ulong_extras.html"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz.html"><strong>fmpz.h</strong> – integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_vec.html"><strong>fmpz_vec.h</strong> – vectors of integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_factor.html"><strong>fmpz_factor.h</strong> – integer factorisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mat.html"><strong>fmpz_mat.h</strong> – matrices over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_lll.html"><strong>fmpz_lll.h</strong> – LLL reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly.html"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_mat.html"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_factor.html"><strong>fmpz_poly_factor.h</strong> – factorisation of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly.html"><strong>fmpz_mpoly.h</strong> – multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_factor.html"><strong>fmpz_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="long_extras.html"><strong>long_extras.h</strong> – support functions for signed word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="longlong.html"><strong>longlong.h</strong> – support functions for multi-word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_extras.html"><strong>mpn_extras.h</strong> – support functions for limb arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="aprcl.html"><strong>aprcl.h</strong> – APRCL primality testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arith.html"><strong>arith.h</strong> – arithmetic and special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft_small.html"><strong>fft_small.h</strong> – FFT modulo word-size primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="qsieve.html"><strong>qsieve.h</strong> – Quadratic sieve</a></li>
<li class="toctree-l1"><a class="reference internal" href="radix.html"><strong>radix.h</strong> – multiprecision arithmetic in general radix</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers.html"><strong>Integers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Rational numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fmpq.html"><strong>fmpq.h</strong> – rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_vec.html"><strong>fmpq_vec.h</strong> – vectors over rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mat.html"><strong>fmpq_mat.h</strong> – matrices over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_poly.html"><strong>fmpq_poly.h</strong> – univariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly_factor.html"><strong>fmpq_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly.html"><strong>fmpq_mpoly.h</strong> – multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_q.html"><strong>fmpz_poly_q.h</strong> – rational functions over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_q.html"><strong>fmpz_mpoly_q.h</strong> – multivariate rational functions over Q</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_rationals.html"><strong>Rational numbers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers mod n</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nmod.html"><strong>nmod.h</strong> – integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_vec.html"><strong>nmod_vec.h</strong> – vectors over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mat.html"><strong>nmod_mat.h</strong> – matrices over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly.html"><strong>nmod_poly.h</strong> – univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_mat.html"><strong>nmod_poly_mat.h</strong> – matrices of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_factor.html"><strong>nmod_poly_factor.h</strong> – factorisation of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly.html"><strong>nmod_mpoly.h</strong> – multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly_factor.html"><strong>nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_mod.html"><strong>mpn_mod.h</strong> – integers mod n (packed multi-word n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod.html"><strong>fmpz_mod.h</strong> – arithmetic modulo integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_vec.html"><strong>fmpz_mod_vec.h</strong> – vectors over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mat.html"><strong>fmpz_mod_mat.h</strong> – matrices over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly.html"><strong>fmpz_mod_poly.h</strong> – polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly_factor.html"><strong>fmpz_mod_poly_factor.h</strong> – factorisation of polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly.html"><strong>fmpz_mod_mpoly.h</strong> – polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_factor.html"><strong>fmpz_mod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_q.html"><strong>fmpz_mod_mpoly_q.h</strong> – multivariate rational functions over Z/mZ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers_mod.html"><strong>Integers mod n</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Groups and other structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="perm.html"><strong>perm.h</strong> – permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="qfb.html"><strong>qfb.h</strong> – binary quadratic forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dirichlet.html"><strong>dirichlet.h</strong> – Dirichlet characters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlog.html"><strong>dlog.h</strong> – discrete logarithms mod ulong primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="bool_mat.html"><strong>bool_mat.h</strong> – matrices over booleans</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Number fields and algebraic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nf.html"><strong>nf.h</strong> – number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="nf_elem.html"><strong>nf_elem.h</strong> – number field elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpzi.html"><strong>fmpzi.h</strong> – Gaussian integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qqbar.html"><strong>qqbar.h</strong> – algebraic numbers represented by minimal polynomials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real and complex numbers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Feature overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using ball arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Technical conventions and potential issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_arb.html">Arb example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="mag.html"><strong>mag.h</strong> – fixed-precision unsigned floating-point numbers for bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="nfloat.html"><strong>nfloat.h</strong> – packed floating-point numbers with n-word precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="arf.html"><strong>arf.h</strong> – arbitrary-precision floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acf.html"><strong>acf.h</strong> – complex floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb.html"><strong>arb.h</strong> – real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb.html"><strong>acb.h</strong> – complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_poly.html"><strong>arb_poly.h</strong> – polynomials over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_poly.html"><strong>acb_poly.h</strong> – polynomials over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fmpz_poly.html"><strong>arb_fmpz_poly.h</strong> – extra methods for integer polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dft.html"><strong>acb_dft.h</strong> – Discrete Fourier transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_mat.html"><strong>arb_mat.h</strong> – matrices over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_mat.html"><strong>acb_mat.h</strong> – matrices over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_hypgeom.html"><strong>acb_hypgeom.h</strong> – hypergeometric functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_hypgeom.html"><strong>arb_hypgeom.h</strong> – hypergeometric functions of real variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_elliptic.html"><strong>acb_elliptic.h</strong> – elliptic integrals and functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_modular.html"><strong>acb_modular.h</strong> – modular forms of complex variables</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>acb_theta.h</strong> – Riemann theta functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dirichlet.html"><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bernoulli.html"><strong>bernoulli.h</strong> – support for Bernoulli numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypgeom.html"><strong>hypgeom.h</strong> – support for hypergeometric series</a></li>
<li class="toctree-l1"><a class="reference internal" href="partitions.html"><strong>partitions.h</strong> – computation of the partition function</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_calc.html"><strong>arb_calc.h</strong> – calculus with real-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_calc.html"><strong>acb_calc.h</strong> – calculus with complex-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fpwrap.html"><strong>arb_fpwrap.h</strong> – floating-point wrappers of Arb mathematical functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_extras.html"><strong>fmpz_extras.h</strong> – extra methods for FLINT integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">General formulas and bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">Algorithms for mathematical constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma.html">Algorithms for the gamma function</a></li>
<li class="toctree-l1"><a class="reference internal" href="hurwitz.html">Algorithms for the Hurwitz zeta function</a></li>
<li class="toctree-l1"><a class="reference internal" href="polylogarithms.html">Algorithms for polylogarithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergeometric.html">Algorithms for hypergeometric functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="agm.html">Algorithms for the arithmetic-geometric mean</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index_arb.html"><strong>Real and complex numbers (Arb)</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_calcium.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_calcium.html">Calcium example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="calcium.html"><strong>calcium.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca.html"><strong>ca.h</strong> – exact real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_vec.html"><strong>ca_vec.h</strong> – vectors of real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_poly.html"><strong>ca_poly.h</strong> – dense univariate polynomials over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_mat.html"><strong>ca_mat.h</strong> – matrices over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_ext.html"><strong>ca_ext.h</strong> – real and complex extension numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_field.html"><strong>ca_field.h</strong> – extension fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr.html"><strong>fexpr.h</strong> – flat-packed symbolic expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr_builtin.html"><strong>fexpr_builtin.h</strong> – builtin symbols</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite fields</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq.html"><strong>fq.h</strong> – finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default.html"><strong>fq_default.h</strong> – unified finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_vec.html"><strong>fq_vec.h</strong> – vectors over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_mat.html"><strong>fq_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_mat.html"><strong>fq_default_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly.html"><strong>fq_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly.html"><strong>fq_default_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly_factor.html"><strong>fq_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly_factor.html"><strong>fq_default_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_embed.html"><strong>fq_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod.html"><strong>fq_nmod.h</strong> – finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_vec.html"><strong>fq_nmod_vec.h</strong> – vectors over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mat.html"><strong>fq_nmod_mat.h</strong> – matrices over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly.html"><strong>fq_nmod_poly.h</strong> – univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly_factor.html"><strong>fq_nmod_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_embed.html"><strong>fq_nmod_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly.html"><strong>fq_nmod_mpoly.h</strong> – multivariate polynomials over finite fields of word-sized characteristic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly_factor.html"><strong>fq_nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over finite fields of word-sized characteristic</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_zech.html"><strong>fq_zech.h</strong> – finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_vec.html"><strong>fq_zech_vec.h</strong> – vectors over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_mat.html"><strong>fq_zech_mat.h</strong> – matrices over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly.html"><strong>fq_zech_poly.h</strong> – univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly_factor.html"><strong>fq_zech_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_embed.html"><strong>fq_zech_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">p-adic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="padic.html"><strong>padic.h</strong> – p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_poly.html"><strong>padic_poly.h</strong> – polynomials over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_mat.html"><strong>padic_mat.h</strong> – matrices over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qadic.html"><strong>qadic.h</strong> – unramified extensions over p-adic numbers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Floating-point support code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="double_extras.html"><strong>double_extras.h</strong> – support functions for double arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="double_interval.html"><strong>double_interval.h</strong> – double-precision interval arithmetic and helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_vec.html"><strong>d_vec.h</strong> – double precision vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_mat.html"><strong>d_mat.h</strong> – double precision matrices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_flint.html"><strong>flint_ctypes</strong> - Python interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Version history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="history.html">History and changes</a></li>
</ul>

  </div>

                </nav>
                <!-- .#Primary drawer (desktop) -->

                <!-- #Secondary drawer (desktop) -->
                <aside
                  class="lg:sticky lg:top-[calc(var(--header-height)+var(--header-padding))] lg:h-[calc(100vh-var(--header-height)-calc(var(--header-padding)*2))] lg:overflow-y-auto scrollbar-overlay hidden lg:order-3 lg:block lg:w-2/12 lg:flex-none"
                >
                  


  
    <div class="local-toc">
      <p class="local-toc__caption mt-0 mb-4 font-semibold uppercase">
        On this page
      </p>
      <ul>
<li><a class="reference internal" href="#"><strong>acb_theta.h</strong> – Riemann theta functions</a><ul>
<li><a class="reference internal" href="#main-user-functions">Main user functions</a><ul>
<li><a class="reference internal" href="#c.acb_theta_char_set_slong_vec"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_set_slong_vec()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_one"><code class="docutils literal notranslate"><span class="pre">acb_theta_one()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_all"><code class="docutils literal notranslate"><span class="pre">acb_theta_all()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-of-usage">Example of usage</a></li>
<li><a class="reference internal" href="#the-siegel-modular-group">The Siegel modular group</a><ul>
<li><a class="reference internal" href="#c.sp2gz_dim"><code class="docutils literal notranslate"><span class="pre">sp2gz_dim()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_set_blocks"><code class="docutils literal notranslate"><span class="pre">sp2gz_set_blocks()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_j"><code class="docutils literal notranslate"><span class="pre">sp2gz_j()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_block_diag"><code class="docutils literal notranslate"><span class="pre">sp2gz_block_diag()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_trig"><code class="docutils literal notranslate"><span class="pre">sp2gz_trig()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_embed"><code class="docutils literal notranslate"><span class="pre">sp2gz_embed()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_restrict"><code class="docutils literal notranslate"><span class="pre">sp2gz_restrict()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_nb_fundamental"><code class="docutils literal notranslate"><span class="pre">sp2gz_nb_fundamental()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_fundamental"><code class="docutils literal notranslate"><span class="pre">sp2gz_fundamental()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_correct"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_correct()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_j"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_j()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_block_diag"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_block_diag()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_trig"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_trig()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_embedded"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_embedded()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_inv"><code class="docutils literal notranslate"><span class="pre">sp2gz_inv()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_decompose"><code class="docutils literal notranslate"><span class="pre">sp2gz_decompose()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_randtest"><code class="docutils literal notranslate"><span class="pre">sp2gz_randtest()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-siegel-half-space">The Siegel half space</a><ul>
<li><a class="reference internal" href="#c.acb_siegel_cocycle"><code class="docutils literal notranslate"><span class="pre">acb_siegel_cocycle()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_transform_cocycle_inv"><code class="docutils literal notranslate"><span class="pre">acb_siegel_transform_cocycle_inv()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_transform"><code class="docutils literal notranslate"><span class="pre">acb_siegel_transform()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_cho_yinv"><code class="docutils literal notranslate"><span class="pre">acb_siegel_cho_yinv()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_reduce"><code class="docutils literal notranslate"><span class="pre">acb_siegel_reduce()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_is_reduced"><code class="docutils literal notranslate"><span class="pre">acb_siegel_is_reduced()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_kappa"><code class="docutils literal notranslate"><span class="pre">acb_siegel_kappa()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_kappa2"><code class="docutils literal notranslate"><span class="pre">acb_siegel_kappa2()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest_reduced"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest_reduced()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest_compact"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest_compact()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest_vec"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest_vec()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest_vec_reduced"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest_vec_reduced()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#theta-characteristics">Theta characteristics</a><ul>
<li><a class="reference internal" href="#c.acb_theta_char_bit"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_bit()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_get_arb"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_get_arb()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_get_acb"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_get_acb()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_dot"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_dot()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_dot_slong"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_dot_slong()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_is_even"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_is_even()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_table"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_table()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_shuffle"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_shuffle()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#toolbox-for-derivatives">Toolbox for derivatives</a><ul>
<li><a class="reference internal" href="#c.acb_theta_jet_nb"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_nb()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_total_order"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_total_order()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_tuples"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_tuples()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_index"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_index()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_mul"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_compose"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_compose()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_exp_pi_i"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_exp_pi_i()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_exp_qf"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_exp_qf()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ellipsoids">Ellipsoids</a><ul>
<li><a class="reference internal" href="#c.acb_theta_eld_struct"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_struct</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_t"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_t</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_init"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_init()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_clear"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_set"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_set()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_nb_pts"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_nb_pts()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_points"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_points()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_box"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_box()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_nb_border"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_nb_border()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_border"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_border()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_contains"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_contains()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_print"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_print()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_distances"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-bounds-in-summation-algorithms">Error bounds in summation algorithms</a><ul>
<li><a class="reference internal" href="#c.acb_theta_sum_radius"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_radius()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_jet_radius"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_jet_radius()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_term"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_term()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_addprec"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_addprec()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-structures-in-summation-algorithms">Context structures in summation algorithms</a><ul>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_struct"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_struct</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_t"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_t</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_struct"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_struct</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_t"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_t</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_init"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_init()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_clear"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_init"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_init()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_clear"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_vec_init"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_vec_init()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_vec_clear"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_vec_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_exp_inv"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_exp_inv()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_sqr_inv"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_sqr_inv()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_set"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_set()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_dupl"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_dupl()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_overlaps"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_overlaps()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_set"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_set()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_dupl"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_dupl()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_add_real"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_add_real()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_common_v"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_common_v()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_overlaps"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_overlaps()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#summation-algorithms">Summation algorithms</a><ul>
<li><a class="reference internal" href="#c.acb_theta_sum_worker_t"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_worker_t</span></code></a><ul>
<li><a class="reference internal" href="#c.acb_theta_sum_worker_t.worker"><code class="docutils literal notranslate"><span class="pre">worker()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#c.acb_theta_sum_sqr_pow"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_sqr_pow()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_work"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_work()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_jet"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_jet()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#agm-steps">AGM steps</a><ul>
<li><a class="reference internal" href="#c.acb_theta_agm_sqrt"><code class="docutils literal notranslate"><span class="pre">acb_theta_agm_sqrt()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_agm_mul"><code class="docutils literal notranslate"><span class="pre">acb_theta_agm_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_agm_mul_tight"><code class="docutils literal notranslate"><span class="pre">acb_theta_agm_mul_tight()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#quasilinear-algorithms-on-reduced-input">Quasilinear algorithms on reduced input</a><ul>
<li><a class="reference internal" href="#c.acb_theta_ql_nb_steps"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_nb_steps()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_lower_dim"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_recombine"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_recombine()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_setup"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_setup()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_exact"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_exact()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_local_bound"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_local_bound()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_jet_error"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_jet_error()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_jet_fd"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_jet_fd()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_jet"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_jet()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#reduction-and-main-functions">Reduction and main functions</a><ul>
<li><a class="reference internal" href="#c.acb_theta_jet_notransform"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_notransform()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_reduce_tau"><code class="docutils literal notranslate"><span class="pre">acb_theta_reduce_tau()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_reduce_z"><code class="docutils literal notranslate"><span class="pre">acb_theta_reduce_z()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#dimension-2-specifics">Dimension 2 specifics</a><ul>
<li><a class="reference internal" href="#c.acb_theta_g2_detk_symj"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_detk_symj()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_transvectant"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_transvectant()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_character"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_character()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_even_weight"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_even_weight()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_chi5"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_chi5()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_chi35"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_chi35()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_chi3_6"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_chi3_6()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_sextic_chi5"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_sextic_chi5()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_covariants"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_covariants()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#tests">Tests</a></li>
<li><a class="reference internal" href="#profiling">Profiling</a></li>
</ul>
</li>
</ul>

    </div>
  

                </aside>
                <!-- .#Secondary drawer (desktop) -->
              </div>
            </main>

            
<footer class="p-4">
  <div
    class="text-secondary-content container mx-auto flex h-8 items-center justify-center text-center text-sm"
  >
    <div>
        Copyright &copy; 2009-2025, The FLINT development team
      <br class="lg:hidden" />
      Made with
      <a
        href="https://www.sphinx-doc.org"
        class="hover:text-accent-content underline"
        >Sphinx</a
      >
      and
      <a
        href="https://readcraft.io/sphinx-clarity-theme/?utm_source=sphinx_clarity_theme"
        class="hover:text-accent-content underline"
        >Clarity Theme for Sphinx </a
      >.
    </div>
  </div>
</footer>
          </div>

          
<!-- #Scroll to top -->
<div id="scroll-to-top" class="toast toast-end">
  <a
    class="btn btn-secondary btn-sm"
    href="#top"
    aria-label="Scroll to top"
  >
    Back to top
    <span class="icon-[prime--arrow-up] text-base"></span>
  </a>
</div>
<!-- .#Scroll to top -->
          
<!-- #Search dialog -->
<dialog id="searchModal" class="modal">
  <div class="modal-box absolute top-8 lg:top-16">
    <search>
      <form action="search.html" method="get">
        <label class="input input-xl w-full">
          <span class="icon-[prime--search] text-4xl"></span>
          <input
            type="search"
            class="grow"
            placeholder="Search the docs"
            name="q"
            placeholder="Search the documentation"
            aria-label="Search the documentation"
          />
          <kbd class="kbd kbd-lg p-4">Enter</kbd>
        </label>
      </form>
    </search>
    <p class="mt-4 text-sm">
      Press <kbd class="kbd">Enter</kbd> to search. Press
      <kbd class="kbd">Esc</kbd> or click outside to close.
    </p>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>close</button>
  </form>
</dialog>
<!-- .#Search dialog -->

          <!-- ====================================================== -->
          <!-- .Page content -->
          <!-- ====================================================== -->

          <!-- ====================================================== -->
          <!-- Secondary drawer after markup -->
          <!-- ====================================================== -->
        </div>
        <div class="drawer-side">
          <label
            for="secondary-drawer"
            class="drawer-overlay"
            aria-label="Close secondary sidebar"
          ></label>
          <div
            class="bg-base-100 text-base-content mt-[var(--header-height)] min-h-full w-80 overflow-y-auto p-4"
          >
            <!-- ==================================================== -->
            <!-- Secondary drawer (mobile) content -->
            <!-- ==================================================== -->
            <div class="text-xs">


  
    <div class="local-toc">
      <p class="local-toc__caption mt-0 mb-4 font-semibold uppercase">
        On this page
      </p>
      <ul>
<li><a class="reference internal" href="#"><strong>acb_theta.h</strong> – Riemann theta functions</a><ul>
<li><a class="reference internal" href="#main-user-functions">Main user functions</a><ul>
<li><a class="reference internal" href="#c.acb_theta_char_set_slong_vec"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_set_slong_vec()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_one"><code class="docutils literal notranslate"><span class="pre">acb_theta_one()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_all"><code class="docutils literal notranslate"><span class="pre">acb_theta_all()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-of-usage">Example of usage</a></li>
<li><a class="reference internal" href="#the-siegel-modular-group">The Siegel modular group</a><ul>
<li><a class="reference internal" href="#c.sp2gz_dim"><code class="docutils literal notranslate"><span class="pre">sp2gz_dim()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_set_blocks"><code class="docutils literal notranslate"><span class="pre">sp2gz_set_blocks()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_j"><code class="docutils literal notranslate"><span class="pre">sp2gz_j()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_block_diag"><code class="docutils literal notranslate"><span class="pre">sp2gz_block_diag()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_trig"><code class="docutils literal notranslate"><span class="pre">sp2gz_trig()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_embed"><code class="docutils literal notranslate"><span class="pre">sp2gz_embed()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_restrict"><code class="docutils literal notranslate"><span class="pre">sp2gz_restrict()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_nb_fundamental"><code class="docutils literal notranslate"><span class="pre">sp2gz_nb_fundamental()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_fundamental"><code class="docutils literal notranslate"><span class="pre">sp2gz_fundamental()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_correct"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_correct()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_j"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_j()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_block_diag"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_block_diag()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_trig"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_trig()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_is_embedded"><code class="docutils literal notranslate"><span class="pre">sp2gz_is_embedded()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_inv"><code class="docutils literal notranslate"><span class="pre">sp2gz_inv()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_decompose"><code class="docutils literal notranslate"><span class="pre">sp2gz_decompose()</span></code></a></li>
<li><a class="reference internal" href="#c.sp2gz_randtest"><code class="docutils literal notranslate"><span class="pre">sp2gz_randtest()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-siegel-half-space">The Siegel half space</a><ul>
<li><a class="reference internal" href="#c.acb_siegel_cocycle"><code class="docutils literal notranslate"><span class="pre">acb_siegel_cocycle()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_transform_cocycle_inv"><code class="docutils literal notranslate"><span class="pre">acb_siegel_transform_cocycle_inv()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_transform"><code class="docutils literal notranslate"><span class="pre">acb_siegel_transform()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_cho_yinv"><code class="docutils literal notranslate"><span class="pre">acb_siegel_cho_yinv()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_reduce"><code class="docutils literal notranslate"><span class="pre">acb_siegel_reduce()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_is_reduced"><code class="docutils literal notranslate"><span class="pre">acb_siegel_is_reduced()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_kappa"><code class="docutils literal notranslate"><span class="pre">acb_siegel_kappa()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_kappa2"><code class="docutils literal notranslate"><span class="pre">acb_siegel_kappa2()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest_reduced"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest_reduced()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest_compact"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest_compact()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest_vec"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest_vec()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_siegel_randtest_vec_reduced"><code class="docutils literal notranslate"><span class="pre">acb_siegel_randtest_vec_reduced()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#theta-characteristics">Theta characteristics</a><ul>
<li><a class="reference internal" href="#c.acb_theta_char_bit"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_bit()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_get_arb"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_get_arb()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_get_acb"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_get_acb()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_dot"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_dot()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_dot_slong"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_dot_slong()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_is_even"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_is_even()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_table"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_table()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_char_shuffle"><code class="docutils literal notranslate"><span class="pre">acb_theta_char_shuffle()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#toolbox-for-derivatives">Toolbox for derivatives</a><ul>
<li><a class="reference internal" href="#c.acb_theta_jet_nb"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_nb()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_total_order"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_total_order()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_tuples"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_tuples()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_index"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_index()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_mul"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_compose"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_compose()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_exp_pi_i"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_exp_pi_i()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_jet_exp_qf"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_exp_qf()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ellipsoids">Ellipsoids</a><ul>
<li><a class="reference internal" href="#c.acb_theta_eld_struct"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_struct</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_t"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_t</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_init"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_init()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_clear"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_set"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_set()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_nb_pts"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_nb_pts()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_points"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_points()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_box"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_box()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_nb_border"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_nb_border()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_border"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_border()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_contains"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_contains()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_print"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_print()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_eld_distances"><code class="docutils literal notranslate"><span class="pre">acb_theta_eld_distances()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#error-bounds-in-summation-algorithms">Error bounds in summation algorithms</a><ul>
<li><a class="reference internal" href="#c.acb_theta_sum_radius"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_radius()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_jet_radius"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_jet_radius()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_term"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_term()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_addprec"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_addprec()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-structures-in-summation-algorithms">Context structures in summation algorithms</a><ul>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_struct"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_struct</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_t"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_t</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_struct"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_struct</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_t"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_t</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_init"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_init()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_clear"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_init"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_init()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_clear"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_vec_init"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_vec_init()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_vec_clear"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_vec_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_exp_inv"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_exp_inv()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_sqr_inv"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_sqr_inv()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_set"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_set()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_dupl"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_dupl()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_tau_overlaps"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_tau_overlaps()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_set"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_set()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_dupl"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_dupl()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_add_real"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_add_real()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_common_v"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_common_v()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ctx_z_overlaps"><code class="docutils literal notranslate"><span class="pre">acb_theta_ctx_z_overlaps()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#summation-algorithms">Summation algorithms</a><ul>
<li><a class="reference internal" href="#c.acb_theta_sum_worker_t"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_worker_t</span></code></a><ul>
<li><a class="reference internal" href="#c.acb_theta_sum_worker_t.worker"><code class="docutils literal notranslate"><span class="pre">worker()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#c.acb_theta_sum_sqr_pow"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_sqr_pow()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_work"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_work()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_sum_jet"><code class="docutils literal notranslate"><span class="pre">acb_theta_sum_jet()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#agm-steps">AGM steps</a><ul>
<li><a class="reference internal" href="#c.acb_theta_agm_sqrt"><code class="docutils literal notranslate"><span class="pre">acb_theta_agm_sqrt()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_agm_mul"><code class="docutils literal notranslate"><span class="pre">acb_theta_agm_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_agm_mul_tight"><code class="docutils literal notranslate"><span class="pre">acb_theta_agm_mul_tight()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#quasilinear-algorithms-on-reduced-input">Quasilinear algorithms on reduced input</a><ul>
<li><a class="reference internal" href="#c.acb_theta_ql_nb_steps"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_nb_steps()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_lower_dim"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_lower_dim()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_recombine"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_recombine()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_setup"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_setup()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_exact"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_exact()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_local_bound"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_local_bound()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_jet_error"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_jet_error()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_jet_fd"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_jet_fd()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_ql_jet"><code class="docutils literal notranslate"><span class="pre">acb_theta_ql_jet()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#reduction-and-main-functions">Reduction and main functions</a><ul>
<li><a class="reference internal" href="#c.acb_theta_jet_notransform"><code class="docutils literal notranslate"><span class="pre">acb_theta_jet_notransform()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_reduce_tau"><code class="docutils literal notranslate"><span class="pre">acb_theta_reduce_tau()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_reduce_z"><code class="docutils literal notranslate"><span class="pre">acb_theta_reduce_z()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#dimension-2-specifics">Dimension 2 specifics</a><ul>
<li><a class="reference internal" href="#c.acb_theta_g2_detk_symj"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_detk_symj()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_transvectant"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_transvectant()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_character"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_character()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_even_weight"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_even_weight()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_chi5"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_chi5()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_chi35"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_chi35()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_chi3_6"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_chi3_6()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_sextic_chi5"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_sextic_chi5()</span></code></a></li>
<li><a class="reference internal" href="#c.acb_theta_g2_covariants"><code class="docutils literal notranslate"><span class="pre">acb_theta_g2_covariants()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#tests">Tests</a></li>
<li><a class="reference internal" href="#profiling">Profiling</a></li>
</ul>
</li>
</ul>

    </div>
  
</div>
          </div>
        </div>
      </div>

      <!-- ========================================================== -->
      <!-- Primary drawer after markup -->
      <!-- ========================================================== -->
    </div>

    <div class="drawer-side">
      <label
        for="primary-drawer"
        aria-label="Close primary sidebar"
        class="drawer-overlay"
      ></label>
      <div
        class="bg-base-100 text-base-content mt-[var(--header-height)] min-h-full w-80 overflow-y-auto p-4"
      >
        <!-- ===================================================== -->
        <!-- Primary drawer (mobile) content -->
        <!-- ===================================================== -->
        <div class="text-xs">


  <div class="global-toc">
    <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html"><strong>Building, testing and installing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="bug_reporting.html"><strong>Bug reporting</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing to FLINT</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html"><strong>Contributors</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html"><strong>Memory management</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="portability.html"><strong>Portability</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="threading.html"><strong>Threading</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flint.html"><strong>flint.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html"><strong>profiler.h</strong> – performance profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread_pool.html"><strong>thread_pool.h</strong> – thread pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpoly.html"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_vectors.html"><strong>machine_vectors.h</strong> – SIMD-accelerated operations on fixed-length vectors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generic rings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gr.html"><strong>gr.h</strong> – generic structures and their elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_implementing.html"><strong>gr.h (continued)</strong> – implementing rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_domains.html"><strong>gr.h (continued)</strong> – builtin domains and types</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_generic.html"><strong>gr_generic.h</strong> – basic algorithms and fallback implementations for generic elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_special.html"><strong>gr_special.h</strong> – special arithmetic and transcendental functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_vec.html"><strong>gr_vec.h</strong> – vectors over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mat.html"><strong>gr_mat.h</strong> – dense matrices over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_poly.html"><strong>gr_poly.h</strong> – dense univariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mpoly.html"><strong>gr_mpoly.h</strong> – sparse multivariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_series.html"><strong>gr_series.h</strong> – formal power series over generic rings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_generic.html"><strong>Generic rings</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ulong_extras.html"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz.html"><strong>fmpz.h</strong> – integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_vec.html"><strong>fmpz_vec.h</strong> – vectors of integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_factor.html"><strong>fmpz_factor.h</strong> – integer factorisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mat.html"><strong>fmpz_mat.h</strong> – matrices over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_lll.html"><strong>fmpz_lll.h</strong> – LLL reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly.html"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_mat.html"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_factor.html"><strong>fmpz_poly_factor.h</strong> – factorisation of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly.html"><strong>fmpz_mpoly.h</strong> – multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_factor.html"><strong>fmpz_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="long_extras.html"><strong>long_extras.h</strong> – support functions for signed word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="longlong.html"><strong>longlong.h</strong> – support functions for multi-word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_extras.html"><strong>mpn_extras.h</strong> – support functions for limb arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="aprcl.html"><strong>aprcl.h</strong> – APRCL primality testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arith.html"><strong>arith.h</strong> – arithmetic and special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft_small.html"><strong>fft_small.h</strong> – FFT modulo word-size primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="qsieve.html"><strong>qsieve.h</strong> – Quadratic sieve</a></li>
<li class="toctree-l1"><a class="reference internal" href="radix.html"><strong>radix.h</strong> – multiprecision arithmetic in general radix</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers.html"><strong>Integers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Rational numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fmpq.html"><strong>fmpq.h</strong> – rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_vec.html"><strong>fmpq_vec.h</strong> – vectors over rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mat.html"><strong>fmpq_mat.h</strong> – matrices over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_poly.html"><strong>fmpq_poly.h</strong> – univariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly_factor.html"><strong>fmpq_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly.html"><strong>fmpq_mpoly.h</strong> – multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_q.html"><strong>fmpz_poly_q.h</strong> – rational functions over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_q.html"><strong>fmpz_mpoly_q.h</strong> – multivariate rational functions over Q</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_rationals.html"><strong>Rational numbers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers mod n</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nmod.html"><strong>nmod.h</strong> – integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_vec.html"><strong>nmod_vec.h</strong> – vectors over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mat.html"><strong>nmod_mat.h</strong> – matrices over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly.html"><strong>nmod_poly.h</strong> – univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_mat.html"><strong>nmod_poly_mat.h</strong> – matrices of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_factor.html"><strong>nmod_poly_factor.h</strong> – factorisation of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly.html"><strong>nmod_mpoly.h</strong> – multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly_factor.html"><strong>nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_mod.html"><strong>mpn_mod.h</strong> – integers mod n (packed multi-word n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod.html"><strong>fmpz_mod.h</strong> – arithmetic modulo integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_vec.html"><strong>fmpz_mod_vec.h</strong> – vectors over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mat.html"><strong>fmpz_mod_mat.h</strong> – matrices over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly.html"><strong>fmpz_mod_poly.h</strong> – polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly_factor.html"><strong>fmpz_mod_poly_factor.h</strong> – factorisation of polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly.html"><strong>fmpz_mod_mpoly.h</strong> – polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_factor.html"><strong>fmpz_mod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_q.html"><strong>fmpz_mod_mpoly_q.h</strong> – multivariate rational functions over Z/mZ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers_mod.html"><strong>Integers mod n</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Groups and other structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="perm.html"><strong>perm.h</strong> – permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="qfb.html"><strong>qfb.h</strong> – binary quadratic forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dirichlet.html"><strong>dirichlet.h</strong> – Dirichlet characters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlog.html"><strong>dlog.h</strong> – discrete logarithms mod ulong primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="bool_mat.html"><strong>bool_mat.h</strong> – matrices over booleans</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Number fields and algebraic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nf.html"><strong>nf.h</strong> – number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="nf_elem.html"><strong>nf_elem.h</strong> – number field elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpzi.html"><strong>fmpzi.h</strong> – Gaussian integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qqbar.html"><strong>qqbar.h</strong> – algebraic numbers represented by minimal polynomials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real and complex numbers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Feature overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using ball arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Technical conventions and potential issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_arb.html">Arb example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="mag.html"><strong>mag.h</strong> – fixed-precision unsigned floating-point numbers for bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="nfloat.html"><strong>nfloat.h</strong> – packed floating-point numbers with n-word precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="arf.html"><strong>arf.h</strong> – arbitrary-precision floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acf.html"><strong>acf.h</strong> – complex floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb.html"><strong>arb.h</strong> – real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb.html"><strong>acb.h</strong> – complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_poly.html"><strong>arb_poly.h</strong> – polynomials over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_poly.html"><strong>acb_poly.h</strong> – polynomials over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fmpz_poly.html"><strong>arb_fmpz_poly.h</strong> – extra methods for integer polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dft.html"><strong>acb_dft.h</strong> – Discrete Fourier transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_mat.html"><strong>arb_mat.h</strong> – matrices over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_mat.html"><strong>acb_mat.h</strong> – matrices over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_hypgeom.html"><strong>acb_hypgeom.h</strong> – hypergeometric functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_hypgeom.html"><strong>arb_hypgeom.h</strong> – hypergeometric functions of real variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_elliptic.html"><strong>acb_elliptic.h</strong> – elliptic integrals and functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_modular.html"><strong>acb_modular.h</strong> – modular forms of complex variables</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>acb_theta.h</strong> – Riemann theta functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dirichlet.html"><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bernoulli.html"><strong>bernoulli.h</strong> – support for Bernoulli numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypgeom.html"><strong>hypgeom.h</strong> – support for hypergeometric series</a></li>
<li class="toctree-l1"><a class="reference internal" href="partitions.html"><strong>partitions.h</strong> – computation of the partition function</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_calc.html"><strong>arb_calc.h</strong> – calculus with real-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_calc.html"><strong>acb_calc.h</strong> – calculus with complex-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fpwrap.html"><strong>arb_fpwrap.h</strong> – floating-point wrappers of Arb mathematical functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_extras.html"><strong>fmpz_extras.h</strong> – extra methods for FLINT integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">General formulas and bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">Algorithms for mathematical constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma.html">Algorithms for the gamma function</a></li>
<li class="toctree-l1"><a class="reference internal" href="hurwitz.html">Algorithms for the Hurwitz zeta function</a></li>
<li class="toctree-l1"><a class="reference internal" href="polylogarithms.html">Algorithms for polylogarithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergeometric.html">Algorithms for hypergeometric functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="agm.html">Algorithms for the arithmetic-geometric mean</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index_arb.html"><strong>Real and complex numbers (Arb)</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_calcium.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_calcium.html">Calcium example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="calcium.html"><strong>calcium.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca.html"><strong>ca.h</strong> – exact real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_vec.html"><strong>ca_vec.h</strong> – vectors of real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_poly.html"><strong>ca_poly.h</strong> – dense univariate polynomials over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_mat.html"><strong>ca_mat.h</strong> – matrices over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_ext.html"><strong>ca_ext.h</strong> – real and complex extension numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_field.html"><strong>ca_field.h</strong> – extension fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr.html"><strong>fexpr.h</strong> – flat-packed symbolic expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr_builtin.html"><strong>fexpr_builtin.h</strong> – builtin symbols</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite fields</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq.html"><strong>fq.h</strong> – finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default.html"><strong>fq_default.h</strong> – unified finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_vec.html"><strong>fq_vec.h</strong> – vectors over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_mat.html"><strong>fq_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_mat.html"><strong>fq_default_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly.html"><strong>fq_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly.html"><strong>fq_default_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly_factor.html"><strong>fq_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly_factor.html"><strong>fq_default_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_embed.html"><strong>fq_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod.html"><strong>fq_nmod.h</strong> – finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_vec.html"><strong>fq_nmod_vec.h</strong> – vectors over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mat.html"><strong>fq_nmod_mat.h</strong> – matrices over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly.html"><strong>fq_nmod_poly.h</strong> – univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly_factor.html"><strong>fq_nmod_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_embed.html"><strong>fq_nmod_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly.html"><strong>fq_nmod_mpoly.h</strong> – multivariate polynomials over finite fields of word-sized characteristic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly_factor.html"><strong>fq_nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over finite fields of word-sized characteristic</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_zech.html"><strong>fq_zech.h</strong> – finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_vec.html"><strong>fq_zech_vec.h</strong> – vectors over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_mat.html"><strong>fq_zech_mat.h</strong> – matrices over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly.html"><strong>fq_zech_poly.h</strong> – univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly_factor.html"><strong>fq_zech_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_embed.html"><strong>fq_zech_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">p-adic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="padic.html"><strong>padic.h</strong> – p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_poly.html"><strong>padic_poly.h</strong> – polynomials over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_mat.html"><strong>padic_mat.h</strong> – matrices over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qadic.html"><strong>qadic.h</strong> – unramified extensions over p-adic numbers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Floating-point support code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="double_extras.html"><strong>double_extras.h</strong> – support functions for double arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="double_interval.html"><strong>double_interval.h</strong> – double-precision interval arithmetic and helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_vec.html"><strong>d_vec.h</strong> – double precision vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_mat.html"><strong>d_mat.h</strong> – double precision matrices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_flint.html"><strong>flint_ctypes</strong> - Python interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Version history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="history.html">History and changes</a></li>
</ul>

  </div>
</div>
      </div>
    </div>
  </div>


    
    <script
  defer
  src="_static/scripts/scroll-to-top.js"
></script>

<script>
  window.ScrollspyConfig = {
    rootMargin: "-120px 0px -60% 0px",
  };
</script>
<script defer src="_static/scripts/scrollspy.js"></script>
  <script src="_static/documentation_options.js?v=4cb41d1b"></script>
  <script src="_static/doctools.js?v=c73fddf3"></script>
  <script src="_static/sphinx_highlight.js?v=36527ec2"></script>
  <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    </body>
</html>