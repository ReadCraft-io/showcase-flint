
<!doctype html>
<html
  lang="en"
  data-content_root="./"
  class="scroll-smooth [--header-height:calc(var(--spacing)*18)] [--header-padding:calc(var(--spacing)*12)]"
  id="top"
  
>
  <head>
    <title>ulong_extras.h – arithmetic and number-theoretic functions for single-word integers &mdash; FLINT 3.5.0-dev documentation</title>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="generator"
  content="Sphinx 9.1.0, Clarity Theme for Sphinx 1.0.2 (https://readcraft.io/sphinx-clarity-theme/)"
/>


<meta name="viewport" content="width=device-width, initial-scale=1" />



<script src="_static/scripts/dark-mode.js"></script>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=a5519fdd" />
    <link rel="stylesheet" type="text/css" href="_static/styles/output.css?v=bbb64fb4" />
    <link rel="stylesheet" type="text/css" href="_static/styles/custom.css?v=76923282" />



    
    
  </head>

  <body >
    
  <!-- ============================================================== -->
  <!-- Primary drawer before markup -->
  <!-- ============================================================== -->
  <div class="drawer">
    <input id="primary-drawer" type="checkbox" class="drawer-toggle" />
    <div class="drawer-content">
      <!-- ========================================================== -->
      <!-- Secondary drawer before markup -->
      <!-- ========================================================== -->
      <div class="drawer drawer-end">
        <input id="secondary-drawer" type="checkbox" class="drawer-toggle" />
        <div class="drawer-content">
          <!-- ====================================================== -->
          <!-- Page content -->
          <!-- ====================================================== -->
          <div class="bg-base-100 divide-base-200 divide-y">
            


<!-- Header -->
<header id="main-header" class="bg-base-100 sticky top-0 z-50">
  <div
    class="container mx-auto flex h-[var(--header-height)] items-center px-4 md:px-0"
  >
    <!-- Left side (logo) -->
    <div class="flex-1">
<a href="index.html">
  
  
    <span class="text-primary-content text-xl font-bold">
      
      FLINT 3.5.0-dev documentation
    </span>
  
</a></div>

    <!-- Right side -->
    <div class="flex flex-1 items-center justify-end">
      <!-- #Header menu (desktop) -->
      <div class="hidden lg:block">
        <!-- `[&_li]:self-center` - If a content of <li> is the button, the "self-center" required to properly vertically align it -->
        <!-- `[&_li>a]:px-2 [&_li>a]:py-3` - Tweaks default menu ugly padding that doesn't match to buttons padding -->
        <ul
          class="menu menu-horizontal text-secondary-content gap-2 [&_li]:self-center [&_li>a]:px-2 [&_li>a]:py-3"
        >
          
        </ul>
      </div>
      <!-- .#Header menu (desktop) -->

      <!-- #Search button -->
      <div class="tooltip tooltip-bottom" data-tip="Search">
        <button
          class="btn btn-ghost btn-secondary"
          onclick="searchModal.showModal()"
        >
          <span class="icon-[prime--search] text-2xl"></span>
        </button>
      </div>
      <!-- .#Search button -->

      
  
  


      
  <!-- #Mode select -->
  <div class="tooltip tooltip-bottom" data-tip="Light/dark mode">
    <button class="btn btn-ghost btn-secondary">
      <label class="swap swap-rotate">
        <!-- this hidden checkbox controls the state -->
        <input type="checkbox" onclick="toggleMode()" />
        <!-- light mode icon -->
        <span class="icon-[prime--sun] swap-on text-2xl"></span>
        <!-- dark mode icon -->
        <span class="icon-[prime--moon] swap-off text-2xl"></span>
      </label>
    </button>
  </div>
  <!-- .#Mode select -->


      <!-- #Header menu (mobile) -->
      <details class="dropdown dropdown-left lg:hidden">
        <summary class="btn btn-secondary aspect-square" aria-label="Menu">
          <span class="icon-[prime--bars]"></span>
          <span class="sr-only">Menu</span>
        </summary>
        <!-- `[&_li>a.btn]:justify-start` - If a content of <li> is the button, it should be aligned to the start (left) -->
        <ul
          class="menu dropdown-content bg-base-100 rounded-box dark:border-base-200 z-1 w-52 p-2 shadow-sm dark:border [&_li>a.btn]:justify-start"
        >
          
        </ul>
      </details>
      <!-- .#Header menu (mobile) -->
    </div>
  </div>
</header>
            
<!-- #Sidebar toggles (mobile) -->
<nav class="p-4 lg:hidden">
  <div class="container mx-auto flex items-center justify-between text-sm">
    <!-- Left side -->
    <div>
      
        <button
          class="btn btn-secondary btn-sm text-secondary-content/80 font-normal"
        >
          <label
            for="primary-drawer"
            class="flex cursor-pointer items-center gap-1"
          >
            <span class="icon-[prime--align-left] text-xl"></span>
            Table of Contents
          </label>
        </button>
      
    </div>
    <!-- .Left side -->
    <!-- Right side -->
    <div>
      
        <button
          class="btn btn-secondary btn-sm text-secondary-content/80 font-normal"
        >
          <label
            for="secondary-drawer"
            class="flex cursor-pointer items-center gap-1"
          >
            This page
            <span class="icon-[prime--align-right] text-xl"></span>
          </label>
        </button>
      
    </div>
    <!-- .Right side -->
  </div>
</nav>
<!-- .#Sidebar toggles (mobile) -->

            <main class="p-4 lg:pt-[var(--header-padding)]">
              <div class="container mx-auto lg:flex lg:items-start">
                <article class="lg:order-2 lg:w-8/12 lg:flex-none lg:px-12">
                  
<!-- #Breadcrumb -->
<nav class="flex flex-wrap items-center gap-1 text-sm">
  
  <a
    href="index.html"
    class="text-secondary-content/80 hover:text-accent-content hover:underline"
  >
    FLINT 3.5.0-dev documentation
  </a>

  

  
  <span
    class="icon-[prime--arrow-right] text-secondary-content/50"
  ></span>
  <span class="text-secondary-content/80"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</span>
</nav>
<!-- .#Breadcrumb -->

                  
                  <main role="main">
  <section id="ulong-extras-h-arithmetic-and-number-theoretic-functions-for-single-word-integers">
<span id="ulong-extras"></span><h1><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers<a class="headerlink" href="#ulong-extras-h-arithmetic-and-number-theoretic-functions-for-single-word-integers" title="Link to this heading">¶</a></h1>
<p>This module implements functions for single limb unsigned integers,
including arithmetic with a precomputed inverse and modular
arithmetic.</p>
<p>The module includes functions for square roots, factorisation and
primality testing. Almost all the functions in this module are highly
developed and extremely well optimised.</p>
<p>The basic type is the <code class="docutils literal notranslate"><span class="pre">ulong</span></code> as defined by GMP. Functions
which take a precomputed inverse either have the suffix <code class="docutils literal notranslate"><span class="pre">preinv</span></code> and
take an <code class="docutils literal notranslate"><span class="pre">ulong</span></code> precomputed inverse as computed by
<code class="docutils literal notranslate"><span class="pre">n_preinvert_limb</span></code> or have the suffix <code class="docutils literal notranslate"><span class="pre">_precomp</span></code> and accept a
<code class="docutils literal notranslate"><span class="pre">double</span></code> precomputed inverse as computed by
<code class="docutils literal notranslate"><span class="pre">n_precompute_inverse</span></code>.</p>
<p>Sometimes three functions with similar names are provided for the same
task, e.g. <code class="docutils literal notranslate"><span class="pre">n_mod_precomp</span></code>, <code class="docutils literal notranslate"><span class="pre">n_mod2_precomp</span></code> and
<code class="docutils literal notranslate"><span class="pre">n_mod2_preinv</span></code>. If the part of the name that designates the
functionality ends in 2 then the function has few if any limitations
on its inputs. Otherwise the function may have limitations such as
being limited to 52 or 53 bits. In practice we found that the preinv
functions are generally faster anyway, so most times it pays to just
use the <code class="docutils literal notranslate"><span class="pre">n_blah2_preinv</span></code> variants.</p>
<p>Some functions with the <code class="docutils literal notranslate"><span class="pre">n_ll_</span></code> or <code class="docutils literal notranslate"><span class="pre">n_lll_</span></code> prefix accept
parameters of two or three limbs respectively.</p>
<section id="simple-example">
<h2>Simple example<a class="headerlink" href="#simple-example" title="Link to this heading">¶</a></h2>
<p>The following example computes <span class="math notranslate nohighlight">\(ab \pmod{n}\)</span> using a precomputed
inverse, where <span class="math notranslate nohighlight">\(a = 12345678, b = 87654321\)</span> and <span class="math notranslate nohighlight">\(n = 111111111\)</span>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ulong_extras.h&quot;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ulong</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ninv</span><span class="p">;</span>

<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UWORD</span><span class="p">(</span><span class="mi">12345678</span><span class="p">);</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UWORD</span><span class="p">(</span><span class="mi">87654321</span><span class="p">);</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UWORD</span><span class="p">(</span><span class="mi">111111111</span><span class="p">);</span>
<span class="w">    </span><span class="n">ninv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_preinvert_limb</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_mulmod2_preinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ninv</span><span class="p">);</span>

<span class="w">    </span><span class="n">flint_printf</span><span class="p">(</span><span class="s">&quot;%wu*%wu mod %wu is %wu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="mi">12345678</span><span class="o">*</span><span class="mi">87654321</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="mi">111111111</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">23456790</span>
</pre></div>
</div>
</section>
<section id="random-functions">
<h2>Random functions<a class="headerlink" href="#random-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_randlimb">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randlimb</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randlimb" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c._n_randlimb">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_n_randlimb</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._n_randlimb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random limb.</p>
<p>The algorithm generates two random half limbs <span class="math notranslate nohighlight">\(s_j\)</span>, <span class="math notranslate nohighlight">\(j = 0, 1\)</span>,
by iterating respectively <span class="math notranslate nohighlight">\(v_{i+1} = (v_i a + b) \bmod{p_j}\)</span> for
some initial seed <span class="math notranslate nohighlight">\(v_0\)</span>, randomly chosen values <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> and
<code class="docutils literal notranslate"><span class="pre">p_0</span> <span class="pre">=</span> <span class="pre">4294967311</span> <span class="pre">=</span> <span class="pre">nextprime(2^32)</span></code> on a 64-bit machine
and <code class="docutils literal notranslate"><span class="pre">p_0</span> <span class="pre">=</span> <span class="pre">nextprime(2^16)</span></code> on a 32-bit machine and
<code class="docutils literal notranslate"><span class="pre">p_1</span> <span class="pre">=</span> <span class="pre">nextprime(p_0)</span></code>.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">_n_randlimb</span></code> is defined inline, which can allow for
better performance when generating many random numbers.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randbits">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randbits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randbits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random number with the given number of
bits. The most significant bit is always set, unless zero is passed,
in which case zero is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randtest_bits">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randtest_bits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randtest_bits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random number with the given number of
bits. The most significant bit is always set, unless zero is passed,
in which case zero is returned. The probability of a value with a
sparse binary representation being returned is increased. This
function is intended for use in test code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randint">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randint</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randint" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.n_urandint">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_urandint</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_urandint" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c._n_randint">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_n_randint</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._n_randint" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random number up to but not including
the given limit. If zero is passed as a parameter, an entire random
limb is returned.</p>
<p>The functions <code class="docutils literal notranslate"><span class="pre">n_randint</span></code> and <code class="docutils literal notranslate"><span class="pre">n_urandint</span></code> are identical.
The function <code class="docutils literal notranslate"><span class="pre">_n_randint</span></code> is defined inline, which can allow for
better performance when generating many random numbers.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randtest">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randtest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pseudo random number with a random number of bits,
from <span class="math notranslate nohighlight">\(0\)</span> to <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>.  The probability of the special
values <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span>, <code class="docutils literal notranslate"><span class="pre">COEFF_MAX</span></code> and <code class="docutils literal notranslate"><span class="pre">WORD_MAX</span></code> is increased
as is the probability of a value with sparse binary representation.
This random function is mainly used for testing purposes.
This function is intended for use in test code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randtest_not_zero">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randtest_not_zero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randtest_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <a class="reference internal" href="#c.n_randtest" title="n_randtest"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_randtest()</span></code></a>, but does not return <span class="math notranslate nohighlight">\(0\)</span>.
This function is intended for use in test code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randprime">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randprime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a random prime number <code class="docutils literal notranslate"><span class="pre">(proved</span> <span class="pre">=</span> <span class="pre">1)</span></code> or probable prime
<code class="docutils literal notranslate"><span class="pre">(proved</span> <span class="pre">=</span> <span class="pre">0)</span></code>
with <code class="docutils literal notranslate"><span class="pre">bits</span></code> bits, where <code class="docutils literal notranslate"><span class="pre">bits</span></code> must be at least 2 and
at most <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randtest_prime">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randtest_prime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randtest_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a random prime number <code class="docutils literal notranslate"><span class="pre">(proved</span> <span class="pre">=</span> <span class="pre">1)</span></code> or probable
prime <code class="docutils literal notranslate"><span class="pre">(proved</span> <span class="pre">=</span> <span class="pre">0)</span></code>
with size randomly chosen between 2 and <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code> bits.
This function is intended for use in test code.</p>
</dd></dl>

</section>
<section id="basic-arithmetic">
<h2>Basic arithmetic<a class="headerlink" href="#basic-arithmetic" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_pow">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_pow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_pow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">n^exp</span></code>. No checking is done for overflow. The exponent
may be zero. We define <span class="math notranslate nohighlight">\(0^0 = 1\)</span>.</p>
<p>The algorithm simply uses a for loop. Repeated squaring is
unlikely to speed up this algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_flog">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_flog</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_flog" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\lfloor\log_b n\rfloor\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(n \geq 1\)</span> and <span class="math notranslate nohighlight">\(b \geq 2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_clog">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_clog</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_clog" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\lceil\log_b n\rceil\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(n \geq 1\)</span> and <span class="math notranslate nohighlight">\(b \geq 2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_clog_2exp">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_clog_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_clog_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\lceil\log_b 2^n\rceil\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(b \geq 2\)</span>.</p>
</dd></dl>

</section>
<section id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_revbin">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_revbin</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_revbin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the binary reverse of <span class="math notranslate nohighlight">\(n\)</span>, assuming it is <span class="math notranslate nohighlight">\(b\)</span> bits in length,
e.g. <code class="docutils literal notranslate"><span class="pre">n_revbin(10110,</span> <span class="pre">6)</span></code> will return <code class="docutils literal notranslate"><span class="pre">110100</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sizeinbase">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sizeinbase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sizeinbase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the exact number of digits needed to represent <span class="math notranslate nohighlight">\(n\)</span> as a
string in base <code class="docutils literal notranslate"><span class="pre">base</span></code> assumed to be between 2 and 36.
Returns 1 when <span class="math notranslate nohighlight">\(n = 0\)</span>.</p>
</dd></dl>

</section>
<section id="basic-arithmetic-with-precomputed-inverses">
<h2>Basic arithmetic with precomputed inverses<a class="headerlink" href="#basic-arithmetic-with-precomputed-inverses" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_preinvert_limb_prenorm">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_preinvert_limb_prenorm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_preinvert_limb_prenorm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an approximate inverse <code class="docutils literal notranslate"><span class="pre">invxl</span></code> of the limb <code class="docutils literal notranslate"><span class="pre">xl</span></code>,
with an implicit leading~`1`. More formally it computes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">invxl</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="n">B</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="n">B</span>
</pre></div>
</div>
<p>Note that <span class="math notranslate nohighlight">\(x\)</span> must be normalised, i.e. with msb set. This inverse
makes use of Lemma 8.1 in <a class="reference internal" href="references.html#gramon1994" id="id1"><span>[GraMon1994]</span></a>:</p>
<p>Let <span class="math notranslate nohighlight">\(d\)</span> be normalised, <span class="math notranslate nohighlight">\(d &lt; B\)</span>, i.e. it fits in a word, and suppose
that <span class="math notranslate nohighlight">\(m d &lt; B^2 \leq (m+1) d\)</span>. Let <span class="math notranslate nohighlight">\(0 \leq n \leq B d - 1\)</span>.  Write
<span class="math notranslate nohighlight">\(n = n_2 B + n_1 B/2 + n_0\)</span> with <span class="math notranslate nohighlight">\(n_1 = 0\)</span> or <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(n_0 &lt; B/2\)</span>.
Suppose <span class="math notranslate nohighlight">\(q_1 B + q_0 = n_2 B + (n_2 + n_1) (m - B) + n_1 (d-B/2) + n_0\)</span>
and <span class="math notranslate nohighlight">\(0 \leq q_0 &lt; B\)</span>. Then <span class="math notranslate nohighlight">\(0 \leq q_1 &lt; B\)</span> and <span class="math notranslate nohighlight">\(0 \leq n - q_1 d &lt; 2 d\)</span>.</p>
<p>In the theorem, <span class="math notranslate nohighlight">\(m\)</span> is the inverse of <span class="math notranslate nohighlight">\(d\)</span>. If we let
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">invxl</span> <span class="pre">+</span> <span class="pre">B</span></code> and <span class="math notranslate nohighlight">\(d = x\)</span> we have <span class="math notranslate nohighlight">\(m d = B^2 - 1 &lt; B^2\)</span> and
<span class="math notranslate nohighlight">\((m+1) x = B^2 + d - 1 \geq B^2\)</span>.</p>
<p>The theorem is often applied as follows: note that <span class="math notranslate nohighlight">\(n_0\)</span> and <span class="math notranslate nohighlight">\(n_1 (d-B/2)\)</span>
are both less than <span class="math notranslate nohighlight">\(B/2\)</span>. Also note that <span class="math notranslate nohighlight">\(n_1 (m-B) &lt; B\)</span>. Thus the sum of
all these terms contributes at most <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(q_1\)</span>. We are left with
<span class="math notranslate nohighlight">\(n_2 B + n_2 (m-B)\)</span>. But note that <span class="math notranslate nohighlight">\((m-B)\)</span> is precisely our precomputed
inverse <code class="docutils literal notranslate"><span class="pre">invxl</span></code>. If we write <span class="math notranslate nohighlight">\(q_1 B + q_0 = n_2 B + n_2 (m-B)\)</span>,
then from the theorem, we have <span class="math notranslate nohighlight">\(0 \leq n - q_1 d &lt; 3 d\)</span>, i.e. the
quotient is out by at most <span class="math notranslate nohighlight">\(2\)</span> and is always either correct or too small.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_preinvert_limb">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_preinvert_limb</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_preinvert_limb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>, as defined in <a class="reference internal" href="references.html#gramol2010" id="id2"><span>[GraMol2010]</span></a>.
This precomputed inverse can be used with all of the functions that
take a precomputed inverse whose names are suffixed by <code class="docutils literal notranslate"><span class="pre">_preinv</span></code>.</p>
<p>We require <span class="math notranslate nohighlight">\(n &gt; 0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_precompute_inverse">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_precompute_inverse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_precompute_inverse" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> with double precision value <span class="math notranslate nohighlight">\(1/n\)</span>.
This precomputed inverse can be used with all of the functions that
take a precomputed inverse whose names are suffixed by <code class="docutils literal notranslate"><span class="pre">_precomp</span></code>.</p>
<p>We require <span class="math notranslate nohighlight">\(n &gt; 0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mod_precomp">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mod_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mod_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed
by <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. We require <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">2^FLINT_D_BITS</span></code>
and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">2^(FLINT_BITS-1)</span></code> and <span class="math notranslate nohighlight">\(0 \leq a &lt; n^2\)</span>.</p>
<p>We assume the processor is in the standard round to nearest
mode. Thus <code class="docutils literal notranslate"><span class="pre">ninv</span></code> is correct to <span class="math notranslate nohighlight">\(53\)</span> binary bits, the least
significant bit of which we shall call a place, and can be at most
half a place out. When <span class="math notranslate nohighlight">\(a\)</span> is multiplied by <span class="math notranslate nohighlight">\(ninv\)</span>, the binary
representation of <span class="math notranslate nohighlight">\(a\)</span> is exact and the mantissa is less than <span class="math notranslate nohighlight">\(2\)</span>, thus we
see that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">ninv</span></code> can be at most one out in the mantissa. We now
truncate <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">ninv</span></code> to the nearest integer, which is always a round
down. Either we already have an integer, or we need to make a change down
of at least <span class="math notranslate nohighlight">\(1\)</span> in the last place. In the latter case we either get
precisely the exact quotient or below it as when we rounded the
product to the nearest place we changed by at most half a place.
In the case that truncating to an integer takes us below the
exact quotient, we have rounded down by less than <span class="math notranslate nohighlight">\(1\)</span> plus half a
place. But as the product is less than <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(n\)</span> is less than <span class="math notranslate nohighlight">\(2^{53}\)</span>,
half a place is less than <span class="math notranslate nohighlight">\(1\)</span>, thus we are out by less than <span class="math notranslate nohighlight">\(2\)</span> from
the exact quotient, i.e. the quotient we have computed is the
quotient we are after or one too small. That leaves only the case
where we had to round up to the nearest place which happened to
be an integer, so that truncating to an integer didn’t change
anything. But this implies that the exact quotient <span class="math notranslate nohighlight">\(a/n\)</span> is less
than <span class="math notranslate nohighlight">\(2^{-54}\)</span> from an integer. We deal with this rare case by
subtracting 1 from the quotient. Then the quotient we have computed is
either exactly what we are after, or one too small.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mod2_precomp">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mod2_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mod2_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span> or
on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>As for <a class="reference internal" href="#c.n_mod_precomp" title="n_mod_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mod_precomp()</span></code></a> for <span class="math notranslate nohighlight">\(n &lt; 2^{53}\)</span> and <span class="math notranslate nohighlight">\(a &lt; n^2\)</span> the
computed quotient is either what we are after or one too large or small.
We deal with these cases. Otherwise we can be sure that the
top <span class="math notranslate nohighlight">\(52\)</span> bits of the quotient are computed correctly. We take
the remainder and adjust the quotient by multiplying the
remainder by <code class="docutils literal notranslate"><span class="pre">ninv</span></code> to compute another approximate quotient as
per <code class="xref c c-func docutils literal notranslate"><span class="pre">mod_precomp()</span></code>. Now the remainder may be either
negative or positive, so the quotient we compute may be one
out in either direction.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_divrem2_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divrem2_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divrem2_preinv" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.n_divrem_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divrem_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">norm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divrem_preinv" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.n_divrem_preinv_unnorm">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divrem_preinv_unnorm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">norm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divrem_preinv_unnorm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> and sets <span class="math notranslate nohighlight">\(q\)</span> to the quotient of <span class="math notranslate nohighlight">\(a\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, given a
precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are
no restrictions on <span class="math notranslate nohighlight">\(a\)</span> and the only restriction on <span class="math notranslate nohighlight">\(n\)</span> is that it be
nonzero.</p>
<p>This uses the algorithm of Granlund and Möller <a class="reference internal" href="references.html#gramol2010" id="id3"><span>[GraMol2010]</span></a>. First
<span class="math notranslate nohighlight">\(n\)</span> is normalised and <span class="math notranslate nohighlight">\(a\)</span> is shifted into two limbs to compensate. Then
their algorithm is applied verbatim and the remainder shifted back.</p>
<p>The difference between the legacy <a class="reference internal" href="#c.n_divrem2_preinv" title="n_divrem2_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_divrem2_preinv()</span></code></a> and
<a class="reference internal" href="#c.n_divrem_preinv" title="n_divrem_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_divrem_preinv()</span></code></a> is that the latter accepts the <code class="docutils literal notranslate"><span class="pre">norm</span></code>
parameter specifying the number of leading zero bits of <code class="docutils literal notranslate"><span class="pre">n</span></code> as input
and hence avoids computing this on the fly.
The version <a class="reference internal" href="#c.n_divrem_preinv_unnorm" title="n_divrem_preinv_unnorm"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_divrem_preinv_unnorm()</span></code></a> requires positive <code class="docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_divrem_norm">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divrem_norm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divrem_norm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> and sets <span class="math notranslate nohighlight">\(q\)</span> to the quotient of <span class="math notranslate nohighlight">\(a\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, assuming
that <span class="math notranslate nohighlight">\(n\)</span> is normalised. This is a trivial operation as the quotient
is either 0 or 1.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_div2_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_div2_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_div2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the Euclidean quotient of <span class="math notranslate nohighlight">\(a\)</span> by <span class="math notranslate nohighlight">\(n\)</span> given a precomputed inverse of
<span class="math notranslate nohighlight">\(n\)</span> computed by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span>
and the only restriction on <span class="math notranslate nohighlight">\(n\)</span> is that it be nonzero.</p>
<p>This uses the algorithm of Granlund and Möller <a class="reference internal" href="references.html#gramol2010" id="id4"><span>[GraMol2010]</span></a>. First
<span class="math notranslate nohighlight">\(n\)</span> is normalised and <span class="math notranslate nohighlight">\(a\)</span> is shifted into two limbs to compensate. Then
their algorithm is applied verbatim.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mod2_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mod2_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span> and the only
restriction on <span class="math notranslate nohighlight">\(n\)</span> is that it be nonzero.</p>
<p>This uses the algorithm of Granlund and Möller <a class="reference internal" href="references.html#gramol2010" id="id5"><span>[GraMol2010]</span></a>. First
<span class="math notranslate nohighlight">\(n\)</span> is normalised and <span class="math notranslate nohighlight">\(a\)</span> is shifted into two limbs to compensate. Then
their algorithm is applied verbatim and the result shifted back.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_divrem2_precomp">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divrem2_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">npre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divrem2_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a> and sets <span class="math notranslate nohighlight">\(q\)</span> to the quotient. There
are no restrictions on <span class="math notranslate nohighlight">\(a\)</span> or on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>This is as for <a class="reference internal" href="#c.n_mod2_precomp" title="n_mod2_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mod2_precomp()</span></code></a> with some additional care taken
to retain the quotient information. There are also special
cases to deal with the case where <span class="math notranslate nohighlight">\(a\)</span> is already reduced modulo
<span class="math notranslate nohighlight">\(n\)</span> and where <span class="math notranslate nohighlight">\(n\)</span> is <span class="math notranslate nohighlight">\(64\)</span> bits and <span class="math notranslate nohighlight">\(a\)</span> is not reduced modulo <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_ll_mod_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_ll_mod_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_hi</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_lo</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_ll_mod_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span>, which
will be two limbs <code class="docutils literal notranslate"><span class="pre">(a_hi,</span> <span class="pre">a_lo)</span></code>, or on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>The old version of this function merely reduced the top limb
<code class="docutils literal notranslate"><span class="pre">a_hi</span></code> modulo <span class="math notranslate nohighlight">\(n\)</span> so that <a class="reference internal" href="longlong.html#c.udiv_qrnnd_preinv" title="udiv_qrnnd_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">udiv_qrnnd_preinv()</span></code></a> could
be used.</p>
<p>The new version reduces the top limb modulo <span class="math notranslate nohighlight">\(n\)</span> as per
<a class="reference internal" href="#c.n_mod2_preinv" title="n_mod2_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mod2_preinv()</span></code></a> and then the algorithm of Granlund and
Möller <a class="reference internal" href="references.html#gramol2010" id="id6"><span>[GraMol2010]</span></a> is used again to reduce modulo <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_lll_mod_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_lll_mod_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_hi</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_mi</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_lo</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_lll_mod_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span>, where <span class="math notranslate nohighlight">\(a\)</span> has three limbs <code class="docutils literal notranslate"><span class="pre">(a_hi,</span> <span class="pre">a_mi,</span> <span class="pre">a_lo)</span></code>,
given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>.
It is assumed that <code class="docutils literal notranslate"><span class="pre">a_hi</span></code> is reduced modulo <span class="math notranslate nohighlight">\(n\)</span>. There are no
restrictions on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>This function uses the algorithm of Granlund and
Möller <a class="reference internal" href="references.html#gramol2010" id="id7"><span>[GraMol2010]</span></a> to first reduce the top two limbs
modulo <span class="math notranslate nohighlight">\(n\)</span>, then does the same on the bottom two limbs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_precomp">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>
computed by <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. We require
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">2^FLINT_D_BITS</span></code> and <span class="math notranslate nohighlight">\(0 \leq a, b &lt; n\)</span>.</p>
<p>We assume the processor is in the standard round to nearest
mode. Thus <code class="docutils literal notranslate"><span class="pre">ninv</span></code> is correct to <span class="math notranslate nohighlight">\(53\)</span> binary bits, the least
significant bit of which we shall call a place, and can be at most half
a place out. The product of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> is computed with error at most
half a place. When <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> is multiplied by <span class="math notranslate nohighlight">\(ninv\)</span> we find that the
exact quotient and computed quotient differ by less than two places. As
the quotient is less than <span class="math notranslate nohighlight">\(n\)</span> this means that the exact quotient is at
most <span class="math notranslate nohighlight">\(1\)</span> away from the computed quotient. We truncate this quotient to
an integer which reduces the value by less than <span class="math notranslate nohighlight">\(1\)</span>. We end up with a
value which can be no more than two above the quotient we are after and
no less than two below. However an argument similar to that for
<a class="reference internal" href="#c.n_mod_precomp" title="n_mod_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mod_precomp()</span></code></a> shows that the truncated computed quotient cannot
be two smaller than the truncated exact quotient. In other words the
computed integer quotient is at most two above and one below the quotient
we are after.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod2_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod2_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> or
on <span class="math notranslate nohighlight">\(n\)</span>. This is implemented by multiplying using <a class="reference internal" href="longlong.html#c.umul_ppmm" title="umul_ppmm"><code class="xref c c-func docutils literal notranslate"><span class="pre">umul_ppmm()</span></code></a> and
then reducing using <a class="reference internal" href="#c.n_ll_mod_preinv" title="n_ll_mod_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_ll_mod_preinv()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod2">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \bmod{n}\)</span>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> or
on <span class="math notranslate nohighlight">\(n\)</span>. This is implemented by multiplying using <a class="reference internal" href="longlong.html#c.umul_ppmm" title="umul_ppmm"><code class="xref c c-func docutils literal notranslate"><span class="pre">umul_ppmm()</span></code></a> and
then reducing using <a class="reference internal" href="#c.n_ll_mod_preinv" title="n_ll_mod_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_ll_mod_preinv()</span></code></a> after computing a precomputed
inverse.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">norm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \pmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>, assuming <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are reduced modulo <span class="math notranslate nohighlight">\(n\)</span>
and <span class="math notranslate nohighlight">\(n\)</span> is normalised, i.e. with most significant bit set. There are
no other restrictions on <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> or <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>The value <code class="docutils literal notranslate"><span class="pre">norm</span></code> is provided for convenience. As <span class="math notranslate nohighlight">\(n\)</span> is required
to be normalised, it may be that <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have been shifted to the
left by <code class="docutils literal notranslate"><span class="pre">norm</span></code> bits before calling the function. Their product
then has an extra factor of <span class="math notranslate nohighlight">\(2^\text{norm}\)</span>. Specifying a nonzero
<code class="docutils literal notranslate"><span class="pre">norm</span></code> will shift the product right by this many bits before
reducing it.</p>
<p>The algorithm used is that of Granlund and Möller <a class="reference internal" href="references.html#gramol2010" id="id8"><span>[GraMol2010]</span></a>.</p>
</dd></dl>

</section>
<section id="greatest-common-divisor">
<h2>Greatest common divisor<a class="headerlink" href="#greatest-common-divisor" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_gcd">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_gcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_gcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the greatest common divisor <span class="math notranslate nohighlight">\(g\)</span> of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. No assumptions
are made about the values <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>This function wraps GMP’s <code class="docutils literal notranslate"><span class="pre">mpn_gcd_1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_gcdinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_gcdinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_gcdinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the greatest common divisor <span class="math notranslate nohighlight">\(g\)</span> of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> and computes
<span class="math notranslate nohighlight">\(a\)</span> such that <span class="math notranslate nohighlight">\(0 \leq a &lt; y\)</span> and <span class="math notranslate nohighlight">\(a x = \gcd(x, y) \bmod{y}\)</span>, when
this is defined. We require <span class="math notranslate nohighlight">\(x &lt; y\)</span>.</p>
<p>When <span class="math notranslate nohighlight">\(y = 1\)</span> the greatest common divisor is set to <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(a\)</span> is
set to <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>This is merely an adaption of the extended Euclidean algorithm
computing just one cofactor and reducing it modulo <span class="math notranslate nohighlight">\(y\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_xgcd">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_xgcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_xgcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the greatest common divisor <span class="math notranslate nohighlight">\(g\)</span> of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> and unsigned
values <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> such that <span class="math notranslate nohighlight">\(a x - b y = g\)</span>. We require <span class="math notranslate nohighlight">\(x \geq y\)</span>.</p>
<p>We claim that computing the extended greatest common divisor via the
Euclidean algorithm always results in cofactor <span class="math notranslate nohighlight">\(\lvert a \rvert &lt; x/2\)</span>,
<span class="math notranslate nohighlight">\(\lvert b\rvert &lt; x/2\)</span>, with perhaps some small degenerate exceptions.</p>
<p>We proceed by induction.</p>
<p>Suppose we are at some step of the algorithm, with <span class="math notranslate nohighlight">\(x_n = q y_n + r\)</span>
with <span class="math notranslate nohighlight">\(r \geq 1\)</span>, and suppose <span class="math notranslate nohighlight">\(1 = s y_n - t r\)</span> with
<span class="math notranslate nohighlight">\(s &lt; y_n / 2\)</span>, <span class="math notranslate nohighlight">\(t &lt; y_n / 2\)</span> by hypothesis.</p>
<p>Write <span class="math notranslate nohighlight">\(1 = s y_n - t (x_n - q y_n) = (s + t q) y_n - t x_n\)</span>.</p>
<p>It suffices to show that <span class="math notranslate nohighlight">\((s + t q) &lt; x_n / 2\)</span> as <span class="math notranslate nohighlight">\(t &lt; y_n / 2 &lt; x_n / 2\)</span>,
which will complete the induction step.</p>
<p>But at the previous step in the backsubstitution we would have had
<span class="math notranslate nohighlight">\(1 = s r - c d\)</span> with <span class="math notranslate nohighlight">\(s &lt; r/2\)</span> and <span class="math notranslate nohighlight">\(c &lt; r/2\)</span>.</p>
<p>Then <span class="math notranslate nohighlight">\(s + t q &lt; r/2 + y_n / 2 q = (r + q y_n)/2 = x_n / 2\)</span>.</p>
<p>See the documentation of <a class="reference internal" href="#c.n_gcd" title="n_gcd"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_gcd()</span></code></a> for a description of the
branching in the algorithm, which is faster than using division.</p>
</dd></dl>

</section>
<section id="jacobi-and-kronecker-symbols">
<h2>Jacobi and Kronecker symbols<a class="headerlink" href="#jacobi-and-kronecker-symbols" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_jacobi">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_jacobi</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_jacobi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Jacobi symbol <span class="math notranslate nohighlight">\(\left(\frac{x}{y}\right)\)</span> for any <span class="math notranslate nohighlight">\(x\)</span> and odd <span class="math notranslate nohighlight">\(y\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_jacobi_unsigned">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_jacobi_unsigned</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_jacobi_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Jacobi symbol, allowing <span class="math notranslate nohighlight">\(x\)</span> to go up to a full limb.</p>
</dd></dl>

</section>
<section id="modular-arithmetic">
<h2>Modular arithmetic<a class="headerlink" href="#modular-arithmetic" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_addmod">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_addmod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_addmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\((a + b) \bmod{n}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_submod">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_submod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_submod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\((a - b) \bmod{n}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_invmod">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_invmod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_invmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the inverse of <span class="math notranslate nohighlight">\(x\)</span> modulo <span class="math notranslate nohighlight">\(y\)</span>, if it exists. Otherwise an exception
is thrown.</p>
<p>This is merely an adaption of the extended Euclidean algorithm
with appropriate normalisation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_binvert">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_binvert</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_binvert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <span class="math notranslate nohighlight">\(n\)</span> is odd, returns the multiplicative inverse modulo
<span class="math notranslate nohighlight">\(2^{\mathtt{FLINT\_BITS}}\)</span>. If <span class="math notranslate nohighlight">\(n\)</span> is even, some arbitrary
value is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod_precomp">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">npre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">a^exp</span></code> modulo <span class="math notranslate nohighlight">\(n\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>
computed by <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. We require <span class="math notranslate nohighlight">\(n &lt; 2^{53}\)</span>
and <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>. There are no restrictions on <code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e.
it can be negative.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod_ui_precomp">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod_ui_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">npre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod_ui_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">a^exp</span></code> modulo <span class="math notranslate nohighlight">\(n\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>
computed by <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. We require <span class="math notranslate nohighlight">\(n &lt; 2^{53}\)</span>
and <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>. The exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> is unsigned and so
can be larger than allowed by <a class="reference internal" href="#c.n_powmod_precomp" title="n_powmod_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_powmod_precomp()</span></code></a>.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">a^exp</span></code> modulo <span class="math notranslate nohighlight">\(n\)</span>. We require <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">2^FLINT_D_BITS</span></code>
and <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>. There are no restrictions on <code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e.
it can be negative.</p>
<p>This is implemented by precomputing an inverse and calling the
<code class="docutils literal notranslate"><span class="pre">precomp</span></code> version of this function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod2_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod2_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">(a^exp)</span> <span class="pre">%</span> <span class="pre">n</span></code> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. We require <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>, but there are no
restrictions on <span class="math notranslate nohighlight">\(n\)</span> or on <code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e. it can be negative.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exp</span></code> is negative but <span class="math notranslate nohighlight">\(a\)</span> is not invertible modulo <span class="math notranslate nohighlight">\(n\)</span>, an
exception is raised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod2">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">(a^exp)</span> <span class="pre">%</span> <span class="pre">n</span></code>. We require <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>, but there are
no restrictions on <span class="math notranslate nohighlight">\(n\)</span> or on <code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e. it can be negative.</p>
<p>This is implemented by precomputing an inverse limb and calling the
<code class="docutils literal notranslate"><span class="pre">preinv</span></code> version of this function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exp</span></code> is negative but <span class="math notranslate nohighlight">\(a\)</span> is not invertible modulo <span class="math notranslate nohighlight">\(n\)</span>, an
exception is raised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod2_ui_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod2_ui_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod2_ui_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">(a^exp)</span> <span class="pre">%</span> <span class="pre">n</span></code> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. We require <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>, but there are no
restrictions on <span class="math notranslate nohighlight">\(n\)</span>. The exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> is unsigned and so can be
larger than allowed by <a class="reference internal" href="#c.n_powmod2_preinv" title="n_powmod2_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_powmod2_preinv()</span></code></a>.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod2_fmpz_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod2_fmpz_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod2_fmpz_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">(a^exp)</span> <span class="pre">%</span> <span class="pre">n</span></code> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. We require <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>, but there are no
restrictions on <span class="math notranslate nohighlight">\(n\)</span>. The exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> must not be negative.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtmod">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtmod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(p\)</span> is prime, compute a square root of <span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(p\)</span> if <span class="math notranslate nohighlight">\(a\)</span> is a
quadratic residue modulo <span class="math notranslate nohighlight">\(p\)</span>, otherwise return <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(p\)</span> is not prime the result is with high probability <span class="math notranslate nohighlight">\(0\)</span>, indicating
that <span class="math notranslate nohighlight">\(p\)</span> is not prime, or <span class="math notranslate nohighlight">\(a\)</span> is not a square modulo <span class="math notranslate nohighlight">\(p\)</span>. Otherwise the
result is meaningless.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(a\)</span> is reduced modulo <span class="math notranslate nohighlight">\(p\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtmod_2pow">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtmod_2pow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sqrt</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtmod_2pow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes all the square roots of <code class="docutils literal notranslate"><span class="pre">a</span></code> modulo <code class="docutils literal notranslate"><span class="pre">2^exp</span></code>. The roots
are stored in an array which is created and whose address is stored in
the location pointed to by <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>. The array of roots is allocated
by the function but must be cleaned up by the user by calling
<code class="docutils literal notranslate"><span class="pre">flint_free</span></code>. The number of roots is returned by the function. If
<code class="docutils literal notranslate"><span class="pre">a</span></code> is not a quadratic residue modulo <code class="docutils literal notranslate"><span class="pre">2^exp</span></code> then 0 is
returned by the function and the location <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> points to is set to
NULL.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtmod_primepow">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtmod_primepow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sqrt</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtmod_primepow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes all the square roots of <code class="docutils literal notranslate"><span class="pre">a</span></code> modulo <code class="docutils literal notranslate"><span class="pre">p^exp</span></code>. The roots
are stored in an array which is created and whose address is stored in
the location pointed to by <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>. The array of roots is allocated
by the function but must be cleaned up by the user by calling
<code class="docutils literal notranslate"><span class="pre">flint_free</span></code>. The number of roots is returned by the function. If
<code class="docutils literal notranslate"><span class="pre">a</span></code> is not a quadratic residue modulo <code class="docutils literal notranslate"><span class="pre">p^exp</span></code> then 0 is
returned by the function and the location <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> points to is set to
NULL.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtmodn">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtmodn</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sqrt</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtmodn" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes all the square roots of <code class="docutils literal notranslate"><span class="pre">a</span></code> modulo <code class="docutils literal notranslate"><span class="pre">m</span></code> given the
factorisation of <code class="docutils literal notranslate"><span class="pre">m</span></code> in <code class="docutils literal notranslate"><span class="pre">fac</span></code>. The roots are stored in an array
which is created and whose address is stored in the location pointed to by
<code class="docutils literal notranslate"><span class="pre">sqrt</span></code>. The array of roots is allocated by the function but must be
cleaned up by the user by calling <a class="reference internal" href="flint.html#c.flint_free" title="flint_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_free()</span></code></a>. The number of roots
is returned by the function. If <code class="docutils literal notranslate"><span class="pre">a</span></code> is not a quadratic residue modulo
<code class="docutils literal notranslate"><span class="pre">m</span></code> then 0 is returned by the function and the location <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>
points to is set to NULL.</p>
</dd></dl>

</section>
<section id="modular-arithmetic-with-fixed-operand">
<h2>Modular arithmetic with fixed operand<a class="headerlink" href="#modular-arithmetic-with-fixed-operand" title="Link to this heading">¶</a></h2>
<p>This is about computing several modular multiplications where one operand and
the modulus are fixed, that is, computing <span class="math notranslate nohighlight">\(a b_i \bmod n\)</span> for several <span class="math notranslate nohighlight">\(b_i\)</span>’s
and fixed <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(n\)</span>. Most functions below require <span class="math notranslate nohighlight">\(a &lt; n &lt;
2^{\mathtt{FLINT\_BITS} - 1}\)</span> but have no constraint on <span class="math notranslate nohighlight">\(b_i\)</span> (it can be <span class="math notranslate nohighlight">\(\ge
n\)</span>).</p>
<p>Some explanations about the method can be found after the functions
descriptions. This has been introduced in NTL and is attributed to Victor
Shoup. For references, see</p>
<ul class="simple">
<li><p>NTL code (in particular file FFT.cpp, consulted in NTL v11.5.1);</p></li>
<li><p>David Harvey, Faster arithmetic for number-theoretic transforms, 2014 J.Symbolic Computation (<a class="reference external" href="http://dx.doi.org/10.1016/j.jsc.2013.09.002">http://dx.doi.org/10.1016/j.jsc.2013.09.002</a>);</p></li>
<li><p>Victor Shoup, “Arithmetic Software Libraries”, 2021 (<a class="reference external" href="https://doi.org/10.1017/9781108854207.012">https://doi.org/10.1017/9781108854207.012</a>) (chapter 9 of the book <a class="reference external" href="https://doi.org/10.1017/9781108854207">https://doi.org/10.1017/9781108854207</a>).</p></li>
</ul>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_precomp_shoup">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_precomp_shoup</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_precomp_shoup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">a_precomp</span></code>, a scaled approximation of <span class="math notranslate nohighlight">\(a / n\)</span>. This requires <span class="math notranslate nohighlight">\(a
&lt; n\)</span>. Precisely, <code class="docutils literal notranslate"><span class="pre">a_precomp</span></code>  is the integer <span class="math notranslate nohighlight">\(\lfloor a \cdot
2^{\mathtt{FLINT\_BITS}} / n \rfloor\)</span>, and is intended to be used as the
precomputed data for <a class="reference internal" href="#c.n_mulmod_shoup" title="n_mulmod_shoup"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod_shoup()</span></code></a>, which requires <span class="math notranslate nohighlight">\(n &lt;
2^{\mathtt{FLINT\_BITS} - 1}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_precomp_shoup_quo_rem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_precomp_shoup_quo_rem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a_pr_quo</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a_pr_rem</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_precomp_shoup_quo_rem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">a_pr_quo</span></code> to the above scaled approximation of <span class="math notranslate nohighlight">\(\lfloor a \cdot
2^{\mathtt{FLINT\_BITS}} / n \rfloor\)</span>, which is the quotient in the integer
division of <span class="math notranslate nohighlight">\(a \cdot 2^{\mathtt{FLINT\_BITS}}\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, and also sets
<code class="docutils literal notranslate"><span class="pre">a_pr_rem</span></code> to the remainder in this division. This requires <span class="math notranslate nohighlight">\(a &lt; n\)</span> and
is intended to be used as the precomputed data for
<a class="reference internal" href="#c.n_mulmod_and_precomp_shoup" title="n_mulmod_and_precomp_shoup"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod_and_precomp_shoup()</span></code></a>, which requires <span class="math notranslate nohighlight">\(n &lt;
2^{\mathtt{FLINT\_BITS} - 1}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_precomp_shoup_rem_from_quo">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_precomp_shoup_rem_from_quo</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_pr_quo</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_precomp_shoup_rem_from_quo" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the remainder in the integer division of <span class="math notranslate nohighlight">\(a \cdot
2^{\mathtt{FLINT\_BITS}}\)</span> by <span class="math notranslate nohighlight">\(n\)</span>. This requires <span class="math notranslate nohighlight">\(a &lt; n\)</span> and is intended to
be used as the precomputed data for <a class="reference internal" href="#c.n_mulmod_and_precomp_shoup" title="n_mulmod_and_precomp_shoup"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod_and_precomp_shoup()</span></code></a>,
which requires <span class="math notranslate nohighlight">\(n &lt; 2^{\mathtt{FLINT\_BITS} - 1}\)</span>. This is faster than
<a class="reference internal" href="#c.n_mulmod_precomp_shoup_quo_rem" title="n_mulmod_precomp_shoup_quo_rem"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup_quo_rem()</span></code></a> when <code class="docutils literal notranslate"><span class="pre">a_pr_quo</span></code> is already known.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_shoup">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_shoup</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_precomp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_shoup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \bmod n\)</span> given <code class="docutils literal notranslate"><span class="pre">a_precomp</span></code>, a precomputed scaled
approximation of <span class="math notranslate nohighlight">\(a / n\)</span> equal to <span class="math notranslate nohighlight">\(\lfloor a \cdot 2^{\mathtt{FLINT\_BITS}}
/ n \rfloor\)</span>. This requires <span class="math notranslate nohighlight">\(n &lt; 2^{\mathtt{FLINT\_BITS} - 1}\)</span> and <span class="math notranslate nohighlight">\(a &lt; n\)</span>,
there is no restriction on <span class="math notranslate nohighlight">\(b\)</span>. Works faster than other <code class="docutils literal notranslate"><span class="pre">mulmod</span></code>
routines (e.g. <a class="reference internal" href="#c.n_mulmod2_preinv" title="n_mulmod2_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod2_preinv()</span></code></a>) in situations where one repeats
modular multiplications with fixed <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(n\)</span> and several values of <span class="math notranslate nohighlight">\(b\)</span>’s,
which amortizes the time for precomputing <code class="docutils literal notranslate"><span class="pre">a_precomp</span></code>. Examples are
scalar multiplication of vectors such as <a class="reference internal" href="nmod_vec.html#c._nmod_vec_scalar_mul_nmod" title="_nmod_vec_scalar_mul_nmod"><code class="xref c c-func docutils literal notranslate"><span class="pre">_nmod_vec_scalar_mul_nmod()</span></code></a>
or of matrices such as <a class="reference internal" href="nmod_mat.html#c.nmod_mat_scalar_mul" title="nmod_mat_scalar_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">nmod_mat_scalar_mul()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_and_precomp_shoup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_and_precomp_shoup</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ab</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ab_precomp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_pr_quo</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a_pr_rem</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b_precomp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_and_precomp_shoup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">ab</span></code> to <span class="math notranslate nohighlight">\(a b \bmod n\)</span> and sets <code class="docutils literal notranslate"><span class="pre">ab_precomp</span></code> to the precomputed
scaled approximation for <code class="docutils literal notranslate"><span class="pre">ab</span> <span class="pre">/</span> <span class="pre">n</span></code>, that is, <span class="math notranslate nohighlight">\(\lfloor (ab \bmod n) \cdot
2^{\mathtt{FLINT\_BITS}} / n \rfloor\)</span>. This requires <span class="math notranslate nohighlight">\(n &lt;
2^{\mathtt{FLINT\_BITS} - 1}\)</span>, <span class="math notranslate nohighlight">\(a &lt; n\)</span>, and <span class="math notranslate nohighlight">\(b &lt; n\)</span>. The input <code class="docutils literal notranslate"><span class="pre">a_pr_quo</span></code>
and <code class="docutils literal notranslate"><span class="pre">a_pr_rem</span></code> is as in the description of
<a class="reference internal" href="#c.n_mulmod_precomp_shoup_quo_rem" title="n_mulmod_precomp_shoup_quo_rem"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup_quo_rem()</span></code></a>, and <code class="docutils literal notranslate"><span class="pre">b_precomp</span></code> is as in the
description of <a class="reference internal" href="#c.n_mulmod_precomp_shoup" title="n_mulmod_precomp_shoup"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup()</span></code></a>. This can be used for example
when seeking a list of powers <span class="math notranslate nohighlight">\([a \bmod n, a^2 \bmod n, a^3 \bmod n,
\ldots]\)</span> along with associated precomputed data to speed up repeated
modular multiplications by these fixed powers.</p>
</dd></dl>

<p>Here are some explanations. Let <span class="math notranslate nohighlight">\(B = \mathtt{FLINT\_BITS}\)</span>, and <span class="math notranslate nohighlight">\(W = 2^B\)</span>. We have as input
<span class="math notranslate nohighlight">\(a, b, n\)</span>, and the goal is mainly to output <span class="math notranslate nohighlight">\(ab \bmod n\)</span>. Constraints are: <span class="math notranslate nohighlight">\(a &lt;
n\)</span>, and <span class="math notranslate nohighlight">\(n\)</span> has <span class="math notranslate nohighlight">\(&lt; B\)</span> bits, i.e. <span class="math notranslate nohighlight">\(0 \le a &lt; n &lt; 2^{B-1}\)</span>. There is no
restriction on b.</p>
<p>This is intended for repeated multiplications with fixed <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(n\)</span>, and
varying <span class="math notranslate nohighlight">\(b\)</span>; hence the initial step is seen as a precomputation (it
depends on <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(n\)</span> only).</p>
<p><strong>Precomputation step:</strong>  The main function is <code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup</span></code>,
which computes <span class="math notranslate nohighlight">\(\mathtt{a\_precomp} = \lfloor a W / n \rfloor\)</span>. The requirement
<span class="math notranslate nohighlight">\(a &lt; n\)</span> ensures <code class="docutils literal notranslate"><span class="pre">a_precomp</span></code> fits in a word (i.e. <span class="math notranslate nohighlight">\(\mathtt{a\_precomp} &lt; W\)</span>).
The variant ending in <code class="docutils literal notranslate"><span class="pre">_quo_rem</span></code> computes the same quotient
<span class="math notranslate nohighlight">\(\mathtt{a\_pr\_quo} = \mathtt{a\_precomp}\)</span> but also stores the remainder
<span class="math notranslate nohighlight">\(\mathtt{a\_pr\_rem}\)</span> in the division of <span class="math notranslate nohighlight">\(a W\)</span> by <span class="math notranslate nohighlight">\(n\)</span>; the variant ending in
<code class="docutils literal notranslate"><span class="pre">_rem_from_quo</span></code> deduces the remainder from the quotient if the latter is
already known.</p>
<p><strong>Modular multiplication:</strong> The main function is <code class="docutils literal notranslate"><span class="pre">n_mulmod_shoup</span></code>, which
takes <span class="math notranslate nohighlight">\(a, b, \hat{a}, n\)</span> as input and returns <span class="math notranslate nohighlight">\(ab \bmod n\)</span>, where <span class="math notranslate nohighlight">\(\hat{a} =
\mathtt{a\_precomp}\)</span>. The steps are:</p>
<ol class="arabic simple">
<li><p>find <span class="math notranslate nohighlight">\(\mathtt{p_hi}, \mathtt{p_lo}\)</span> such that <span class="math notranslate nohighlight">\(\hat{a} b = \mathtt{p_hi} W + \mathtt{p_lo}\)</span>     (high part of a double-word multiplication, <span class="math notranslate nohighlight">\(\mathtt{p_lo}\)</span> will not be used)</p></li>
<li><p>compute <span class="math notranslate nohighlight">\(c = ab - \mathtt{p_hi} n\)</span>                  (two single-word multiplications)</p></li>
<li><p>if <span class="math notranslate nohighlight">\(c \ge n\)</span>, return <span class="math notranslate nohighlight">\(c-n\)</span>, else return <span class="math notranslate nohighlight">\(c\)</span></p></li>
</ol>
<p><em>Step 1.</em> One has <span class="math notranslate nohighlight">\(\mathtt{p_hi} = \lfloor ab/n \rfloor\)</span> or <span class="math notranslate nohighlight">\(\mathtt{p_hi} = \lfloor ab/n \rfloor - 1\)</span>.</p>
<p>Proof: Write <span class="math notranslate nohighlight">\(aW = \hat{a} n + r\)</span>, with <span class="math notranslate nohighlight">\(0 \le r &lt; n\)</span>.  Thus <span class="math notranslate nohighlight">\(\frac{\hat{a}
b}{W} = \frac{ab}{n} - \frac{rb}{nW}\)</span>.  So <span class="math notranslate nohighlight">\(\mathtt{p_hi} = \lfloor
\frac{\hat{a} b}{W} \rfloor = \lfloor \frac{ab}{n} - \frac{rb}{nW} \rfloor\)</span>.
Clearly <span class="math notranslate nohighlight">\(\mathtt{p_hi} \le \lfloor \frac{ab}{n} \rfloor\)</span>. And <span class="math notranslate nohighlight">\(rb &lt; nW\)</span> (since
<span class="math notranslate nohighlight">\(r &lt; n\)</span> and <span class="math notranslate nohighlight">\(b &lt; W\)</span>) so <span class="math notranslate nohighlight">\(-\frac{rb}{nW} &gt; -1\)</span>, hence <span class="math notranslate nohighlight">\(\mathtt{p_hi} \ge
\lfloor \frac{ab}{n} \rfloor - 1\)</span>.</p>
<p><em>Step 2.</em> It follows that either <span class="math notranslate nohighlight">\(c = ab \bmod n\)</span> or <span class="math notranslate nohighlight">\(c = (ab \bmod n) + n\)</span>.</p>
<p>This is where the restriction on <span class="math notranslate nohighlight">\(n\)</span> comes into play: allowing <span class="math notranslate nohighlight">\(n\)</span> to have <span class="math notranslate nohighlight">\(B\)</span>
bits prevents us from detecting which case we are in (a comparison such as <span class="math notranslate nohighlight">\(c
\ge n\)</span> would not tell). Since <span class="math notranslate nohighlight">\(n\)</span> has <span class="math notranslate nohighlight">\(&lt; B\)</span> bits, <span class="math notranslate nohighlight">\(c \ge n\)</span> if and only if <span class="math notranslate nohighlight">\(c =
(ab \bmod n) + n\)</span>.</p>
<p><em>Step 3.</em> we use this to detect which case we are in and correct the possible
excess.</p>
<p><strong>Combining precomputation and multiplication:</strong> The main function is
<code class="docutils literal notranslate"><span class="pre">n_mulmod_and_precomp_shoup</span></code>. The goal is to compute not only <span class="math notranslate nohighlight">\(ab \bmod n\)</span>,
but also the corresponding quotient <span class="math notranslate nohighlight">\(\mathtt{ab\_precomp} = \lfloor (ab \bmod
n) \cdot W / n \rfloor\)</span>. For this we require as input both the precomputed
quotient and remainder for <span class="math notranslate nohighlight">\(a\)</span> (that is, <code class="docutils literal notranslate"><span class="pre">a_pr_quo</span></code> and <code class="docutils literal notranslate"><span class="pre">a_pr_rem</span></code>), as
well as the precomputed quotient for <code class="docutils literal notranslate"><span class="pre">b</span></code> (<code class="docutils literal notranslate"><span class="pre">b_precomp</span></code>). This adds the
constraint that <span class="math notranslate nohighlight">\(b &lt; n\)</span>.</p>
<p>To simplify notation, write the integer division <span class="math notranslate nohighlight">\(aW = \hat{a} n + \check{a}\)</span>
so that <span class="math notranslate nohighlight">\(\hat{a} = \mathtt{a\_pr\_quo}\)</span> and <span class="math notranslate nohighlight">\(\check{a} = \mathtt{a\_pr\_rem}\)</span>,
and similarly for <span class="math notranslate nohighlight">\(bW = \hat{b} n + \check{b}\)</span> with <span class="math notranslate nohighlight">\(\hat{b} =
\mathtt{b\_precomp}\)</span> (we will not use <span class="math notranslate nohighlight">\(\check{b}\)</span>).</p>
<p>The first three steps follow the above-described approach to compute <span class="math notranslate nohighlight">\(ab \bmod
n\)</span> using <span class="math notranslate nohighlight">\(\hat{a}\)</span> (but this time, the lower part of the double-word
multiplication is kept):</p>
<ol class="arabic simple">
<li><p>find <span class="math notranslate nohighlight">\(d, \hat{c}\)</span> such that <span class="math notranslate nohighlight">\(\hat{a} b = d W + \hat{c}\)</span> (double-word multiplication)</p></li>
<li><p>compute <span class="math notranslate nohighlight">\(c = a b - d n\)</span> (two single-word multiplications)</p></li>
<li><p>if <span class="math notranslate nohighlight">\(c \ge n\)</span> then <span class="math notranslate nohighlight">\(c \gets c - n\)</span></p></li>
</ol>
<p>At this stage, <span class="math notranslate nohighlight">\(c = ab \bmod n\)</span>, and <span class="math notranslate nohighlight">\(\hat{c} = \hat{a} b \bmod W\)</span>. Now suppose
we have the quotient <span class="math notranslate nohighlight">\(q = \lfloor \frac{\check{a} b}{n} \rfloor\)</span> in the
division of <span class="math notranslate nohighlight">\(\check{a}b\)</span> by <span class="math notranslate nohighlight">\(n\)</span>. The claim is that <span class="math notranslate nohighlight">\(\hat{c} + q\)</span> is the sought
precomputation quotient for <span class="math notranslate nohighlight">\(ab \bmod n\)</span> up to a multiple of <span class="math notranslate nohighlight">\(W\)</span>, that is,
<span class="math notranslate nohighlight">\(\hat{c} + q = \lfloor \frac{c W}{n} \rfloor \bmod W\)</span>. Indeed, one has <span class="math notranslate nohighlight">\(\lfloor
\frac{c W}{n} \rfloor = \lfloor \frac{ab W}{n} \rfloor \bmod W\)</span>, and it remains
to observe that <span class="math notranslate nohighlight">\(\lfloor \frac{ab W}{n} \rfloor = \lfloor
\frac{(\hat{a}n+\check{a}) b}{n} \rfloor = \hat{a} b + \lfloor \frac{\check{a}
b}{n} \rfloor = \hat{c} + q \bmod W\)</span>.</p>
<p>Therefore the remaining steps consist in computing the quotient <span class="math notranslate nohighlight">\(q\)</span>, which can
be done via the modular multiplication of <span class="math notranslate nohighlight">\(\check{a}\)</span> by <span class="math notranslate nohighlight">\(b\)</span> using the
precomputed quotient for <span class="math notranslate nohighlight">\(b\)</span>:</p>
<ol class="arabic simple" start="4">
<li><p>find <span class="math notranslate nohighlight">\(q,e\)</span> such that <span class="math notranslate nohighlight">\(\hat{b} \check{a} = q W + e\)</span> (high-part of double word multiplication, <span class="math notranslate nohighlight">\(e\)</span> will not be used)</p></li>
<li><p>compute <span class="math notranslate nohighlight">\(h = b \check{a} - q n\)</span> (two single-word multiplications)</p></li>
<li><p>if <span class="math notranslate nohighlight">\(h \ge n\)</span> then <span class="math notranslate nohighlight">\(q \gets q+1\)</span></p></li>
</ol>
</section>
<section id="divisibility-testing">
<h2>Divisibility testing<a class="headerlink" href="#divisibility-testing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_divides">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divides</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divides" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">1</span></code> if <code class="docutils literal notranslate"><span class="pre">p</span></code> divides <code class="docutils literal notranslate"><span class="pre">n</span></code> and sets <code class="docutils literal notranslate"><span class="pre">q</span></code> to the quotient,
otherwise returns <code class="docutils literal notranslate"><span class="pre">0</span></code> and sets <code class="docutils literal notranslate"><span class="pre">q</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>

</section>
<section id="prime-number-generation-and-counting">
<h2>Prime number generation and counting<a class="headerlink" href="#prime-number-generation-and-counting" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises the prime number iterator <code class="docutils literal notranslate"><span class="pre">iter</span></code> for use.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_clear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears memory allocated by the prime number iterator <code class="docutils literal notranslate"><span class="pre">iter</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_next">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_next</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_next" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the next prime number and advances the state of <code class="docutils literal notranslate"><span class="pre">iter</span></code>.
The first call returns 2.</p>
<p>Small primes are looked up from <code class="docutils literal notranslate"><span class="pre">flint_small_primes</span></code>.
When this table is exhausted, primes are generated in blocks
by calling <a class="reference internal" href="#c.n_primes_sieve_range" title="n_primes_sieve_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_primes_sieve_range()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_jump_after">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_jump_after</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_jump_after" title="Link to this definition">¶</a><br /></dt>
<dd><p>Changes the state of <code class="docutils literal notranslate"><span class="pre">iter</span></code> to start generating primes
after <span class="math notranslate nohighlight">\(n\)</span> (excluding <span class="math notranslate nohighlight">\(n\)</span> itself).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_extend_small">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_extend_small</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">bound</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_extend_small" title="Link to this definition">¶</a><br /></dt>
<dd><p>Extends the table of small primes in <code class="docutils literal notranslate"><span class="pre">iter</span></code> to contain
at least two primes larger than or equal to <code class="docutils literal notranslate"><span class="pre">bound</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_sieve_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_sieve_range</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_sieve_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the block endpoints of <code class="docutils literal notranslate"><span class="pre">iter</span></code> to the smallest and
largest odd numbers between <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> inclusive, and
sieves to mark all odd primes in this range.
The iterator state is changed to point to the first
number in the sieved range.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_compute_primes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_compute_primes</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_compute_primes" title="Link to this definition">¶</a><br /></dt>
<dd><p>Precomputes at least <code class="docutils literal notranslate"><span class="pre">num_primes</span></code> primes and their <code class="docutils literal notranslate"><span class="pre">double</span></code>
precomputed inverses and stores them in an internal cache.
Assuming that FLINT has been built with support for thread-local storage,
each thread has its own cache.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_arr_readonly">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_arr_readonly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_arr_readonly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to a read-only array of the first <code class="docutils literal notranslate"><span class="pre">num_primes</span></code>
prime numbers. The computed primes are cached for repeated calls.
The pointer is valid until the user calls <a class="reference internal" href="#c.n_cleanup_primes" title="n_cleanup_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_cleanup_primes()</span></code></a>
in the same thread.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_prime_inverses_arr_readonly">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">n_prime_inverses_arr_readonly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_prime_inverses_arr_readonly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to a read-only array of inverses of the first
<code class="docutils literal notranslate"><span class="pre">num_primes</span></code> prime numbers. The computed primes are cached for
repeated calls. The pointer is valid until the user calls
<a class="reference internal" href="#c.n_cleanup_primes" title="n_cleanup_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_cleanup_primes()</span></code></a> in the same thread.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cleanup_primes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cleanup_primes</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cleanup_primes" title="Link to this definition">¶</a><br /></dt>
<dd><p>Frees the internal cache of prime numbers used by the current thread.
This will invalidate any pointers returned by
<a class="reference internal" href="#c.n_primes_arr_readonly" title="n_primes_arr_readonly"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_primes_arr_readonly()</span></code></a> or <a class="reference internal" href="#c.n_prime_inverses_arr_readonly" title="n_prime_inverses_arr_readonly"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_prime_inverses_arr_readonly()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_nextprime">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_nextprime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_nextprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the next prime after <span class="math notranslate nohighlight">\(n\)</span>. Assumes the result will fit in an
<code class="docutils literal notranslate"><span class="pre">ulong</span></code>. If proved is <span class="math notranslate nohighlight">\(0\)</span>, i.e. false, the prime is not
proven prime, otherwise it is.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_prime_pi">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_prime_pi</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_prime_pi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the value of the prime counting function <span class="math notranslate nohighlight">\(\pi(n)\)</span>, i.e. the
number of primes less than or equal to <span class="math notranslate nohighlight">\(n\)</span>. The invariant
<code class="docutils literal notranslate"><span class="pre">n_prime_pi(n_nth_prime(n))</span> <span class="pre">==</span> <span class="pre">n</span></code>.</p>
<p>Currently, this function simply extends the table of cached primes up to
an upper limit and then performs a binary search.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_prime_pi_bounds">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_prime_pi_bounds</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lo</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hi</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_prime_pi_bounds" title="Link to this definition">¶</a><br /></dt>
<dd><p>Calculates lower and upper bounds for the value of the prime counting
function <code class="docutils literal notranslate"><span class="pre">lo</span> <span class="pre">&lt;=</span> <span class="pre">pi(n)</span> <span class="pre">&lt;=</span> <span class="pre">hi</span></code>. If <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code> point to
the same location, the high value will be stored.</p>
<p>This does a table lookup for small values, then switches over to some
proven bounds.</p>
<p>The upper approximation is <span class="math notranslate nohighlight">\(1.25506 n / \ln n\)</span>, and the
lower is <span class="math notranslate nohighlight">\(n / \ln n\)</span>.  These bounds are due to Rosser and
Schoenfeld <a class="reference internal" href="references.html#rossch1962" id="id9"><span>[RosSch1962]</span></a> and valid for <span class="math notranslate nohighlight">\(n \geq 17\)</span>.</p>
<p>We use the number of bits in <span class="math notranslate nohighlight">\(n\)</span> (or one less) to form an
approximation to <span class="math notranslate nohighlight">\(\ln n\)</span>, taking care to use a value too
small or too large to maintain the inequality.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_nth_prime">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_nth_prime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_nth_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(n\)</span>th prime number <span class="math notranslate nohighlight">\(p_n\)</span>, using the mathematical indexing
convention <span class="math notranslate nohighlight">\(p_1 = 2, p_2 = 3, \dotsc\)</span>.</p>
<p>This function simply ensures that the table of cached primes is large
enough and then looks up the entry.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_nth_prime_bounds">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_nth_prime_bounds</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lo</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hi</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_nth_prime_bounds" title="Link to this definition">¶</a><br /></dt>
<dd><p>Calculates lower and upper bounds for the  <span class="math notranslate nohighlight">\(n\)</span>th prime number <span class="math notranslate nohighlight">\(p_n\)</span> ,
<code class="docutils literal notranslate"><span class="pre">lo</span> <span class="pre">&lt;=</span> <span class="pre">p_n</span> <span class="pre">&lt;=</span> <span class="pre">hi</span></code>. If <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code> point to the same
location, the high value will be stored. Note that this function will
overflow for sufficiently large <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>We use the following estimates, valid for <span class="math notranslate nohighlight">\(n &gt; 5\)</span> :</p>
<div class="math notranslate nohighlight">
\[\begin{split}p_n  &amp; &gt;  n (\ln n + \ln \ln n - 1) \\
p_n  &amp; &lt;  n (\ln n + \ln \ln n) \\
p_n  &amp; &lt;  n (\ln n + \ln \ln n - 0.9427) \quad (n \geq 15985)\end{split}\]</div>
<p>The first inequality was proved by Dusart <a class="reference internal" href="references.html#dus1999" id="id10"><span>[Dus1999]</span></a>, and the last
is due to Massias and Robin <a class="reference internal" href="references.html#masrob1996" id="id11"><span>[MasRob1996]</span></a>.  For a further overview,
see <a class="reference external" href="http://primes.utm.edu/howmany.shtml">http://primes.utm.edu/howmany.shtml</a> .</p>
<p>We bound <span class="math notranslate nohighlight">\(\ln n\)</span> using the number of bits in <span class="math notranslate nohighlight">\(n\)</span> as in
<code class="docutils literal notranslate"><span class="pre">n_prime_pi_bounds()</span></code>, and estimate <span class="math notranslate nohighlight">\(\ln \ln n\)</span> to the nearest
integer; this function is nearly constant.</p>
</dd></dl>

</section>
<section id="primality-testing">
<h2>Primality testing<a class="headerlink" href="#primality-testing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_prime">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_prime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns 1 if <span class="math notranslate nohighlight">\(n\)</span> is prime and 0 otherwise. This function is intended
for general input.</p>
<p>For integers up to 15 bits, we look up the result in a bit array.
For integers between 16 and 64 bits, we do some trial division and then
perform a single base-2 strong probable prime test to detect most
composites. For numbers that pass this test, primality is certified
by checking that <span class="math notranslate nohighlight">\(n\)</span> is not one of the 31894014 base-2 strong pseudoprimes
<span class="math notranslate nohighlight">\(n &lt; 2^{64}\)</span> which have been tabulated exhaustively by Feitsma <a class="reference internal" href="references.html#feigal2013" id="id12"><span>[FeiGal2013]</span></a>.</p>
<p>The 2314 pseudoprimes up to 32 bits are simply looked up in a hash table.</p>
<p>For the pseudoprimes up to 64 bits we modify the approach of Forisek and
Jancina <a class="reference internal" href="references.html#forjan2015" id="id13"><span>[ForJan2015]</span></a>. We first eliminate a class of pseudoprimes that
are difficult to find reliable witnesses to. These are of the form pq where
p and q are primes and q = k*p(-1)+1 where k is in the interval [2,12].
A semiprime check algorithm using a single floating-point sqrt, and the
multiplicative inverses of the sqrt of k eliminates this class in
approximately 1/20 of the runtime of a fermat test. The remaining pseudoprimes
are parittioned into 32768 sets using a fast multiplicative hash, and then tested
against a precomputed witness smaller than 16-bit that is reliable to each set.</p>
<p>The total witness table requires 64KiB or 1/8 of the Forisek-Jancina table
of 262144 16-bit bases. Due to the semiprime check this test is slightly
less efficient in the case of primes, and equivalent in the average case
but it’s low memory usage means it performs better in memory intensive computations.</p>
<p>To check this implementation against Feitsma’s table, one can run the
<code class="docutils literal notranslate"><span class="pre">examples/check_n_is_prime</span></code> program.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_prime_odd_no_trial">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_prime_odd_no_trial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_prime_odd_no_trial" title="Link to this definition">¶</a><br /></dt>
<dd><p>As <a class="reference internal" href="#c.n_is_prime" title="n_is_prime"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_is_prime()</span></code></a>, but does not perform trial division. Requires
that <span class="math notranslate nohighlight">\(n\)</span> is odd. This function is much slower than <a class="reference internal" href="#c.n_is_prime" title="n_is_prime"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_is_prime()</span></code></a>
for random input but slightly faster for certifying primality or
compositeness if <span class="math notranslate nohighlight">\(n\)</span> has already
passed preliminary trial division or sieving done by the user.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_prime_pocklington">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_prime_pocklington</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">iterations</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_prime_pocklington" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a prime using the Pocklington–Lehmer primality
test. If <span class="math notranslate nohighlight">\(1\)</span> is returned <span class="math notranslate nohighlight">\(n\)</span> has been proved prime. If <span class="math notranslate nohighlight">\(0\)</span> is returned
<span class="math notranslate nohighlight">\(n\)</span> is composite. However <span class="math notranslate nohighlight">\(-1\)</span> may be returned if nothing was proved
either way due to the number of iterations being too small.</p>
<p>The most time consuming part of the algorithm is factoring
<span class="math notranslate nohighlight">\(n - 1\)</span>. For this reason <a class="reference internal" href="#c.n_factor_partial" title="n_factor_partial"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_partial()</span></code></a> is used,
which uses a combination of trial factoring and Hart’s one
line factor algorithm <a class="reference internal" href="references.html#har2012" id="id14"><span>[Har2012]</span></a> to try to quickly factor <span class="math notranslate nohighlight">\(n - 1\)</span>.
Additionally if the cofactor is less than the square root of
<span class="math notranslate nohighlight">\(n - 1\)</span> the algorithm can still proceed.</p>
<p>One can also specify a number of iterations if less time
should be taken. Simply set this to <code class="docutils literal notranslate"><span class="pre">WORD(0)</span></code> if this is irrelevant.
In most cases a greater number of iterations will not
significantly affect timings as most of the time is spent
factoring.</p>
<p>See
<a class="reference external" href="https://mathworld.wolfram.com/PocklingtonsTheorem.html">https://mathworld.wolfram.com/PocklingtonsTheorem.html</a>
for a description of the algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_prime_pseudosquare">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_prime_pseudosquare</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_prime_pseudosquare" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a prime according to Theorem 2.7 <a class="reference internal" href="references.html#lukpatwil1996" id="id15"><span>[LukPatWil1996]</span></a>.</p>
<p>We first factor <span class="math notranslate nohighlight">\(N\)</span> using trial division up to some limit <span class="math notranslate nohighlight">\(B\)</span>.
In fact, the number of primes used in the trial factoring is at
most <code class="docutils literal notranslate"><span class="pre">FLINT_PSEUDOSQUARES_CUTOFF</span></code>.</p>
<p>Next we compute <span class="math notranslate nohighlight">\(N/B\)</span> and find the next pseudosquare <span class="math notranslate nohighlight">\(L_p\)</span> above
this value, using a static table as per
<a class="reference external" href="https://oeis.org/A002189/b002189.txt">https://oeis.org/A002189/b002189.txt</a> .</p>
<p>As noted in the text, if <span class="math notranslate nohighlight">\(p\)</span> is prime then Step 3 will pass. This
test rejects many composites, and so by this time we suspect
that <span class="math notranslate nohighlight">\(p\)</span> is prime. If <span class="math notranslate nohighlight">\(N\)</span> is <span class="math notranslate nohighlight">\(3\)</span> or <span class="math notranslate nohighlight">\(7\)</span> modulo <span class="math notranslate nohighlight">\(8\)</span>, we are done,
and <span class="math notranslate nohighlight">\(N\)</span> is prime.</p>
<p>We now run a probable prime test, for which no known
counterexamples are known, to reject any composites. We then
proceed to prove <span class="math notranslate nohighlight">\(N\)</span> prime by executing Step 4. In the case that
<span class="math notranslate nohighlight">\(N\)</span> is <span class="math notranslate nohighlight">\(1\)</span> modulo <span class="math notranslate nohighlight">\(8\)</span>, if Step 4 fails, we extend the number of primes
<span class="math notranslate nohighlight">\(p_i\)</span> at Step 3 and hope to find one which passes Step 4. We take
the test one past the largest <span class="math notranslate nohighlight">\(p\)</span> for which we have pseudosquares
<span class="math notranslate nohighlight">\(L_p\)</span> tabulated, as this already corresponds to the next <span class="math notranslate nohighlight">\(L_p\)</span> which
is bigger than <span class="math notranslate nohighlight">\(2^{64}\)</span> and hence larger than any prime we might be
testing.</p>
<p>As explained in the text, Condition 4 cannot fail if <span class="math notranslate nohighlight">\(N\)</span> is prime.</p>
<p>The possibility exists that the probable prime test declares a
composite prime. However in that case an error is printed, as
that would be of independent interest.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_strong_probabprime_precomp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_strong_probabprime_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">npre</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_strong_probabprime_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a strong probable prime to the base <span class="math notranslate nohighlight">\(a\)</span>. We
require that <span class="math notranslate nohighlight">\(d\)</span> is set to the largest odd factor of <span class="math notranslate nohighlight">\(n - 1\)</span> and
<code class="docutils literal notranslate"><span class="pre">npre</span></code> is a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed with
<a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>.  We also require that <span class="math notranslate nohighlight">\(n &lt; 2^{53}\)</span>,
<span class="math notranslate nohighlight">\(a\)</span> to be reduced modulo <span class="math notranslate nohighlight">\(n\)</span> and not <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(n\)</span> to be odd.</p>
<p>If we write <span class="math notranslate nohighlight">\(n - 1 = 2^s d\)</span> where <span class="math notranslate nohighlight">\(d\)</span> is odd then <span class="math notranslate nohighlight">\(n\)</span> is a strong
probable prime to the base <span class="math notranslate nohighlight">\(a\)</span>, i.e. an <span class="math notranslate nohighlight">\(a\)</span>-SPRP, if either
<span class="math notranslate nohighlight">\(a^d = 1 \pmod n\)</span> or <span class="math notranslate nohighlight">\((a^d)^{2^r} = -1 \pmod n\)</span> for some <span class="math notranslate nohighlight">\(r\)</span> less
than <span class="math notranslate nohighlight">\(s\)</span>.</p>
<p>A description of strong probable primes is given here:
<a class="reference external" href="https://mathworld.wolfram.com/StrongPseudoprime.html">https://mathworld.wolfram.com/StrongPseudoprime.html</a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_strong_probabprime2_preinv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_strong_probabprime2_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ninv</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_strong_probabprime2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a strong probable prime to the base <span class="math notranslate nohighlight">\(a\)</span>. We require
that <span class="math notranslate nohighlight">\(d\)</span> is set to the largest odd factor of <span class="math notranslate nohighlight">\(n - 1\)</span> and <code class="docutils literal notranslate"><span class="pre">npre</span></code>
is a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed with <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>.
We require <span class="math notranslate nohighlight">\(a\)</span> to be reduced modulo <span class="math notranslate nohighlight">\(n\)</span> and non-zero, and <span class="math notranslate nohighlight">\(n\)</span> to be odd.</p>
<p>If we write <span class="math notranslate nohighlight">\(n - 1 = 2^s d\)</span> where <span class="math notranslate nohighlight">\(d\)</span> is odd then <span class="math notranslate nohighlight">\(n\)</span> is a strong
probable prime to the base <span class="math notranslate nohighlight">\(a\)</span> (an <span class="math notranslate nohighlight">\(a\)</span>-SPRP) if either <span class="math notranslate nohighlight">\(a^d = 1 \pmod n\)</span>
or <span class="math notranslate nohighlight">\((a^d)^{2^r} = -1 \pmod n\)</span> for some <span class="math notranslate nohighlight">\(r\)</span> less than <span class="math notranslate nohighlight">\(s\)</span>.</p>
<p>A description of strong probable primes is given here:
<a class="reference external" href="https://mathworld.wolfram.com/StrongPseudoprime.html">https://mathworld.wolfram.com/StrongPseudoprime.html</a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime_fermat">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime_fermat</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime_fermat" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is a base <span class="math notranslate nohighlight">\(i\)</span> Fermat probable prime. Requires
<span class="math notranslate nohighlight">\(1 &lt; i &lt; n\)</span> and that <span class="math notranslate nohighlight">\(i\)</span> does not divide <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>By Fermat’s Little Theorem if <span class="math notranslate nohighlight">\(i^{n-1}\)</span> is not congruent to <span class="math notranslate nohighlight">\(1\)</span>
then <span class="math notranslate nohighlight">\(n\)</span> is not prime.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime_fibonacci">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime_fibonacci</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime_fibonacci" title="Link to this definition">¶</a><br /></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(F_j\)</span> be the <span class="math notranslate nohighlight">\(j\)</span>th element of the Fibonacci sequence
<span class="math notranslate nohighlight">\(0, 1, 1, 2, 3, 5, \dotsc\)</span>, starting at <span class="math notranslate nohighlight">\(j = 0\)</span>. Then if <span class="math notranslate nohighlight">\(n\)</span> is prime
we have <span class="math notranslate nohighlight">\(F_{n - (n/5)} = 0 \pmod n\)</span>, where <span class="math notranslate nohighlight">\((n/5)\)</span> is the Jacobi
symbol.</p>
<p>For further details, see  pp. 142 <a class="reference internal" href="references.html#crapom2005" id="id16"><span>[CraPom2005]</span></a>.</p>
<p>We require that <span class="math notranslate nohighlight">\(n\)</span> is not divisible by <span class="math notranslate nohighlight">\(2\)</span> or <span class="math notranslate nohighlight">\(5\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime_BPSW">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime_BPSW</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime_BPSW" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements a Baillie–Pomerance–Selfridge–Wagstaff probable primality
test. This is a variant of the usual BPSW test (which only uses strong
base-2 probable prime and Lucas-Selfridge tests, see Baillie and
Wagstaff <a class="reference internal" href="references.html#baiwag1980" id="id17"><span>[BaiWag1980]</span></a>).</p>
<p>This implementation makes use of a weakening of the usual Baillie-PSW
test given in  <a class="reference internal" href="references.html#chen2003" id="id18"><span>[Chen2003]</span></a>, namely replacing the Lucas test with a
Fibonacci test when <span class="math notranslate nohighlight">\(n \equiv 2, 3 \pmod{5}\)</span> (see also the comment on
page 143 of <a class="reference internal" href="references.html#crapom2005" id="id19"><span>[CraPom2005]</span></a>), regarding Fibonacci pseudoprimes.</p>
<p>There are no known counterexamples to this being a primality test.</p>
<p>Up to <span class="math notranslate nohighlight">\(2^{64}\)</span> the test we use has been checked against tables of
pseudoprimes. Thus it is a primality test up to this limit.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime_lucas">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime_lucas</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime_lucas" title="Link to this definition">¶</a><br /></dt>
<dd><p>For details on Lucas pseudoprimes, see [pp. 143] <a class="reference internal" href="references.html#crapom2005" id="id20"><span>[CraPom2005]</span></a>.</p>
<p>We implement a variant of the Lucas pseudoprime test similar to that
described by Baillie and Wagstaff <a class="reference internal" href="references.html#baiwag1980" id="id21"><span>[BaiWag1980]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function is obsolete and currently just wraps <a class="reference internal" href="#c.n_is_prime" title="n_is_prime"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_is_prime()</span></code></a>.</p>
</dd></dl>

</section>
<section id="chinese-remaindering">
<h2>Chinese remaindering<a class="headerlink" href="#chinese-remaindering" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_CRT">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_CRT</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">m1</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">r2</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">m2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_CRT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Use the Chinese Remainder Theorem to return the unique value
<span class="math notranslate nohighlight">\(0 \le x &lt; M\)</span> congruent to <span class="math notranslate nohighlight">\(r_1\)</span> modulo <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(r_2\)</span> modulo <span class="math notranslate nohighlight">\(m_2\)</span>,
where <span class="math notranslate nohighlight">\(M = m_1 \times m_2\)</span> is assumed to fit a ulong.</p>
<p>It is assumed that <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(m_2\)</span> are positive integers greater
than <span class="math notranslate nohighlight">\(1\)</span> and coprime. It is assumed that <span class="math notranslate nohighlight">\(0 \le r_1 &lt; m_1\)</span> and <span class="math notranslate nohighlight">\(0 \le r_2 &lt; m_2\)</span>.</p>
</dd></dl>

</section>
<section id="square-root-and-perfect-power-testing">
<h2>Square root and perfect power testing<a class="headerlink" href="#square-root-and-perfect-power-testing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrt">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the integer truncation of the square root of <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>The implementation uses a call to the IEEE floating point sqrt function.
The integer itself is represented by the nearest double and its square
root is computed to the nearest place. If <span class="math notranslate nohighlight">\(a\)</span> is one below a square, the
rounding may be up, whereas if it is one above a square, the rounding
will be down. Thus the square root may be one too large in some
instances which we then adjust by checking if we have the right value.
We also have to be careful when the square of this too large
value causes an overflow. The same assumptions hold for a single
precision float provided the square root itself can be represented
in a single float, i.e. for <span class="math notranslate nohighlight">\(a &lt; 281474976710656 = 2^{46}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtrem">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtrem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the integer truncation of the square root of <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>The integer itself is represented by the nearest double and its square
root is computed to the nearest place. If <span class="math notranslate nohighlight">\(a\)</span> is one below a square, the
rounding may be up, whereas if it is one above a square, the rounding
will be down. Thus the square root may be one too large in some
instances which we then adjust by checking if we have the right value.
We also have to be careful when the square of this too
large value causes an overflow. The same assumptions hold for a
single precision float provided the square root itself can be
represented in a single float, i.e. for <span class="math notranslate nohighlight">\(a &lt; 281474976710656 = 2^{46}\)</span>.</p>
<p>The remainder is computed by subtracting the square of the computed square
root from <span class="math notranslate nohighlight">\(a\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_square">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_square</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_square" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(x\)</span> is a square, otherwise <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>This code first checks if <span class="math notranslate nohighlight">\(x\)</span> is a square modulo <span class="math notranslate nohighlight">\(64\)</span>,
<span class="math notranslate nohighlight">\(63 = 3 \times 3 \times 7\)</span> and <span class="math notranslate nohighlight">\(65 = 5 \times 13\)</span>, using lookup tables,
and if so it then takes a square root and checks that the square of this
equals the original value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_perfect_power235">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_perfect_power235</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_perfect_power235" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is a perfect square, cube or fifth power.</p>
<p>This function uses a series of modular tests to reject most
non 235-powers. Each modular test returns a value from 0 to 7
whose bits respectively indicate whether the value is a square,
cube or fifth power modulo the given modulus. When these are
logically <code class="docutils literal notranslate"><span class="pre">AND</span></code>-ed together, this gives a powerful test which will
reject most non-235 powers.</p>
<p>If a bit remains set indicating it may be a square, a standard
square root test is performed. Similarly a cube root or fifth
root can be taken, if indicated, to determine whether the power
of that root is exactly equal to <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_perfect_power">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_perfect_power</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_perfect_power" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(n = r^k\)</span>, return <span class="math notranslate nohighlight">\(k\)</span> and set <code class="docutils literal notranslate"><span class="pre">root</span></code> to <span class="math notranslate nohighlight">\(r\)</span>. Note that <span class="math notranslate nohighlight">\(0\)</span> and
<span class="math notranslate nohighlight">\(1\)</span> are considered squares. No guarantees are made about <span class="math notranslate nohighlight">\(r\)</span> or <span class="math notranslate nohighlight">\(k\)</span>
being the minimum possible value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_root">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_root</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">root</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_root" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.n_rootrem">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_rootrem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">remainder</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">root</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_rootrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the integer part of <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">^</span> <span class="pre">1/root</span></code>. Remainder is set as
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">base^root</span></code>. In case <span class="math notranslate nohighlight">\(n &lt; 1\)</span> or <code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">&lt;</span> <span class="pre">1</span></code>, <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrt">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrt" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
First approximation is calculated by an algorithm mentioned in this
article: <a class="reference external" href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">https://en.wikipedia.org/wiki/Fast_inverse_square_root</a> .
Instead of the inverse square root, the cube root is calculated.
This functions uses different algorithms to calculate the cube root,
depending upon the size of <span class="math notranslate nohighlight">\(n\)</span>. For numbers greater than <span class="math notranslate nohighlight">\(2^{46}\)</span>, it uses
<a class="reference internal" href="#c.n_cbrt_chebyshev_approx" title="n_cbrt_chebyshev_approx"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_cbrt_chebyshev_approx()</span></code></a>. Otherwise, it makes use of the iteration,
<span class="math notranslate nohighlight">\(x \leftarrow x - (x\cdot x\cdot x - a)\cdot x/(2\cdot x\cdot x\cdot x + a)\)</span> for getting a good estimate,
as mentioned in the paper by W. Kahan <a class="reference internal" href="references.html#kahan1991" id="id22"><span>[Kahan1991]</span></a> .</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrt_binary_search">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrt_binary_search</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrt_binary_search" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
Uses binary search to get the correct value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrt_chebyshev_approx">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrt_chebyshev_approx</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrt_chebyshev_approx" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
The number is first expressed in the form <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">2^exp</span></code>. This ensures
<span class="math notranslate nohighlight">\(x\)</span> is in the range [0.5, 1]. Cube root of x is calculated using
Chebyshev’s approximation polynomial for the function <span class="math notranslate nohighlight">\(y = x^{1/3}\)</span>. The
values of the coefficient are calculated from the Python module mpmath,
<a class="reference external" href="https://mpmath.org">https://mpmath.org</a>, using the function chebyfit. x is multiplied
by <code class="docutils literal notranslate"><span class="pre">2^exp</span></code> and the cube root of 1, 2 or 4 (according to <code class="docutils literal notranslate"><span class="pre">exp%3</span></code>).
Requires that <span class="math notranslate nohighlight">\(n\)</span> is nonzero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrtrem">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrtrem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">remainder</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrtrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
Remainder is set as <span class="math notranslate nohighlight">\(n\)</span> minus the cube of the value returned.</p>
</dd></dl>

</section>
<section id="factorisation">
<h2>Factorisation<a class="headerlink" href="#factorisation" title="Link to this heading">¶</a></h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.n_factor_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_t</span></span></span><a class="headerlink" href="#c.n_factor_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>Represents a set of distinct prime factors and their corresponding
exponents.</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.n_factor_t.num">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num</span></span></span><a class="headerlink" href="#c.n_factor_t.num" title="Link to this definition">¶</a><br /></dt>
<dd><p>The number of distinct prime factors.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.n_factor_t.p">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">p</span></span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#c.n_factor_t.p" title="Link to this definition">¶</a><br /></dt>
<dd><p>An array containing the distinct prime factors.</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.n_factor_t.exp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">exp</span></span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#c.n_factor_t.exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>An array containing the corresponding exponents.</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initializes factors.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_evaluate">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_evaluate</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_evaluate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the evaluation of <code class="docutils literal notranslate"><span class="pre">factors</span></code>,
i.e. <span class="math notranslate nohighlight">\(p_{1}^{e_{1}} \cdots p_{n}^{e_{n}}\)</span> assuming that it fits in a limb.
In case the evaluation does not fit in a limb, it returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_remove">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_remove</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Removes the highest possible power of <span class="math notranslate nohighlight">\(p\)</span> from <span class="math notranslate nohighlight">\(n\)</span>, replacing
<span class="math notranslate nohighlight">\(n\)</span> with the quotient. The return value is the highest
power of <span class="math notranslate nohighlight">\(p\)</span> that divided <span class="math notranslate nohighlight">\(n\)</span>. Assumes <span class="math notranslate nohighlight">\(n\)</span> is not <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>For <span class="math notranslate nohighlight">\(p = 2\)</span> trailing zeroes are counted. For other primes
<span class="math notranslate nohighlight">\(p\)</span> is repeatedly squared and stored in a table of powers
with the current highest power of <span class="math notranslate nohighlight">\(p\)</span> removed at each step
until no higher power can be removed. The algorithm then
proceeds down the power tree again removing powers of <span class="math notranslate nohighlight">\(p\)</span>
until none remain.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_remove2_precomp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_remove2_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ppre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_remove2_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Removes the highest possible power of <span class="math notranslate nohighlight">\(p\)</span> from <span class="math notranslate nohighlight">\(n\)</span>, replacing
<span class="math notranslate nohighlight">\(n\)</span> with the quotient. The return value is the highest
power of <span class="math notranslate nohighlight">\(p\)</span> that divided <span class="math notranslate nohighlight">\(n\)</span>. Assumes <span class="math notranslate nohighlight">\(n\)</span> is not <span class="math notranslate nohighlight">\(0\)</span>. We require
<code class="docutils literal notranslate"><span class="pre">ppre</span></code> to be set to a precomputed inverse of <span class="math notranslate nohighlight">\(p\)</span> computed
with <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>.</p>
<p>For <span class="math notranslate nohighlight">\(p = 2\)</span> trailing zeroes are counted. For other primes
<span class="math notranslate nohighlight">\(p\)</span> we make repeated use of <a class="reference internal" href="#c.n_divrem2_precomp" title="n_divrem2_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_divrem2_precomp()</span></code></a> until division
by <span class="math notranslate nohighlight">\(p\)</span> is no longer possible.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_insert">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_insert</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_insert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Inserts the given prime power factor <code class="docutils literal notranslate"><span class="pre">p^exp</span></code> into <code class="docutils literal notranslate"><span class="pre">factors</span></code>.</p>
<p>The algorithm performs a simple search to see if <span class="math notranslate nohighlight">\(p\)</span> already
exists as a prime factor in the structure. If so the exponent
there is increased by the supplied exponent. Otherwise a new
factor <code class="docutils literal notranslate"><span class="pre">p^exp</span></code> is added to the end of the structure.</p>
<p>There is no test code for this function other than its use by
the various factoring functions, which have test code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_trial_range">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_trial_range</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_trial_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Trial factor <span class="math notranslate nohighlight">\(n\)</span> with the first <code class="docutils literal notranslate"><span class="pre">num_primes</span></code> primes, but
starting at the prime with index start (counting from zero).</p>
<p>One requires an initialised <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> structure, but factors
will be added by default to an already used <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code>. Use
the function <a class="reference internal" href="#c.n_factor_init" title="n_factor_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_init()</span></code></a> defined in <code class="docutils literal notranslate"><span class="pre">ulong_extras</span></code> if
initialisation has not already been completed on factors.</p>
<p>The return value is the unfactored cofactor after trial
factoring is done.</p>
<p>The function calls <a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> automatically. See
the documentation for that function regarding limits.</p>
<p>The algorithm stops when the current prime has a square
exceeding <span class="math notranslate nohighlight">\(n\)</span>, as no prime factor of <span class="math notranslate nohighlight">\(n\)</span> can exceed this
unless <span class="math notranslate nohighlight">\(n\)</span> is prime.</p>
<p>The precomputed inverses of all the primes computed by
<a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> are utilised with the <a class="reference internal" href="#c.n_remove2_precomp" title="n_remove2_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_remove2_precomp()</span></code></a>
function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_trial">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_trial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_trial" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function calls <a class="reference internal" href="#c.n_factor_trial_range" title="n_factor_trial_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_trial_range()</span></code></a>, with the value of
<span class="math notranslate nohighlight">\(0\)</span> for <code class="docutils literal notranslate"><span class="pre">start</span></code>. By default this adds factors to an already existing
<code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> or to a newly initialised one.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_power235">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_power235</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_power235" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is not a perfect square, cube or fifth power.
Otherwise it returns the root and sets <code class="docutils literal notranslate"><span class="pre">exp</span></code> to either <span class="math notranslate nohighlight">\(2\)</span>,
<span class="math notranslate nohighlight">\(3\)</span> or <span class="math notranslate nohighlight">\(5\)</span> appropriately.</p>
<p>This function uses a series of modular tests to reject most
non 235-powers. Each modular test returns a value from 0 to 7
whose bits respectively indicate whether the value is a square,
cube or fifth power modulo the given modulus. When these are
logically <code class="docutils literal notranslate"><span class="pre">AND</span></code>-ed together, this gives a powerful test which will
reject most non-235 powers.</p>
<p>If a bit remains set indicating it may be a square, a standard
square root test is performed. Similarly a cube root or fifth
root can be taken, if indicated, to determine whether the power
of that root is exactly equal to <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_one_line">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_one_line</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">iters</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_one_line" title="Link to this definition">¶</a><br /></dt>
<dd><p>This implements Bill Hart’s one line factoring algorithm <a class="reference internal" href="references.html#har2012" id="id23"><span>[Har2012]</span></a>.
It is a variant of Fermat’s algorithm which cycles through a large number
of multipliers instead of incrementing the square root. It is faster than
SQUFOF for <span class="math notranslate nohighlight">\(n\)</span> less than about <span class="math notranslate nohighlight">\(2^{40}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_lehman">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_lehman</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_lehman" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lehman’s factoring algorithm. Currently works up to <span class="math notranslate nohighlight">\(10^{16}\)</span>, but is
not particularly efficient and so is not used in the general factor
function. Always returns a factor of <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_SQUFOF">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_SQUFOF</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">iters</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_SQUFOF" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempts to split <span class="math notranslate nohighlight">\(n\)</span> using the given number of iterations
of SQUFOF. Simply set <code class="docutils literal notranslate"><span class="pre">iters</span></code> to <code class="docutils literal notranslate"><span class="pre">WORD(0)</span></code> for maximum
persistence.</p>
<p>The version of SQUFOF implemented here is as described by Gower
and Wagstaff <a class="reference internal" href="references.html#gowwag2008" id="id24"><span>[GowWag2008]</span></a>.</p>
<p>We start by trying SQUFOF directly on <span class="math notranslate nohighlight">\(n\)</span>. If that fails we
multiply it by each of the primes in <code class="docutils literal notranslate"><span class="pre">flint_primes_small</span></code> in
turn. As this multiplication may result in a two limb value
we allow this in our implementation of SQUFOF. As SQUFOF
works with values about half the size of <span class="math notranslate nohighlight">\(n\)</span> it only needs
single limb arithmetic internally.</p>
<p>If SQUFOF fails to factor <span class="math notranslate nohighlight">\(n\)</span> we return <span class="math notranslate nohighlight">\(0\)</span>, however with
<code class="docutils literal notranslate"><span class="pre">iters</span></code> large enough this should never happen.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Factors <span class="math notranslate nohighlight">\(n\)</span> with no restrictions on <span class="math notranslate nohighlight">\(n\)</span>. If the prime factors are
required to be checked with a primality test, one may set
<code class="docutils literal notranslate"><span class="pre">proved</span></code> to <span class="math notranslate nohighlight">\(1\)</span>, otherwise set it to <span class="math notranslate nohighlight">\(0\)</span>, and they will only be
probable primes. NB: at the present there is no difference because
the probable prime tests have been exhaustively tested up to <span class="math notranslate nohighlight">\(2^{64}\)</span>.</p>
<p>However, in future, this flag may produce and separately check
a primality certificate. This may be quite slow (and probably no
less reliable in practice).</p>
<p>This function first tries trial factoring with a number of primes
specified by the constant <code class="docutils literal notranslate"><span class="pre">FLINT_FACTOR_TRIAL_PRIMES</span></code>. If the
cofactor is <span class="math notranslate nohighlight">\(1\)</span> or prime the function returns with all the factors.</p>
<p>Otherwise, the cofactor is placed in the array <code class="docutils literal notranslate"><span class="pre">factor_arr</span></code>. Whilst
there are factors remaining in there which have not been split, the
algorithm continues. At each step each factor is first checked to
determine if it is a perfect power. If so it is replaced by the power
that has been found. Next if the factor is small enough and composite,
in particular, less than <code class="docutils literal notranslate"><span class="pre">FLINT_FACTOR_ONE_LINE_MAX</span></code> then
<a class="reference internal" href="#c.n_factor_one_line" title="n_factor_one_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_one_line()</span></code></a> is called with
<code class="docutils literal notranslate"><span class="pre">FLINT_FACTOR_ONE_LINE_ITERS</span></code> to try and split the factor. If
that fails or the factor is too large for <a class="reference internal" href="#c.n_factor_one_line" title="n_factor_one_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_one_line()</span></code></a>
then <a class="reference internal" href="#c.n_factor_SQUFOF" title="n_factor_SQUFOF"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_SQUFOF()</span></code></a> is called, with
<code class="docutils literal notranslate"><span class="pre">FLINT_FACTOR_SQUFOF_ITERS</span></code>. If that fails an error results and
the program aborts. However this should not happen in practice.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_trial_partial">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_trial_partial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prod</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_trial_partial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempts trial factoring of <span class="math notranslate nohighlight">\(n\)</span> with the first <code class="docutils literal notranslate"><span class="pre">num_primes</span> <span class="pre">primes</span></code>,
but stops when the product of prime factors so far exceeds <code class="docutils literal notranslate"><span class="pre">limit</span></code>.</p>
<p>One requires an initialised <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> structure, but factors
will be added by default to an already used <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code>. Use
the function <a class="reference internal" href="#c.n_factor_init" title="n_factor_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_init()</span></code></a> defined in <code class="docutils literal notranslate"><span class="pre">ulong_extras</span></code> if
initialisation has not already been completed on <code class="docutils literal notranslate"><span class="pre">factors</span></code>.</p>
<p>Once completed, <code class="docutils literal notranslate"><span class="pre">num</span></code> will contain the number of distinct
prime factors found. The field <span class="math notranslate nohighlight">\(p\)</span> is an array of <code class="docutils literal notranslate"><span class="pre">ulong</span></code>s
containing the distinct prime factors, <code class="docutils literal notranslate"><span class="pre">exp</span></code> an array
containing the corresponding exponents.</p>
<p>The return value is the unfactored cofactor after trial
factoring is done. The value <code class="docutils literal notranslate"><span class="pre">prod</span></code> will be set to the product
of the factors found.</p>
<p>The function calls <a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> automatically. See
the documentation for that function regarding limits.</p>
<p>The algorithm stops when the current prime has a square
exceeding <span class="math notranslate nohighlight">\(n\)</span>, as no prime factor of <span class="math notranslate nohighlight">\(n\)</span> can exceed this
unless <span class="math notranslate nohighlight">\(n\)</span> is prime.</p>
<p>The precomputed inverses of all the primes computed by
<a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> are utilised with the <a class="reference internal" href="#c.n_remove2_precomp" title="n_remove2_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_remove2_precomp()</span></code></a>
function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_partial">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_partial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">limit</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_partial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Factors <span class="math notranslate nohighlight">\(n\)</span>, but stops when the product of prime factors so far
exceeds <code class="docutils literal notranslate"><span class="pre">limit</span></code>.</p>
<p>One requires an initialised <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> structure, but factors
will be added by default to an already used <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code>. Use
the function <code class="docutils literal notranslate"><span class="pre">n_factor_init()</span></code> defined in <code class="docutils literal notranslate"><span class="pre">ulong_extras</span></code> if
initialisation has not already been completed on <code class="docutils literal notranslate"><span class="pre">factors</span></code>.</p>
<p>On exit, <code class="docutils literal notranslate"><span class="pre">num</span></code> will contain the number of distinct prime factors
found. The field <span class="math notranslate nohighlight">\(p\)</span> is an array of <code class="docutils literal notranslate"><span class="pre">ulong</span></code>s containing the
distinct prime factors, <code class="docutils literal notranslate"><span class="pre">exp</span></code> an array containing the corresponding
exponents.</p>
<p>The return value is the unfactored cofactor after factoring is done.</p>
<p>The factors are proved prime if <code class="docutils literal notranslate"><span class="pre">proved</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, otherwise
they are merely probably prime.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_pp1">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_pp1</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">B1</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_pp1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Factors <span class="math notranslate nohighlight">\(n\)</span> using Williams’ <span class="math notranslate nohighlight">\(p + 1\)</span> factoring algorithm, with prime
limit set to <span class="math notranslate nohighlight">\(B1\)</span>. We require <span class="math notranslate nohighlight">\(c\)</span> to be set to a random value. Each
trial of the algorithm with a different value of <span class="math notranslate nohighlight">\(c\)</span> gives another
chance to factor <span class="math notranslate nohighlight">\(n\)</span>, with roughly exponentially decreasing chance
of finding a missing factor. If <span class="math notranslate nohighlight">\(p + 1\)</span> (or <span class="math notranslate nohighlight">\(p - 1\)</span>) is not smooth
for any factor <span class="math notranslate nohighlight">\(p\)</span> of <span class="math notranslate nohighlight">\(n\)</span>, the algorithm will never succeed. The
value <span class="math notranslate nohighlight">\(c\)</span> should be less than <span class="math notranslate nohighlight">\(n\)</span> and greater than <span class="math notranslate nohighlight">\(2\)</span>.</p>
<p>If the algorithm succeeds, it returns the factor, otherwise it
returns <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(1\)</span> (the trivial factors modulo <span class="math notranslate nohighlight">\(n\)</span>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_pp1_wrapper">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_pp1_wrapper</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_pp1_wrapper" title="Link to this definition">¶</a><br /></dt>
<dd><p>A simple wrapper around <code class="docutils literal notranslate"><span class="pre">n_factor_pp1</span></code> which works in the range
<span class="math notranslate nohighlight">\(31\)</span>-<span class="math notranslate nohighlight">\(64\)</span> bits. Below this point, trial factoring will always succeed.
This function mainly exists for <code class="docutils literal notranslate"><span class="pre">n_factor</span></code> and is tuned to minimise
the time for <code class="docutils literal notranslate"><span class="pre">n_factor</span></code> on numbers that reach the <code class="docutils literal notranslate"><span class="pre">n_factor_pp1</span></code>
stage, i.e. after trial factoring and one line factoring.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_pollard_brent_single">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_pollard_brent_single</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factor</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">ai</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">xi</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">max_iters</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_pollard_brent_single" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pollard Rho algorithm (with Brent modification) for integer factorization.
Assumes that the <span class="math notranslate nohighlight">\(n\)</span> is not prime. <span class="math notranslate nohighlight">\(factor\)</span> is set as the factor if found.
It is not assured that the factor found will be prime. Does not compute the complete
factorization, just one factor. Returns 1 if factorization is successful
(non trivial factor is found), else returns 0.</p>
<p><span class="math notranslate nohighlight">\(ai\)</span> is the constant of the polynomial used, <span class="math notranslate nohighlight">\(xi\)</span> is the initial value.
<span class="math notranslate nohighlight">\(max\_iters\)</span> is the number of iterations tried in process of finding the
cycle.</p>
<p>The algorithm used is a modification of the original Pollard Rho algorithm,
suggested by Richard Brent in the paper, available at
<a class="reference external" href="https://maths-people.anu.edu.au/~brent/pd/rpb051i.pdf">https://maths-people.anu.edu.au/~brent/pd/rpb051i.pdf</a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_pollard_brent">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_pollard_brent</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factor</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n_in</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">max_tries</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">max_iters</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_pollard_brent" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pollard Rho algorithm, modified as suggested by Richard Brent. Makes a call to
<a class="reference internal" href="#c.n_factor_pollard_brent_single" title="n_factor_pollard_brent_single"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_pollard_brent_single()</span></code></a>. The input parameters ai and xi for
<a class="reference internal" href="#c.n_factor_pollard_brent_single" title="n_factor_pollard_brent_single"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_pollard_brent_single()</span></code></a> are selected at random.</p>
<p>If the algorithm fails to find a non trivial factor in one call, it tries again
(this time with a different set of random values). This process is repeated a
maximum of <span class="math notranslate nohighlight">\(max\_tries\)</span> times.</p>
<p>Assumes <span class="math notranslate nohighlight">\(n\)</span> is not prime. <span class="math notranslate nohighlight">\(factor\)</span> is set as the factor found, if factorization
is successful. In such a case, 1 is returned. Otherwise, 0 is returned. Factor
discovered is not necessarily prime.</p>
</dd></dl>

</section>
<section id="arithmetic-functions">
<h2>Arithmetic functions<a class="headerlink" href="#arithmetic-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_moebius_mu">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_moebius_mu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_moebius_mu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Moebius function <span class="math notranslate nohighlight">\(\mu(n)\)</span>, which is defined as <span class="math notranslate nohighlight">\(\mu(n) = 0\)</span>
if <span class="math notranslate nohighlight">\(n\)</span> has a prime factor of multiplicity greater than <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(\mu(n) = -1\)</span>
if <span class="math notranslate nohighlight">\(n\)</span> has an odd number of distinct prime factors, and <span class="math notranslate nohighlight">\(\mu(n) = 1\)</span> if
<span class="math notranslate nohighlight">\(n\)</span> has an even number of distinct prime factors. By convention,
<span class="math notranslate nohighlight">\(\mu(0) = 0\)</span>.</p>
<p>For even numbers, we use the identities <span class="math notranslate nohighlight">\(\mu(4n) = 0\)</span> and
<span class="math notranslate nohighlight">\(\mu(2n) = - \mu(n)\)</span>. Odd numbers up to a cutoff are then looked up from
a precomputed table storing <span class="math notranslate nohighlight">\(\mu(n) + 1\)</span> in groups of two bits.</p>
<p>For larger <span class="math notranslate nohighlight">\(n\)</span>, we first check if <span class="math notranslate nohighlight">\(n\)</span> is divisible by a small odd square
and otherwise call <code class="docutils literal notranslate"><span class="pre">n_factor()</span></code> and count the factors.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_moebius_mu_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_moebius_mu_vec</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mu</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_moebius_mu_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(\mu(n)\)</span> for <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">len</span> <span class="pre">-</span> <span class="pre">1</span></code>. This
is done by sieving over each prime in the range, flipping the sign
of <span class="math notranslate nohighlight">\(\mu(n)\)</span> for every multiple of a prime <span class="math notranslate nohighlight">\(p\)</span> and setting <span class="math notranslate nohighlight">\(\mu(n) = 0\)</span>
for every multiple of <span class="math notranslate nohighlight">\(p^2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_squarefree">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_squarefree</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_squarefree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is divisible by some perfect square, and <span class="math notranslate nohighlight">\(1\)</span> otherwise.
This simply amounts to testing whether <span class="math notranslate nohighlight">\(\mu(n) \neq 0\)</span>. As special
cases, <span class="math notranslate nohighlight">\(1\)</span> is considered squarefree and <span class="math notranslate nohighlight">\(0\)</span> is not considered squarefree.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_euler_phi">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_euler_phi</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_euler_phi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Euler totient function <span class="math notranslate nohighlight">\(\phi(n)\)</span>, counting the number of
positive integers less than or equal to <span class="math notranslate nohighlight">\(n\)</span> that are coprime to <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

</section>
<section id="factorials">
<h2>Factorials<a class="headerlink" href="#factorials" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_factorial_fast_mod2_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factorial_fast_mod2_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">pinv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factorial_fast_mod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(n! \bmod p\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(p\)</span> as computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. <span class="math notranslate nohighlight">\(p\)</span> is not required to be a prime, but
no special optimisations are made for composite <span class="math notranslate nohighlight">\(p\)</span>.
Uses fast multipoint evaluation, running in about <span class="math notranslate nohighlight">\(O(n^{1/2})\)</span> time.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factorial_mod2_preinv">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factorial_mod2_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">pinv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factorial_mod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(n! \bmod p\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(p\)</span> as computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. <span class="math notranslate nohighlight">\(p\)</span> is not required to be a prime, but
no special optimisations are made for composite <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>Uses a lookup table for small <span class="math notranslate nohighlight">\(n\)</span>, otherwise computes the product
if <span class="math notranslate nohighlight">\(n\)</span> is not too large, and calls the fast algorithm for extremely
large <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

</section>
<section id="primitive-roots-and-discrete-logarithms">
<h2>Primitive roots and discrete logarithms<a class="headerlink" href="#primitive-roots-and-discrete-logarithms" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_primitive_root_prime_prefactor">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primitive_root_prime_prefactor</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <a class="reference internal" href="#c.n_factor_t" title="n_factor_t"><span class="n"><span class="pre">n_factor_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primitive_root_prime_prefactor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a primitive root for the multiplicative subgroup of <span class="math notranslate nohighlight">\(\mathbb{Z}/p\mathbb{Z}\)</span>
where <span class="math notranslate nohighlight">\(p\)</span> is prime given the factorisation (<code class="docutils literal notranslate"><span class="pre">factors</span></code>) of <span class="math notranslate nohighlight">\(p - 1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primitive_root_prime">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primitive_root_prime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primitive_root_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a primitive root for the multiplicative subgroup of <span class="math notranslate nohighlight">\(\mathbb{Z}/p\mathbb{Z}\)</span>
where <span class="math notranslate nohighlight">\(p\)</span> is prime.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_discrete_log_bsgs">
<a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_discrete_log_bsgs</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_discrete_log_bsgs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the discrete logarithm of <span class="math notranslate nohighlight">\(b\)</span> with  respect to <span class="math notranslate nohighlight">\(a\)</span> in the
multiplicative subgroup of <span class="math notranslate nohighlight">\(\mathbb{Z}/n\mathbb{Z}\)</span> when <span class="math notranslate nohighlight">\(\mathbb{Z}/n\mathbb{Z}\)</span>
is cyclic. That is,
it returns a number <span class="math notranslate nohighlight">\(x\)</span> such that <span class="math notranslate nohighlight">\(a^x = b \bmod n\)</span>.  The
multiplicative subgroup is only cyclic when <span class="math notranslate nohighlight">\(n\)</span> is <span class="math notranslate nohighlight">\(2\)</span>, <span class="math notranslate nohighlight">\(4\)</span>,
<span class="math notranslate nohighlight">\(p^k\)</span>, or <span class="math notranslate nohighlight">\(2p^k\)</span> where <span class="math notranslate nohighlight">\(p\)</span> is an odd prime and <span class="math notranslate nohighlight">\(k\)</span> is a positive
integer.</p>
</dd></dl>

</section>
<section id="elliptic-curve-method-for-factorization-of-ulong">
<h2>Elliptic curve method for factorization of <code class="docutils literal notranslate"><span class="pre">ulong</span></code><a class="headerlink" href="#elliptic-curve-method-for-factorization-of-ulong" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_double">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_double</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x0</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">z0</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_double" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the point <span class="math notranslate nohighlight">\((x : z)\)</span> to two times <span class="math notranslate nohighlight">\((x_0 : z_0)\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span> according
to the formula</p>
<p><span class="math notranslate nohighlight">\(x = (x_0 + z_0)^2 \cdot (x_0 - z_0)^2 \mod n,\)</span></p>
<p><span class="math notranslate nohighlight">\(z = 4 x_0 z_0 \left((x_0 - z_0)^2 + 4a_{24}x_0z_0\right) \mod n.\)</span></p>
<p>This group doubling is valid only for points expressed in
Montgomery projective coordinates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_add</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x1</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">z1</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x2</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">z2</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x0</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">z0</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the point <span class="math notranslate nohighlight">\((x : z)\)</span> to the sum of <span class="math notranslate nohighlight">\((x_1 : z_1)\)</span> and <span class="math notranslate nohighlight">\((x_2 : z_2)\)</span>
modulo <span class="math notranslate nohighlight">\(n\)</span>, given the difference <span class="math notranslate nohighlight">\((x_0 : z_0)\)</span> according to the formula</p>
<p>This group doubling is valid only for points expressed in
Montgomery projective coordinates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_mul_montgomery_ladder">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_mul_montgomery_ladder</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">x0</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">z0</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_mul_montgomery_ladder" title="Link to this definition">¶</a><br /></dt>
<dd><p>Montgomery ladder algorithm for scalar multiplication of elliptic points.</p>
<p>Sets the point <span class="math notranslate nohighlight">\((x : z)\)</span> to <span class="math notranslate nohighlight">\(k(x_0 : z_0)\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Valid only for points expressed in Montgomery projective coordinates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_select_curve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_select_curve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">sigma</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_select_curve" title="Link to this definition">¶</a><br /></dt>
<dd><p>Selects a random elliptic curve given a random integer <code class="docutils literal notranslate"><span class="pre">sigma</span></code>,
according to Suyama’s parameterization. If the factor is found while
selecting the curve, <span class="math notranslate nohighlight">\(1\)</span> is returned. In case the curve found is not
suitable, <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
<p>Also selects the initial point <span class="math notranslate nohighlight">\(x_0\)</span>, and the value of <span class="math notranslate nohighlight">\((a + 2)/4\)</span>, where <span class="math notranslate nohighlight">\(a\)</span>
is a curve parameter. Sets <span class="math notranslate nohighlight">\(z_0\)</span> as <span class="math notranslate nohighlight">\(1\)</span> (shifted left by
<code class="docutils literal notranslate"><span class="pre">n_ecm_inf-&gt;normbits</span></code>). All these are stored in the
<code class="docutils literal notranslate"><span class="pre">n_ecm_t</span></code> struct.</p>
<p>The curve selected is of Montgomery form, the points selected satisfy the
curve and are projective coordinates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_stage_I">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_stage_I</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prime_array</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">num</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">B1</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_stage_I" title="Link to this definition">¶</a><br /></dt>
<dd><p>Stage I implementation of the ECM algorithm.</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> is set as the factor if found. <code class="docutils literal notranslate"><span class="pre">num</span></code> is number of prime numbers
<span class="math notranslate nohighlight">\(&lt;=\)</span> the bound <code class="docutils literal notranslate"><span class="pre">B1</span></code>. <code class="docutils literal notranslate"><span class="pre">prime_array</span></code> is an array of first <code class="docutils literal notranslate"><span class="pre">B1</span></code>
primes. <span class="math notranslate nohighlight">\(n\)</span> is the number being factored.</p>
<p>If the factor is found, <span class="math notranslate nohighlight">\(1\)</span> is returned, otherwise <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_stage_II">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_stage_II</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">B1</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">B2</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">P</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_stage_II" title="Link to this definition">¶</a><br /></dt>
<dd><p>Stage II implementation of the ECM algorithm.</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> is set as the factor if found. <code class="docutils literal notranslate"><span class="pre">B1</span></code>, <code class="docutils literal notranslate"><span class="pre">B2</span></code> are the two
bounds. <code class="docutils literal notranslate"><span class="pre">P</span></code> is the primorial (approximately equal to <span class="math notranslate nohighlight">\(\sqrt{B2}\)</span>).
<span class="math notranslate nohighlight">\(n\)</span> is the number being factored.</p>
<p>If the factor is found, <span class="math notranslate nohighlight">\(1\)</span> is returned, otherwise <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">curves</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">B1</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">B2</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Outer wrapper function for the ECM algorithm. It factors <span class="math notranslate nohighlight">\(n\)</span> which
must fit into a <code class="docutils literal notranslate"><span class="pre">ulong</span></code>.</p>
<p>The function calls stage I and II, and
the precomputations (builds <code class="docutils literal notranslate"><span class="pre">prime_array</span></code> for stage I,
<code class="docutils literal notranslate"><span class="pre">GCD_table</span></code> and <code class="docutils literal notranslate"><span class="pre">prime_table</span></code> for stage II).</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> is set as the factor if found. <code class="docutils literal notranslate"><span class="pre">curves</span></code> is the number of
random curves being tried. <code class="docutils literal notranslate"><span class="pre">B1</span></code>, <code class="docutils literal notranslate"><span class="pre">B2</span></code> are the two bounds or
stage I and stage II. <span class="math notranslate nohighlight">\(n\)</span> is the number being factored.</p>
<p>If a factor is found in stage I, <span class="math notranslate nohighlight">\(1\)</span> is returned.
If a factor is found in stage II, <span class="math notranslate nohighlight">\(2\)</span> is returned.
If a factor is found while selecting the curve, <span class="math notranslate nohighlight">\(-1\)</span> is returned.
Otherwise <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
</dd></dl>

</section>
</section>

</main>

                  
<!-- #Article navigation -->
<nav class="my-8">
  <ul
    class="text-secondary-content flex justify-between gap-4"
  >
    
      <li class="flex flex-col gap-1">
        <span class="flex items-center text-xs font-light">
          <span class="icon-[prime--angle-left]"></span>
          Previous
        </span>
        <a
          class="hover:text-accent-content text-sm underline"
          href="index_generic.html"
          title="Previous article"
          ><strong>Generic rings</strong> : <em>detailed table of contents</em></a
        >
      </li>
    
    
      <li class="flex flex-col gap-1 lg:items-end">
        <span class="flex items-center text-xs font-light">
          Next
          <span class="icon-[prime--angle-right]"></span>
        </span>
        <a
          class="hover:text-accent-content text-sm underline"
          href="fmpz.html"
          title="Next article"
          ><strong>fmpz.h</strong> – integers</a
        >
      </li>
    
  </ul>
</nav>
<!-- .#Article navigation -->
                  
<!-- #Article footer -->
<footer
  class="article-footer border-base-200 text-secondary-content/80 my-4 border-t pt-8 text-sm"
>
  <div class="flex flex-col justify-between gap-4 lg:flex-row">
    <div class="article-footer__left">
      
      
    </div>
    <div class="article-footer__right">
      
      
    </div>
  </div>
</footer>
<!-- .#Article footer -->
                </article>

                <!-- #Primary drawer (desktop) -->
                <nav
                  class="lg:sticky lg:top-[calc(var(--header-height)+var(--header-padding))] lg:h-[calc(100vh-var(--header-height)-calc(var(--header-padding)*2))] lg:overflow-y-auto scrollbar-overlay hidden lg:order-1 lg:block lg:w-2/12 lg:flex-none"
                >
                  


  <div class="global-toc">
    <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html"><strong>Building, testing and installing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="bug_reporting.html"><strong>Bug reporting</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing to FLINT</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html"><strong>Contributors</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html"><strong>Memory management</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="portability.html"><strong>Portability</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="threading.html"><strong>Threading</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flint.html"><strong>flint.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html"><strong>profiler.h</strong> – performance profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread_pool.html"><strong>thread_pool.h</strong> – thread pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpoly.html"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_vectors.html"><strong>machine_vectors.h</strong> – SIMD-accelerated operations on fixed-length vectors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generic rings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gr.html"><strong>gr.h</strong> – generic structures and their elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_implementing.html"><strong>gr.h (continued)</strong> – implementing rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_domains.html"><strong>gr.h (continued)</strong> – builtin domains and types</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_generic.html"><strong>gr_generic.h</strong> – basic algorithms and fallback implementations for generic elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_special.html"><strong>gr_special.h</strong> – special arithmetic and transcendental functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_vec.html"><strong>gr_vec.h</strong> – vectors over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mat.html"><strong>gr_mat.h</strong> – dense matrices over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_poly.html"><strong>gr_poly.h</strong> – dense univariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mpoly.html"><strong>gr_mpoly.h</strong> – sparse multivariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_series.html"><strong>gr_series.h</strong> – formal power series over generic rings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_generic.html"><strong>Generic rings</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz.html"><strong>fmpz.h</strong> – integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_vec.html"><strong>fmpz_vec.h</strong> – vectors of integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_factor.html"><strong>fmpz_factor.h</strong> – integer factorisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mat.html"><strong>fmpz_mat.h</strong> – matrices over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_lll.html"><strong>fmpz_lll.h</strong> – LLL reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly.html"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_mat.html"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_factor.html"><strong>fmpz_poly_factor.h</strong> – factorisation of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly.html"><strong>fmpz_mpoly.h</strong> – multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_factor.html"><strong>fmpz_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="long_extras.html"><strong>long_extras.h</strong> – support functions for signed word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="longlong.html"><strong>longlong.h</strong> – support functions for multi-word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_extras.html"><strong>mpn_extras.h</strong> – support functions for limb arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="aprcl.html"><strong>aprcl.h</strong> – APRCL primality testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arith.html"><strong>arith.h</strong> – arithmetic and special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft_small.html"><strong>fft_small.h</strong> – FFT modulo word-size primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="qsieve.html"><strong>qsieve.h</strong> – Quadratic sieve</a></li>
<li class="toctree-l1"><a class="reference internal" href="radix.html"><strong>radix.h</strong> – multiprecision arithmetic in general radix</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index_integers.html"><strong>Integers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Rational numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fmpq.html"><strong>fmpq.h</strong> – rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_vec.html"><strong>fmpq_vec.h</strong> – vectors over rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mat.html"><strong>fmpq_mat.h</strong> – matrices over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_poly.html"><strong>fmpq_poly.h</strong> – univariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly_factor.html"><strong>fmpq_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly.html"><strong>fmpq_mpoly.h</strong> – multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_q.html"><strong>fmpz_poly_q.h</strong> – rational functions over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_q.html"><strong>fmpz_mpoly_q.h</strong> – multivariate rational functions over Q</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_rationals.html"><strong>Rational numbers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers mod n</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nmod.html"><strong>nmod.h</strong> – integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_vec.html"><strong>nmod_vec.h</strong> – vectors over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mat.html"><strong>nmod_mat.h</strong> – matrices over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly.html"><strong>nmod_poly.h</strong> – univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_mat.html"><strong>nmod_poly_mat.h</strong> – matrices of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_factor.html"><strong>nmod_poly_factor.h</strong> – factorisation of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly.html"><strong>nmod_mpoly.h</strong> – multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly_factor.html"><strong>nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_mod.html"><strong>mpn_mod.h</strong> – integers mod n (packed multi-word n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod.html"><strong>fmpz_mod.h</strong> – arithmetic modulo integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_vec.html"><strong>fmpz_mod_vec.h</strong> – vectors over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mat.html"><strong>fmpz_mod_mat.h</strong> – matrices over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly.html"><strong>fmpz_mod_poly.h</strong> – polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly_factor.html"><strong>fmpz_mod_poly_factor.h</strong> – factorisation of polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly.html"><strong>fmpz_mod_mpoly.h</strong> – polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_factor.html"><strong>fmpz_mod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_q.html"><strong>fmpz_mod_mpoly_q.h</strong> – multivariate rational functions over Z/mZ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers_mod.html"><strong>Integers mod n</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Groups and other structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="perm.html"><strong>perm.h</strong> – permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="qfb.html"><strong>qfb.h</strong> – binary quadratic forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dirichlet.html"><strong>dirichlet.h</strong> – Dirichlet characters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlog.html"><strong>dlog.h</strong> – discrete logarithms mod ulong primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="bool_mat.html"><strong>bool_mat.h</strong> – matrices over booleans</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Number fields and algebraic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nf.html"><strong>nf.h</strong> – number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="nf_elem.html"><strong>nf_elem.h</strong> – number field elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpzi.html"><strong>fmpzi.h</strong> – Gaussian integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qqbar.html"><strong>qqbar.h</strong> – algebraic numbers represented by minimal polynomials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Feature overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using ball arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Technical conventions and potential issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_arb.html">Arb example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="mag.html"><strong>mag.h</strong> – fixed-precision unsigned floating-point numbers for bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="nfloat.html"><strong>nfloat.h</strong> – packed floating-point numbers with n-word precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="arf.html"><strong>arf.h</strong> – arbitrary-precision floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acf.html"><strong>acf.h</strong> – complex floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb.html"><strong>arb.h</strong> – real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb.html"><strong>acb.h</strong> – complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_poly.html"><strong>arb_poly.h</strong> – polynomials over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_poly.html"><strong>acb_poly.h</strong> – polynomials over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fmpz_poly.html"><strong>arb_fmpz_poly.h</strong> – extra methods for integer polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dft.html"><strong>acb_dft.h</strong> – Discrete Fourier transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_mat.html"><strong>arb_mat.h</strong> – matrices over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_mat.html"><strong>acb_mat.h</strong> – matrices over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_hypgeom.html"><strong>acb_hypgeom.h</strong> – hypergeometric functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_hypgeom.html"><strong>arb_hypgeom.h</strong> – hypergeometric functions of real variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_elliptic.html"><strong>acb_elliptic.h</strong> – elliptic integrals and functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_modular.html"><strong>acb_modular.h</strong> – modular forms of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_theta.html"><strong>acb_theta.h</strong> – Riemann theta functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dirichlet.html"><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bernoulli.html"><strong>bernoulli.h</strong> – support for Bernoulli numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypgeom.html"><strong>hypgeom.h</strong> – support for hypergeometric series</a></li>
<li class="toctree-l1"><a class="reference internal" href="partitions.html"><strong>partitions.h</strong> – computation of the partition function</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_calc.html"><strong>arb_calc.h</strong> – calculus with real-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_calc.html"><strong>acb_calc.h</strong> – calculus with complex-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fpwrap.html"><strong>arb_fpwrap.h</strong> – floating-point wrappers of Arb mathematical functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_extras.html"><strong>fmpz_extras.h</strong> – extra methods for FLINT integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">General formulas and bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">Algorithms for mathematical constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma.html">Algorithms for the gamma function</a></li>
<li class="toctree-l1"><a class="reference internal" href="hurwitz.html">Algorithms for the Hurwitz zeta function</a></li>
<li class="toctree-l1"><a class="reference internal" href="polylogarithms.html">Algorithms for polylogarithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergeometric.html">Algorithms for hypergeometric functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="agm.html">Algorithms for the arithmetic-geometric mean</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_arb.html"><strong>Real and complex numbers (Arb)</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_calcium.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_calcium.html">Calcium example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="calcium.html"><strong>calcium.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca.html"><strong>ca.h</strong> – exact real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_vec.html"><strong>ca_vec.h</strong> – vectors of real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_poly.html"><strong>ca_poly.h</strong> – dense univariate polynomials over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_mat.html"><strong>ca_mat.h</strong> – matrices over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_ext.html"><strong>ca_ext.h</strong> – real and complex extension numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_field.html"><strong>ca_field.h</strong> – extension fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr.html"><strong>fexpr.h</strong> – flat-packed symbolic expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr_builtin.html"><strong>fexpr_builtin.h</strong> – builtin symbols</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite fields</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq.html"><strong>fq.h</strong> – finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default.html"><strong>fq_default.h</strong> – unified finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_vec.html"><strong>fq_vec.h</strong> – vectors over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_mat.html"><strong>fq_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_mat.html"><strong>fq_default_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly.html"><strong>fq_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly.html"><strong>fq_default_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly_factor.html"><strong>fq_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly_factor.html"><strong>fq_default_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_embed.html"><strong>fq_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod.html"><strong>fq_nmod.h</strong> – finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_vec.html"><strong>fq_nmod_vec.h</strong> – vectors over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mat.html"><strong>fq_nmod_mat.h</strong> – matrices over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly.html"><strong>fq_nmod_poly.h</strong> – univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly_factor.html"><strong>fq_nmod_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_embed.html"><strong>fq_nmod_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly.html"><strong>fq_nmod_mpoly.h</strong> – multivariate polynomials over finite fields of word-sized characteristic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly_factor.html"><strong>fq_nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over finite fields of word-sized characteristic</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_zech.html"><strong>fq_zech.h</strong> – finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_vec.html"><strong>fq_zech_vec.h</strong> – vectors over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_mat.html"><strong>fq_zech_mat.h</strong> – matrices over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly.html"><strong>fq_zech_poly.h</strong> – univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly_factor.html"><strong>fq_zech_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_embed.html"><strong>fq_zech_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">p-adic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="padic.html"><strong>padic.h</strong> – p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_poly.html"><strong>padic_poly.h</strong> – polynomials over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_mat.html"><strong>padic_mat.h</strong> – matrices over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qadic.html"><strong>qadic.h</strong> – unramified extensions over p-adic numbers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Floating-point support code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="double_extras.html"><strong>double_extras.h</strong> – support functions for double arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="double_interval.html"><strong>double_interval.h</strong> – double-precision interval arithmetic and helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_vec.html"><strong>d_vec.h</strong> – double precision vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_mat.html"><strong>d_mat.h</strong> – double precision matrices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_flint.html"><strong>flint_ctypes</strong> - Python interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Version history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="history.html">History and changes</a></li>
</ul>

  </div>

                </nav>
                <!-- .#Primary drawer (desktop) -->

                <!-- #Secondary drawer (desktop) -->
                <aside
                  class="lg:sticky lg:top-[calc(var(--header-height)+var(--header-padding))] lg:h-[calc(100vh-var(--header-height)-calc(var(--header-padding)*2))] lg:overflow-y-auto scrollbar-overlay hidden lg:order-3 lg:block lg:w-2/12 lg:flex-none"
                >
                  


  
    <div class="local-toc">
      <p class="local-toc__caption mt-0 mb-4 font-semibold uppercase">
        On this page
      </p>
      <ul>
<li><a class="reference internal" href="#"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a><ul>
<li><a class="reference internal" href="#simple-example">Simple example</a></li>
<li><a class="reference internal" href="#random-functions">Random functions</a><ul>
<li><a class="reference internal" href="#c.n_randlimb"><code class="docutils literal notranslate"><span class="pre">n_randlimb()</span></code></a></li>
<li><a class="reference internal" href="#c._n_randlimb"><code class="docutils literal notranslate"><span class="pre">_n_randlimb()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randbits"><code class="docutils literal notranslate"><span class="pre">n_randbits()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randtest_bits"><code class="docutils literal notranslate"><span class="pre">n_randtest_bits()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randint"><code class="docutils literal notranslate"><span class="pre">n_randint()</span></code></a></li>
<li><a class="reference internal" href="#c.n_urandint"><code class="docutils literal notranslate"><span class="pre">n_urandint()</span></code></a></li>
<li><a class="reference internal" href="#c._n_randint"><code class="docutils literal notranslate"><span class="pre">_n_randint()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randtest"><code class="docutils literal notranslate"><span class="pre">n_randtest()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randtest_not_zero"><code class="docutils literal notranslate"><span class="pre">n_randtest_not_zero()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randprime"><code class="docutils literal notranslate"><span class="pre">n_randprime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randtest_prime"><code class="docutils literal notranslate"><span class="pre">n_randtest_prime()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-arithmetic">Basic arithmetic</a><ul>
<li><a class="reference internal" href="#c.n_pow"><code class="docutils literal notranslate"><span class="pre">n_pow()</span></code></a></li>
<li><a class="reference internal" href="#c.n_flog"><code class="docutils literal notranslate"><span class="pre">n_flog()</span></code></a></li>
<li><a class="reference internal" href="#c.n_clog"><code class="docutils literal notranslate"><span class="pre">n_clog()</span></code></a></li>
<li><a class="reference internal" href="#c.n_clog_2exp"><code class="docutils literal notranslate"><span class="pre">n_clog_2exp()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a><ul>
<li><a class="reference internal" href="#c.n_revbin"><code class="docutils literal notranslate"><span class="pre">n_revbin()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sizeinbase"><code class="docutils literal notranslate"><span class="pre">n_sizeinbase()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-arithmetic-with-precomputed-inverses">Basic arithmetic with precomputed inverses</a><ul>
<li><a class="reference internal" href="#c.n_preinvert_limb_prenorm"><code class="docutils literal notranslate"><span class="pre">n_preinvert_limb_prenorm()</span></code></a></li>
<li><a class="reference internal" href="#c.n_preinvert_limb"><code class="docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a></li>
<li><a class="reference internal" href="#c.n_precompute_inverse"><code class="docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mod_precomp"><code class="docutils literal notranslate"><span class="pre">n_mod_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mod2_precomp"><code class="docutils literal notranslate"><span class="pre">n_mod2_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem2_preinv"><code class="docutils literal notranslate"><span class="pre">n_divrem2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem_preinv"><code class="docutils literal notranslate"><span class="pre">n_divrem_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem_preinv_unnorm"><code class="docutils literal notranslate"><span class="pre">n_divrem_preinv_unnorm()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem_norm"><code class="docutils literal notranslate"><span class="pre">n_divrem_norm()</span></code></a></li>
<li><a class="reference internal" href="#c.n_div2_preinv"><code class="docutils literal notranslate"><span class="pre">n_div2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_mod2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem2_precomp"><code class="docutils literal notranslate"><span class="pre">n_divrem2_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_ll_mod_preinv"><code class="docutils literal notranslate"><span class="pre">n_ll_mod_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_lll_mod_preinv"><code class="docutils literal notranslate"><span class="pre">n_lll_mod_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_precomp"><code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_mulmod2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod2"><code class="docutils literal notranslate"><span class="pre">n_mulmod2()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_preinv"><code class="docutils literal notranslate"><span class="pre">n_mulmod_preinv()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#greatest-common-divisor">Greatest common divisor</a><ul>
<li><a class="reference internal" href="#c.n_gcd"><code class="docutils literal notranslate"><span class="pre">n_gcd()</span></code></a></li>
<li><a class="reference internal" href="#c.n_gcdinv"><code class="docutils literal notranslate"><span class="pre">n_gcdinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_xgcd"><code class="docutils literal notranslate"><span class="pre">n_xgcd()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#jacobi-and-kronecker-symbols">Jacobi and Kronecker symbols</a><ul>
<li><a class="reference internal" href="#c.n_jacobi"><code class="docutils literal notranslate"><span class="pre">n_jacobi()</span></code></a></li>
<li><a class="reference internal" href="#c.n_jacobi_unsigned"><code class="docutils literal notranslate"><span class="pre">n_jacobi_unsigned()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modular-arithmetic">Modular arithmetic</a><ul>
<li><a class="reference internal" href="#c.n_addmod"><code class="docutils literal notranslate"><span class="pre">n_addmod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_submod"><code class="docutils literal notranslate"><span class="pre">n_submod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_invmod"><code class="docutils literal notranslate"><span class="pre">n_invmod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_binvert"><code class="docutils literal notranslate"><span class="pre">n_binvert()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod_precomp"><code class="docutils literal notranslate"><span class="pre">n_powmod_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod_ui_precomp"><code class="docutils literal notranslate"><span class="pre">n_powmod_ui_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod"><code class="docutils literal notranslate"><span class="pre">n_powmod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_powmod2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod2"><code class="docutils literal notranslate"><span class="pre">n_powmod2()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod2_ui_preinv"><code class="docutils literal notranslate"><span class="pre">n_powmod2_ui_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod2_fmpz_preinv"><code class="docutils literal notranslate"><span class="pre">n_powmod2_fmpz_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtmod"><code class="docutils literal notranslate"><span class="pre">n_sqrtmod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtmod_2pow"><code class="docutils literal notranslate"><span class="pre">n_sqrtmod_2pow()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtmod_primepow"><code class="docutils literal notranslate"><span class="pre">n_sqrtmod_primepow()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtmodn"><code class="docutils literal notranslate"><span class="pre">n_sqrtmodn()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modular-arithmetic-with-fixed-operand">Modular arithmetic with fixed operand</a><ul>
<li><a class="reference internal" href="#c.n_mulmod_precomp_shoup"><code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_precomp_shoup_quo_rem"><code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup_quo_rem()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_precomp_shoup_rem_from_quo"><code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup_rem_from_quo()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_shoup"><code class="docutils literal notranslate"><span class="pre">n_mulmod_shoup()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_and_precomp_shoup"><code class="docutils literal notranslate"><span class="pre">n_mulmod_and_precomp_shoup()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#divisibility-testing">Divisibility testing</a><ul>
<li><a class="reference internal" href="#c.n_divides"><code class="docutils literal notranslate"><span class="pre">n_divides()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#prime-number-generation-and-counting">Prime number generation and counting</a><ul>
<li><a class="reference internal" href="#c.n_primes_init"><code class="docutils literal notranslate"><span class="pre">n_primes_init()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_clear"><code class="docutils literal notranslate"><span class="pre">n_primes_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_next"><code class="docutils literal notranslate"><span class="pre">n_primes_next()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_jump_after"><code class="docutils literal notranslate"><span class="pre">n_primes_jump_after()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_extend_small"><code class="docutils literal notranslate"><span class="pre">n_primes_extend_small()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_sieve_range"><code class="docutils literal notranslate"><span class="pre">n_primes_sieve_range()</span></code></a></li>
<li><a class="reference internal" href="#c.n_compute_primes"><code class="docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_arr_readonly"><code class="docutils literal notranslate"><span class="pre">n_primes_arr_readonly()</span></code></a></li>
<li><a class="reference internal" href="#c.n_prime_inverses_arr_readonly"><code class="docutils literal notranslate"><span class="pre">n_prime_inverses_arr_readonly()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cleanup_primes"><code class="docutils literal notranslate"><span class="pre">n_cleanup_primes()</span></code></a></li>
<li><a class="reference internal" href="#c.n_nextprime"><code class="docutils literal notranslate"><span class="pre">n_nextprime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_prime_pi"><code class="docutils literal notranslate"><span class="pre">n_prime_pi()</span></code></a></li>
<li><a class="reference internal" href="#c.n_prime_pi_bounds"><code class="docutils literal notranslate"><span class="pre">n_prime_pi_bounds()</span></code></a></li>
<li><a class="reference internal" href="#c.n_nth_prime"><code class="docutils literal notranslate"><span class="pre">n_nth_prime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_nth_prime_bounds"><code class="docutils literal notranslate"><span class="pre">n_nth_prime_bounds()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#primality-testing">Primality testing</a><ul>
<li><a class="reference internal" href="#c.n_is_prime"><code class="docutils literal notranslate"><span class="pre">n_is_prime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_prime_odd_no_trial"><code class="docutils literal notranslate"><span class="pre">n_is_prime_odd_no_trial()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_prime_pocklington"><code class="docutils literal notranslate"><span class="pre">n_is_prime_pocklington()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_prime_pseudosquare"><code class="docutils literal notranslate"><span class="pre">n_is_prime_pseudosquare()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_strong_probabprime_precomp"><code class="docutils literal notranslate"><span class="pre">n_is_strong_probabprime_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_strong_probabprime2_preinv"><code class="docutils literal notranslate"><span class="pre">n_is_strong_probabprime2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime_fermat"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime_fermat()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime_fibonacci"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime_fibonacci()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime_BPSW"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime_BPSW()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime_lucas"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime_lucas()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#chinese-remaindering">Chinese remaindering</a><ul>
<li><a class="reference internal" href="#c.n_CRT"><code class="docutils literal notranslate"><span class="pre">n_CRT()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#square-root-and-perfect-power-testing">Square root and perfect power testing</a><ul>
<li><a class="reference internal" href="#c.n_sqrt"><code class="docutils literal notranslate"><span class="pre">n_sqrt()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtrem"><code class="docutils literal notranslate"><span class="pre">n_sqrtrem()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_square"><code class="docutils literal notranslate"><span class="pre">n_is_square()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_perfect_power235"><code class="docutils literal notranslate"><span class="pre">n_is_perfect_power235()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_perfect_power"><code class="docutils literal notranslate"><span class="pre">n_is_perfect_power()</span></code></a></li>
<li><a class="reference internal" href="#c.n_root"><code class="docutils literal notranslate"><span class="pre">n_root()</span></code></a></li>
<li><a class="reference internal" href="#c.n_rootrem"><code class="docutils literal notranslate"><span class="pre">n_rootrem()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cbrt"><code class="docutils literal notranslate"><span class="pre">n_cbrt()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cbrt_binary_search"><code class="docutils literal notranslate"><span class="pre">n_cbrt_binary_search()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cbrt_chebyshev_approx"><code class="docutils literal notranslate"><span class="pre">n_cbrt_chebyshev_approx()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cbrtrem"><code class="docutils literal notranslate"><span class="pre">n_cbrtrem()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#factorisation">Factorisation</a><ul>
<li><a class="reference internal" href="#c.n_factor_t"><code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code></a><ul>
<li><a class="reference internal" href="#c.n_factor_t.num"><code class="docutils literal notranslate"><span class="pre">num</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_t.p"><code class="docutils literal notranslate"><span class="pre">p</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_t.exp"><code class="docutils literal notranslate"><span class="pre">exp</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#c.n_factor_init"><code class="docutils literal notranslate"><span class="pre">n_factor_init()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_evaluate"><code class="docutils literal notranslate"><span class="pre">n_factor_evaluate()</span></code></a></li>
<li><a class="reference internal" href="#c.n_remove"><code class="docutils literal notranslate"><span class="pre">n_remove()</span></code></a></li>
<li><a class="reference internal" href="#c.n_remove2_precomp"><code class="docutils literal notranslate"><span class="pre">n_remove2_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_insert"><code class="docutils literal notranslate"><span class="pre">n_factor_insert()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_trial_range"><code class="docutils literal notranslate"><span class="pre">n_factor_trial_range()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_trial"><code class="docutils literal notranslate"><span class="pre">n_factor_trial()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_power235"><code class="docutils literal notranslate"><span class="pre">n_factor_power235()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_one_line"><code class="docutils literal notranslate"><span class="pre">n_factor_one_line()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_lehman"><code class="docutils literal notranslate"><span class="pre">n_factor_lehman()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_SQUFOF"><code class="docutils literal notranslate"><span class="pre">n_factor_SQUFOF()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor"><code class="docutils literal notranslate"><span class="pre">n_factor()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_trial_partial"><code class="docutils literal notranslate"><span class="pre">n_factor_trial_partial()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_partial"><code class="docutils literal notranslate"><span class="pre">n_factor_partial()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_pp1"><code class="docutils literal notranslate"><span class="pre">n_factor_pp1()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_pp1_wrapper"><code class="docutils literal notranslate"><span class="pre">n_factor_pp1_wrapper()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_pollard_brent_single"><code class="docutils literal notranslate"><span class="pre">n_factor_pollard_brent_single()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_pollard_brent"><code class="docutils literal notranslate"><span class="pre">n_factor_pollard_brent()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#arithmetic-functions">Arithmetic functions</a><ul>
<li><a class="reference internal" href="#c.n_moebius_mu"><code class="docutils literal notranslate"><span class="pre">n_moebius_mu()</span></code></a></li>
<li><a class="reference internal" href="#c.n_moebius_mu_vec"><code class="docutils literal notranslate"><span class="pre">n_moebius_mu_vec()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_squarefree"><code class="docutils literal notranslate"><span class="pre">n_is_squarefree()</span></code></a></li>
<li><a class="reference internal" href="#c.n_euler_phi"><code class="docutils literal notranslate"><span class="pre">n_euler_phi()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#factorials">Factorials</a><ul>
<li><a class="reference internal" href="#c.n_factorial_fast_mod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_factorial_fast_mod2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factorial_mod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_factorial_mod2_preinv()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#primitive-roots-and-discrete-logarithms">Primitive roots and discrete logarithms</a><ul>
<li><a class="reference internal" href="#c.n_primitive_root_prime_prefactor"><code class="docutils literal notranslate"><span class="pre">n_primitive_root_prime_prefactor()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primitive_root_prime"><code class="docutils literal notranslate"><span class="pre">n_primitive_root_prime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_discrete_log_bsgs"><code class="docutils literal notranslate"><span class="pre">n_discrete_log_bsgs()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#elliptic-curve-method-for-factorization-of-ulong">Elliptic curve method for factorization of <code class="docutils literal notranslate"><span class="pre">ulong</span></code></a><ul>
<li><a class="reference internal" href="#c.n_factor_ecm_double"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_double()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_add"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_add()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_mul_montgomery_ladder"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_mul_montgomery_ladder()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_select_curve"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_select_curve()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_stage_I"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_stage_I()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_stage_II"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_stage_II()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  

                </aside>
                <!-- .#Secondary drawer (desktop) -->
              </div>
            </main>

            
<footer class="p-4">
  <div
    class="text-secondary-content container mx-auto flex h-8 items-center justify-center text-center text-sm"
  >
    <div>
        Copyright &copy; 2009-2025, The FLINT development team
      <br class="lg:hidden" />
      Made with
      <a
        href="https://www.sphinx-doc.org"
        class="hover:text-accent-content underline"
        >Sphinx</a
      >
      and
      <a
        href="https://readcraft.io/sphinx-clarity-theme/?utm_source=sphinx_clarity_theme"
        class="hover:text-accent-content underline"
        >Clarity Theme for Sphinx </a
      >.
    </div>
  </div>
</footer>
          </div>

          
<!-- #Scroll to top -->
<div id="scroll-to-top" class="toast toast-end">
  <a
    class="btn btn-secondary btn-sm"
    href="#top"
    aria-label="Scroll to top"
  >
    Back to top
    <span class="icon-[prime--arrow-up] text-base"></span>
  </a>
</div>
<!-- .#Scroll to top -->
          
<!-- #Search dialog -->
<dialog id="searchModal" class="modal">
  <div class="modal-box absolute top-8 lg:top-16">
    <search>
      <form action="search.html" method="get">
        <label class="input input-xl w-full">
          <span class="icon-[prime--search] text-4xl"></span>
          <input
            type="search"
            class="grow"
            placeholder="Search the docs"
            name="q"
            placeholder="Search the documentation"
            aria-label="Search the documentation"
          />
          <kbd class="kbd kbd-lg p-4">Enter</kbd>
        </label>
      </form>
    </search>
    <p class="mt-4 text-sm">
      Press <kbd class="kbd">Enter</kbd> to search. Press
      <kbd class="kbd">Esc</kbd> or click outside to close.
    </p>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>close</button>
  </form>
</dialog>
<!-- .#Search dialog -->

          <!-- ====================================================== -->
          <!-- .Page content -->
          <!-- ====================================================== -->

          <!-- ====================================================== -->
          <!-- Secondary drawer after markup -->
          <!-- ====================================================== -->
        </div>
        <div class="drawer-side">
          <label
            for="secondary-drawer"
            class="drawer-overlay"
            aria-label="Close secondary sidebar"
          ></label>
          <div
            class="bg-base-100 text-base-content mt-[var(--header-height)] min-h-full w-80 overflow-y-auto p-4"
          >
            <!-- ==================================================== -->
            <!-- Secondary drawer (mobile) content -->
            <!-- ==================================================== -->
            <div class="text-xs">


  
    <div class="local-toc">
      <p class="local-toc__caption mt-0 mb-4 font-semibold uppercase">
        On this page
      </p>
      <ul>
<li><a class="reference internal" href="#"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a><ul>
<li><a class="reference internal" href="#simple-example">Simple example</a></li>
<li><a class="reference internal" href="#random-functions">Random functions</a><ul>
<li><a class="reference internal" href="#c.n_randlimb"><code class="docutils literal notranslate"><span class="pre">n_randlimb()</span></code></a></li>
<li><a class="reference internal" href="#c._n_randlimb"><code class="docutils literal notranslate"><span class="pre">_n_randlimb()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randbits"><code class="docutils literal notranslate"><span class="pre">n_randbits()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randtest_bits"><code class="docutils literal notranslate"><span class="pre">n_randtest_bits()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randint"><code class="docutils literal notranslate"><span class="pre">n_randint()</span></code></a></li>
<li><a class="reference internal" href="#c.n_urandint"><code class="docutils literal notranslate"><span class="pre">n_urandint()</span></code></a></li>
<li><a class="reference internal" href="#c._n_randint"><code class="docutils literal notranslate"><span class="pre">_n_randint()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randtest"><code class="docutils literal notranslate"><span class="pre">n_randtest()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randtest_not_zero"><code class="docutils literal notranslate"><span class="pre">n_randtest_not_zero()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randprime"><code class="docutils literal notranslate"><span class="pre">n_randprime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_randtest_prime"><code class="docutils literal notranslate"><span class="pre">n_randtest_prime()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-arithmetic">Basic arithmetic</a><ul>
<li><a class="reference internal" href="#c.n_pow"><code class="docutils literal notranslate"><span class="pre">n_pow()</span></code></a></li>
<li><a class="reference internal" href="#c.n_flog"><code class="docutils literal notranslate"><span class="pre">n_flog()</span></code></a></li>
<li><a class="reference internal" href="#c.n_clog"><code class="docutils literal notranslate"><span class="pre">n_clog()</span></code></a></li>
<li><a class="reference internal" href="#c.n_clog_2exp"><code class="docutils literal notranslate"><span class="pre">n_clog_2exp()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a><ul>
<li><a class="reference internal" href="#c.n_revbin"><code class="docutils literal notranslate"><span class="pre">n_revbin()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sizeinbase"><code class="docutils literal notranslate"><span class="pre">n_sizeinbase()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-arithmetic-with-precomputed-inverses">Basic arithmetic with precomputed inverses</a><ul>
<li><a class="reference internal" href="#c.n_preinvert_limb_prenorm"><code class="docutils literal notranslate"><span class="pre">n_preinvert_limb_prenorm()</span></code></a></li>
<li><a class="reference internal" href="#c.n_preinvert_limb"><code class="docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a></li>
<li><a class="reference internal" href="#c.n_precompute_inverse"><code class="docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mod_precomp"><code class="docutils literal notranslate"><span class="pre">n_mod_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mod2_precomp"><code class="docutils literal notranslate"><span class="pre">n_mod2_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem2_preinv"><code class="docutils literal notranslate"><span class="pre">n_divrem2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem_preinv"><code class="docutils literal notranslate"><span class="pre">n_divrem_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem_preinv_unnorm"><code class="docutils literal notranslate"><span class="pre">n_divrem_preinv_unnorm()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem_norm"><code class="docutils literal notranslate"><span class="pre">n_divrem_norm()</span></code></a></li>
<li><a class="reference internal" href="#c.n_div2_preinv"><code class="docutils literal notranslate"><span class="pre">n_div2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_mod2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_divrem2_precomp"><code class="docutils literal notranslate"><span class="pre">n_divrem2_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_ll_mod_preinv"><code class="docutils literal notranslate"><span class="pre">n_ll_mod_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_lll_mod_preinv"><code class="docutils literal notranslate"><span class="pre">n_lll_mod_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_precomp"><code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_mulmod2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod2"><code class="docutils literal notranslate"><span class="pre">n_mulmod2()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_preinv"><code class="docutils literal notranslate"><span class="pre">n_mulmod_preinv()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#greatest-common-divisor">Greatest common divisor</a><ul>
<li><a class="reference internal" href="#c.n_gcd"><code class="docutils literal notranslate"><span class="pre">n_gcd()</span></code></a></li>
<li><a class="reference internal" href="#c.n_gcdinv"><code class="docutils literal notranslate"><span class="pre">n_gcdinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_xgcd"><code class="docutils literal notranslate"><span class="pre">n_xgcd()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#jacobi-and-kronecker-symbols">Jacobi and Kronecker symbols</a><ul>
<li><a class="reference internal" href="#c.n_jacobi"><code class="docutils literal notranslate"><span class="pre">n_jacobi()</span></code></a></li>
<li><a class="reference internal" href="#c.n_jacobi_unsigned"><code class="docutils literal notranslate"><span class="pre">n_jacobi_unsigned()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modular-arithmetic">Modular arithmetic</a><ul>
<li><a class="reference internal" href="#c.n_addmod"><code class="docutils literal notranslate"><span class="pre">n_addmod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_submod"><code class="docutils literal notranslate"><span class="pre">n_submod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_invmod"><code class="docutils literal notranslate"><span class="pre">n_invmod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_binvert"><code class="docutils literal notranslate"><span class="pre">n_binvert()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod_precomp"><code class="docutils literal notranslate"><span class="pre">n_powmod_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod_ui_precomp"><code class="docutils literal notranslate"><span class="pre">n_powmod_ui_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod"><code class="docutils literal notranslate"><span class="pre">n_powmod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_powmod2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod2"><code class="docutils literal notranslate"><span class="pre">n_powmod2()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod2_ui_preinv"><code class="docutils literal notranslate"><span class="pre">n_powmod2_ui_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_powmod2_fmpz_preinv"><code class="docutils literal notranslate"><span class="pre">n_powmod2_fmpz_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtmod"><code class="docutils literal notranslate"><span class="pre">n_sqrtmod()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtmod_2pow"><code class="docutils literal notranslate"><span class="pre">n_sqrtmod_2pow()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtmod_primepow"><code class="docutils literal notranslate"><span class="pre">n_sqrtmod_primepow()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtmodn"><code class="docutils literal notranslate"><span class="pre">n_sqrtmodn()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modular-arithmetic-with-fixed-operand">Modular arithmetic with fixed operand</a><ul>
<li><a class="reference internal" href="#c.n_mulmod_precomp_shoup"><code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_precomp_shoup_quo_rem"><code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup_quo_rem()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_precomp_shoup_rem_from_quo"><code class="docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup_rem_from_quo()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_shoup"><code class="docutils literal notranslate"><span class="pre">n_mulmod_shoup()</span></code></a></li>
<li><a class="reference internal" href="#c.n_mulmod_and_precomp_shoup"><code class="docutils literal notranslate"><span class="pre">n_mulmod_and_precomp_shoup()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#divisibility-testing">Divisibility testing</a><ul>
<li><a class="reference internal" href="#c.n_divides"><code class="docutils literal notranslate"><span class="pre">n_divides()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#prime-number-generation-and-counting">Prime number generation and counting</a><ul>
<li><a class="reference internal" href="#c.n_primes_init"><code class="docutils literal notranslate"><span class="pre">n_primes_init()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_clear"><code class="docutils literal notranslate"><span class="pre">n_primes_clear()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_next"><code class="docutils literal notranslate"><span class="pre">n_primes_next()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_jump_after"><code class="docutils literal notranslate"><span class="pre">n_primes_jump_after()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_extend_small"><code class="docutils literal notranslate"><span class="pre">n_primes_extend_small()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_sieve_range"><code class="docutils literal notranslate"><span class="pre">n_primes_sieve_range()</span></code></a></li>
<li><a class="reference internal" href="#c.n_compute_primes"><code class="docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primes_arr_readonly"><code class="docutils literal notranslate"><span class="pre">n_primes_arr_readonly()</span></code></a></li>
<li><a class="reference internal" href="#c.n_prime_inverses_arr_readonly"><code class="docutils literal notranslate"><span class="pre">n_prime_inverses_arr_readonly()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cleanup_primes"><code class="docutils literal notranslate"><span class="pre">n_cleanup_primes()</span></code></a></li>
<li><a class="reference internal" href="#c.n_nextprime"><code class="docutils literal notranslate"><span class="pre">n_nextprime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_prime_pi"><code class="docutils literal notranslate"><span class="pre">n_prime_pi()</span></code></a></li>
<li><a class="reference internal" href="#c.n_prime_pi_bounds"><code class="docutils literal notranslate"><span class="pre">n_prime_pi_bounds()</span></code></a></li>
<li><a class="reference internal" href="#c.n_nth_prime"><code class="docutils literal notranslate"><span class="pre">n_nth_prime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_nth_prime_bounds"><code class="docutils literal notranslate"><span class="pre">n_nth_prime_bounds()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#primality-testing">Primality testing</a><ul>
<li><a class="reference internal" href="#c.n_is_prime"><code class="docutils literal notranslate"><span class="pre">n_is_prime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_prime_odd_no_trial"><code class="docutils literal notranslate"><span class="pre">n_is_prime_odd_no_trial()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_prime_pocklington"><code class="docutils literal notranslate"><span class="pre">n_is_prime_pocklington()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_prime_pseudosquare"><code class="docutils literal notranslate"><span class="pre">n_is_prime_pseudosquare()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_strong_probabprime_precomp"><code class="docutils literal notranslate"><span class="pre">n_is_strong_probabprime_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_strong_probabprime2_preinv"><code class="docutils literal notranslate"><span class="pre">n_is_strong_probabprime2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime_fermat"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime_fermat()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime_fibonacci"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime_fibonacci()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime_BPSW"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime_BPSW()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime_lucas"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime_lucas()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_probabprime"><code class="docutils literal notranslate"><span class="pre">n_is_probabprime()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#chinese-remaindering">Chinese remaindering</a><ul>
<li><a class="reference internal" href="#c.n_CRT"><code class="docutils literal notranslate"><span class="pre">n_CRT()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#square-root-and-perfect-power-testing">Square root and perfect power testing</a><ul>
<li><a class="reference internal" href="#c.n_sqrt"><code class="docutils literal notranslate"><span class="pre">n_sqrt()</span></code></a></li>
<li><a class="reference internal" href="#c.n_sqrtrem"><code class="docutils literal notranslate"><span class="pre">n_sqrtrem()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_square"><code class="docutils literal notranslate"><span class="pre">n_is_square()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_perfect_power235"><code class="docutils literal notranslate"><span class="pre">n_is_perfect_power235()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_perfect_power"><code class="docutils literal notranslate"><span class="pre">n_is_perfect_power()</span></code></a></li>
<li><a class="reference internal" href="#c.n_root"><code class="docutils literal notranslate"><span class="pre">n_root()</span></code></a></li>
<li><a class="reference internal" href="#c.n_rootrem"><code class="docutils literal notranslate"><span class="pre">n_rootrem()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cbrt"><code class="docutils literal notranslate"><span class="pre">n_cbrt()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cbrt_binary_search"><code class="docutils literal notranslate"><span class="pre">n_cbrt_binary_search()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cbrt_chebyshev_approx"><code class="docutils literal notranslate"><span class="pre">n_cbrt_chebyshev_approx()</span></code></a></li>
<li><a class="reference internal" href="#c.n_cbrtrem"><code class="docutils literal notranslate"><span class="pre">n_cbrtrem()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#factorisation">Factorisation</a><ul>
<li><a class="reference internal" href="#c.n_factor_t"><code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code></a><ul>
<li><a class="reference internal" href="#c.n_factor_t.num"><code class="docutils literal notranslate"><span class="pre">num</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_t.p"><code class="docutils literal notranslate"><span class="pre">p</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_t.exp"><code class="docutils literal notranslate"><span class="pre">exp</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#c.n_factor_init"><code class="docutils literal notranslate"><span class="pre">n_factor_init()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_evaluate"><code class="docutils literal notranslate"><span class="pre">n_factor_evaluate()</span></code></a></li>
<li><a class="reference internal" href="#c.n_remove"><code class="docutils literal notranslate"><span class="pre">n_remove()</span></code></a></li>
<li><a class="reference internal" href="#c.n_remove2_precomp"><code class="docutils literal notranslate"><span class="pre">n_remove2_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_insert"><code class="docutils literal notranslate"><span class="pre">n_factor_insert()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_trial_range"><code class="docutils literal notranslate"><span class="pre">n_factor_trial_range()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_trial"><code class="docutils literal notranslate"><span class="pre">n_factor_trial()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_power235"><code class="docutils literal notranslate"><span class="pre">n_factor_power235()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_one_line"><code class="docutils literal notranslate"><span class="pre">n_factor_one_line()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_lehman"><code class="docutils literal notranslate"><span class="pre">n_factor_lehman()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_SQUFOF"><code class="docutils literal notranslate"><span class="pre">n_factor_SQUFOF()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor"><code class="docutils literal notranslate"><span class="pre">n_factor()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_trial_partial"><code class="docutils literal notranslate"><span class="pre">n_factor_trial_partial()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_partial"><code class="docutils literal notranslate"><span class="pre">n_factor_partial()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_pp1"><code class="docutils literal notranslate"><span class="pre">n_factor_pp1()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_pp1_wrapper"><code class="docutils literal notranslate"><span class="pre">n_factor_pp1_wrapper()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_pollard_brent_single"><code class="docutils literal notranslate"><span class="pre">n_factor_pollard_brent_single()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_pollard_brent"><code class="docutils literal notranslate"><span class="pre">n_factor_pollard_brent()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#arithmetic-functions">Arithmetic functions</a><ul>
<li><a class="reference internal" href="#c.n_moebius_mu"><code class="docutils literal notranslate"><span class="pre">n_moebius_mu()</span></code></a></li>
<li><a class="reference internal" href="#c.n_moebius_mu_vec"><code class="docutils literal notranslate"><span class="pre">n_moebius_mu_vec()</span></code></a></li>
<li><a class="reference internal" href="#c.n_is_squarefree"><code class="docutils literal notranslate"><span class="pre">n_is_squarefree()</span></code></a></li>
<li><a class="reference internal" href="#c.n_euler_phi"><code class="docutils literal notranslate"><span class="pre">n_euler_phi()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#factorials">Factorials</a><ul>
<li><a class="reference internal" href="#c.n_factorial_fast_mod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_factorial_fast_mod2_preinv()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factorial_mod2_preinv"><code class="docutils literal notranslate"><span class="pre">n_factorial_mod2_preinv()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#primitive-roots-and-discrete-logarithms">Primitive roots and discrete logarithms</a><ul>
<li><a class="reference internal" href="#c.n_primitive_root_prime_prefactor"><code class="docutils literal notranslate"><span class="pre">n_primitive_root_prime_prefactor()</span></code></a></li>
<li><a class="reference internal" href="#c.n_primitive_root_prime"><code class="docutils literal notranslate"><span class="pre">n_primitive_root_prime()</span></code></a></li>
<li><a class="reference internal" href="#c.n_discrete_log_bsgs"><code class="docutils literal notranslate"><span class="pre">n_discrete_log_bsgs()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#elliptic-curve-method-for-factorization-of-ulong">Elliptic curve method for factorization of <code class="docutils literal notranslate"><span class="pre">ulong</span></code></a><ul>
<li><a class="reference internal" href="#c.n_factor_ecm_double"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_double()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_add"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_add()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_mul_montgomery_ladder"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_mul_montgomery_ladder()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_select_curve"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_select_curve()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_stage_I"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_stage_I()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm_stage_II"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm_stage_II()</span></code></a></li>
<li><a class="reference internal" href="#c.n_factor_ecm"><code class="docutils literal notranslate"><span class="pre">n_factor_ecm()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  
</div>
          </div>
        </div>
      </div>

      <!-- ========================================================== -->
      <!-- Primary drawer after markup -->
      <!-- ========================================================== -->
    </div>

    <div class="drawer-side">
      <label
        for="primary-drawer"
        aria-label="Close primary sidebar"
        class="drawer-overlay"
      ></label>
      <div
        class="bg-base-100 text-base-content mt-[var(--header-height)] min-h-full w-80 overflow-y-auto p-4"
      >
        <!-- ===================================================== -->
        <!-- Primary drawer (mobile) content -->
        <!-- ===================================================== -->
        <div class="text-xs">


  <div class="global-toc">
    <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html"><strong>Building, testing and installing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="bug_reporting.html"><strong>Bug reporting</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing to FLINT</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html"><strong>Contributors</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html"><strong>Memory management</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="portability.html"><strong>Portability</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="threading.html"><strong>Threading</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flint.html"><strong>flint.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html"><strong>profiler.h</strong> – performance profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread_pool.html"><strong>thread_pool.h</strong> – thread pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpoly.html"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_vectors.html"><strong>machine_vectors.h</strong> – SIMD-accelerated operations on fixed-length vectors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generic rings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gr.html"><strong>gr.h</strong> – generic structures and their elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_implementing.html"><strong>gr.h (continued)</strong> – implementing rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_domains.html"><strong>gr.h (continued)</strong> – builtin domains and types</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_generic.html"><strong>gr_generic.h</strong> – basic algorithms and fallback implementations for generic elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_special.html"><strong>gr_special.h</strong> – special arithmetic and transcendental functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_vec.html"><strong>gr_vec.h</strong> – vectors over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mat.html"><strong>gr_mat.h</strong> – dense matrices over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_poly.html"><strong>gr_poly.h</strong> – dense univariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mpoly.html"><strong>gr_mpoly.h</strong> – sparse multivariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_series.html"><strong>gr_series.h</strong> – formal power series over generic rings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_generic.html"><strong>Generic rings</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz.html"><strong>fmpz.h</strong> – integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_vec.html"><strong>fmpz_vec.h</strong> – vectors of integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_factor.html"><strong>fmpz_factor.h</strong> – integer factorisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mat.html"><strong>fmpz_mat.h</strong> – matrices over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_lll.html"><strong>fmpz_lll.h</strong> – LLL reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly.html"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_mat.html"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_factor.html"><strong>fmpz_poly_factor.h</strong> – factorisation of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly.html"><strong>fmpz_mpoly.h</strong> – multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_factor.html"><strong>fmpz_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="long_extras.html"><strong>long_extras.h</strong> – support functions for signed word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="longlong.html"><strong>longlong.h</strong> – support functions for multi-word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_extras.html"><strong>mpn_extras.h</strong> – support functions for limb arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="aprcl.html"><strong>aprcl.h</strong> – APRCL primality testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arith.html"><strong>arith.h</strong> – arithmetic and special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft_small.html"><strong>fft_small.h</strong> – FFT modulo word-size primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="qsieve.html"><strong>qsieve.h</strong> – Quadratic sieve</a></li>
<li class="toctree-l1"><a class="reference internal" href="radix.html"><strong>radix.h</strong> – multiprecision arithmetic in general radix</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index_integers.html"><strong>Integers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Rational numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fmpq.html"><strong>fmpq.h</strong> – rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_vec.html"><strong>fmpq_vec.h</strong> – vectors over rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mat.html"><strong>fmpq_mat.h</strong> – matrices over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_poly.html"><strong>fmpq_poly.h</strong> – univariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly_factor.html"><strong>fmpq_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly.html"><strong>fmpq_mpoly.h</strong> – multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_q.html"><strong>fmpz_poly_q.h</strong> – rational functions over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_q.html"><strong>fmpz_mpoly_q.h</strong> – multivariate rational functions over Q</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_rationals.html"><strong>Rational numbers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers mod n</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nmod.html"><strong>nmod.h</strong> – integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_vec.html"><strong>nmod_vec.h</strong> – vectors over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mat.html"><strong>nmod_mat.h</strong> – matrices over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly.html"><strong>nmod_poly.h</strong> – univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_mat.html"><strong>nmod_poly_mat.h</strong> – matrices of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_factor.html"><strong>nmod_poly_factor.h</strong> – factorisation of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly.html"><strong>nmod_mpoly.h</strong> – multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly_factor.html"><strong>nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_mod.html"><strong>mpn_mod.h</strong> – integers mod n (packed multi-word n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod.html"><strong>fmpz_mod.h</strong> – arithmetic modulo integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_vec.html"><strong>fmpz_mod_vec.h</strong> – vectors over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mat.html"><strong>fmpz_mod_mat.h</strong> – matrices over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly.html"><strong>fmpz_mod_poly.h</strong> – polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly_factor.html"><strong>fmpz_mod_poly_factor.h</strong> – factorisation of polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly.html"><strong>fmpz_mod_mpoly.h</strong> – polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_factor.html"><strong>fmpz_mod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_q.html"><strong>fmpz_mod_mpoly_q.h</strong> – multivariate rational functions over Z/mZ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers_mod.html"><strong>Integers mod n</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Groups and other structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="perm.html"><strong>perm.h</strong> – permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="qfb.html"><strong>qfb.h</strong> – binary quadratic forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dirichlet.html"><strong>dirichlet.h</strong> – Dirichlet characters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlog.html"><strong>dlog.h</strong> – discrete logarithms mod ulong primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="bool_mat.html"><strong>bool_mat.h</strong> – matrices over booleans</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Number fields and algebraic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nf.html"><strong>nf.h</strong> – number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="nf_elem.html"><strong>nf_elem.h</strong> – number field elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpzi.html"><strong>fmpzi.h</strong> – Gaussian integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qqbar.html"><strong>qqbar.h</strong> – algebraic numbers represented by minimal polynomials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Feature overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using ball arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Technical conventions and potential issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_arb.html">Arb example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="mag.html"><strong>mag.h</strong> – fixed-precision unsigned floating-point numbers for bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="nfloat.html"><strong>nfloat.h</strong> – packed floating-point numbers with n-word precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="arf.html"><strong>arf.h</strong> – arbitrary-precision floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acf.html"><strong>acf.h</strong> – complex floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb.html"><strong>arb.h</strong> – real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb.html"><strong>acb.h</strong> – complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_poly.html"><strong>arb_poly.h</strong> – polynomials over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_poly.html"><strong>acb_poly.h</strong> – polynomials over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fmpz_poly.html"><strong>arb_fmpz_poly.h</strong> – extra methods for integer polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dft.html"><strong>acb_dft.h</strong> – Discrete Fourier transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_mat.html"><strong>arb_mat.h</strong> – matrices over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_mat.html"><strong>acb_mat.h</strong> – matrices over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_hypgeom.html"><strong>acb_hypgeom.h</strong> – hypergeometric functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_hypgeom.html"><strong>arb_hypgeom.h</strong> – hypergeometric functions of real variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_elliptic.html"><strong>acb_elliptic.h</strong> – elliptic integrals and functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_modular.html"><strong>acb_modular.h</strong> – modular forms of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_theta.html"><strong>acb_theta.h</strong> – Riemann theta functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dirichlet.html"><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bernoulli.html"><strong>bernoulli.h</strong> – support for Bernoulli numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypgeom.html"><strong>hypgeom.h</strong> – support for hypergeometric series</a></li>
<li class="toctree-l1"><a class="reference internal" href="partitions.html"><strong>partitions.h</strong> – computation of the partition function</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_calc.html"><strong>arb_calc.h</strong> – calculus with real-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_calc.html"><strong>acb_calc.h</strong> – calculus with complex-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fpwrap.html"><strong>arb_fpwrap.h</strong> – floating-point wrappers of Arb mathematical functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_extras.html"><strong>fmpz_extras.h</strong> – extra methods for FLINT integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">General formulas and bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">Algorithms for mathematical constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma.html">Algorithms for the gamma function</a></li>
<li class="toctree-l1"><a class="reference internal" href="hurwitz.html">Algorithms for the Hurwitz zeta function</a></li>
<li class="toctree-l1"><a class="reference internal" href="polylogarithms.html">Algorithms for polylogarithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergeometric.html">Algorithms for hypergeometric functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="agm.html">Algorithms for the arithmetic-geometric mean</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_arb.html"><strong>Real and complex numbers (Arb)</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_calcium.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_calcium.html">Calcium example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="calcium.html"><strong>calcium.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca.html"><strong>ca.h</strong> – exact real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_vec.html"><strong>ca_vec.h</strong> – vectors of real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_poly.html"><strong>ca_poly.h</strong> – dense univariate polynomials over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_mat.html"><strong>ca_mat.h</strong> – matrices over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_ext.html"><strong>ca_ext.h</strong> – real and complex extension numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_field.html"><strong>ca_field.h</strong> – extension fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr.html"><strong>fexpr.h</strong> – flat-packed symbolic expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr_builtin.html"><strong>fexpr_builtin.h</strong> – builtin symbols</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite fields</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq.html"><strong>fq.h</strong> – finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default.html"><strong>fq_default.h</strong> – unified finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_vec.html"><strong>fq_vec.h</strong> – vectors over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_mat.html"><strong>fq_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_mat.html"><strong>fq_default_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly.html"><strong>fq_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly.html"><strong>fq_default_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly_factor.html"><strong>fq_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly_factor.html"><strong>fq_default_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_embed.html"><strong>fq_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod.html"><strong>fq_nmod.h</strong> – finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_vec.html"><strong>fq_nmod_vec.h</strong> – vectors over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mat.html"><strong>fq_nmod_mat.h</strong> – matrices over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly.html"><strong>fq_nmod_poly.h</strong> – univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly_factor.html"><strong>fq_nmod_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_embed.html"><strong>fq_nmod_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly.html"><strong>fq_nmod_mpoly.h</strong> – multivariate polynomials over finite fields of word-sized characteristic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly_factor.html"><strong>fq_nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over finite fields of word-sized characteristic</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_zech.html"><strong>fq_zech.h</strong> – finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_vec.html"><strong>fq_zech_vec.h</strong> – vectors over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_mat.html"><strong>fq_zech_mat.h</strong> – matrices over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly.html"><strong>fq_zech_poly.h</strong> – univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly_factor.html"><strong>fq_zech_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_embed.html"><strong>fq_zech_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">p-adic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="padic.html"><strong>padic.h</strong> – p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_poly.html"><strong>padic_poly.h</strong> – polynomials over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_mat.html"><strong>padic_mat.h</strong> – matrices over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qadic.html"><strong>qadic.h</strong> – unramified extensions over p-adic numbers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Floating-point support code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="double_extras.html"><strong>double_extras.h</strong> – support functions for double arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="double_interval.html"><strong>double_interval.h</strong> – double-precision interval arithmetic and helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_vec.html"><strong>d_vec.h</strong> – double precision vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_mat.html"><strong>d_mat.h</strong> – double precision matrices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_flint.html"><strong>flint_ctypes</strong> - Python interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Version history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="history.html">History and changes</a></li>
</ul>

  </div>
</div>
      </div>
    </div>
  </div>


    
    <script
  defer
  src="_static/scripts/scroll-to-top.js"
></script>

<script>
  window.ScrollspyConfig = {
    rootMargin: "-120px 0px -60% 0px",
  };
</script>
<script defer src="_static/scripts/scrollspy.js"></script>
  <script src="_static/documentation_options.js?v=4cb41d1b"></script>
  <script src="_static/doctools.js?v=c73fddf3"></script>
  <script src="_static/sphinx_highlight.js?v=36527ec2"></script>
  <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    </body>
</html>