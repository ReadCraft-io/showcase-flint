
<!doctype html>
<html
  lang="en"
  data-content_root="./"
  class="scroll-smooth [--header-height:calc(var(--spacing)*18)] [--header-padding:calc(var(--spacing)*12)]"
  id="top"
  
>
  <head>
    <title>fmpz_mat.h – matrices over the integers &mdash; FLINT 3.5.0-dev documentation</title>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="generator"
  content="Sphinx 9.1.0, Clarity Theme for Sphinx 0.1.1 (https://readcraft.io/sphinx-clarity-theme/)"
/>


<meta name="viewport" content="width=device-width, initial-scale=1" />



<script src="_static/scripts/dark-mode.js"></script>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=a5519fdd" />
    <link rel="stylesheet" type="text/css" href="_static/styles/output.css?v=71cc70a9" />



    
    
  </head>

  <body >
    
  <!-- ============================================================== -->
  <!-- Primary drawer before markup -->
  <!-- ============================================================== -->
  <div class="drawer">
    <input id="primary-drawer" type="checkbox" class="drawer-toggle" />
    <div class="drawer-content">
      <!-- ========================================================== -->
      <!-- Secondary drawer before markup -->
      <!-- ========================================================== -->
      <div class="drawer drawer-end">
        <input id="secondary-drawer" type="checkbox" class="drawer-toggle" />
        <div class="drawer-content">
          <!-- ====================================================== -->
          <!-- Page content -->
          <!-- ====================================================== -->
          <div class="bg-base-100 divide-base-200 divide-y">
            


<!-- Header -->
<header id="main-header" class="bg-base-100 sticky top-0 z-50">
  <div
    class="container mx-auto flex h-[var(--header-height)] items-center px-4 md:px-0"
  >
    <!-- Left side (logo) -->
    <div class="flex-1">
<a href="index.html">
  
  
    <span class="text-primary-content text-xl font-bold">
      
      FLINT 3.5.0-dev documentation
    </span>
  
</a></div>

    <!-- Right side -->
    <div class="flex flex-1 items-center justify-end">
      <!-- #Header menu (desktop) -->
      <div class="hidden lg:block">
        <!-- `[&_li]:self-center` - If a content of <li> is the button, the "self-center" required to properly vertically align it -->
        <!-- `[&_li>a]:px-2 [&_li>a]:py-3` - Tweaks default menu ugly padding that doesn't match to buttons padding -->
        <ul
          class="menu menu-horizontal text-secondary-content gap-2 [&_li]:self-center [&_li>a]:px-2 [&_li>a]:py-3"
        >
          
        </ul>
      </div>
      <!-- .#Header menu (desktop) -->

      <!-- #Search button -->
      <div class="tooltip tooltip-bottom" data-tip="Search">
        <button
          class="btn btn-ghost btn-secondary"
          onclick="searchModal.showModal()"
        >
          <span class="icon-[prime--search] text-2xl"></span>
        </button>
      </div>
      <!-- .#Search button -->

      
  
  


      
  <!-- #Mode select -->
  <div class="tooltip tooltip-bottom" data-tip="Light/dark mode">
    <button class="btn btn-ghost btn-secondary">
      <label class="swap swap-rotate">
        <!-- this hidden checkbox controls the state -->
        <input type="checkbox" onclick="toggleMode()" />
        <!-- light mode icon -->
        <span class="icon-[prime--sun] swap-on text-2xl"></span>
        <!-- dark mode icon -->
        <span class="icon-[prime--moon] swap-off text-2xl"></span>
      </label>
    </button>
  </div>
  <!-- .#Mode select -->


      <!-- #Header menu (mobile) -->
      <details class="dropdown dropdown-left lg:hidden">
        <summary class="btn btn-secondary aspect-square" aria-label="Menu">
          <span class="icon-[prime--bars]"></span>
          <span class="sr-only">Menu</span>
        </summary>
        <!-- `[&_li>a.btn]:justify-start` - If a content of <li> is the button, it should be aligned to the start (left) -->
        <ul
          class="menu dropdown-content bg-base-100 rounded-box dark:border-base-200 z-1 w-52 p-2 shadow-sm dark:border [&_li>a.btn]:justify-start"
        >
          
        </ul>
      </details>
      <!-- .#Header menu (mobile) -->
    </div>
  </div>
</header>
            
<!-- #Sidebar toggles (mobile) -->
<nav class="p-4 lg:hidden">
  <div class="container mx-auto flex items-center justify-between text-sm">
    <!-- Left side -->
    <div>
      
        <button
          class="btn btn-secondary btn-sm text-secondary-content/80 font-normal"
        >
          <label
            for="primary-drawer"
            class="flex cursor-pointer items-center gap-1"
          >
            <span class="icon-[prime--align-left] text-xl"></span>
            Table of Contents
          </label>
        </button>
      
    </div>
    <!-- .Left side -->
    <!-- Right side -->
    <div>
      
        <button
          class="btn btn-secondary btn-sm text-secondary-content/80 font-normal"
        >
          <label
            for="secondary-drawer"
            class="flex cursor-pointer items-center gap-1"
          >
            This page
            <span class="icon-[prime--align-right] text-xl"></span>
          </label>
        </button>
      
    </div>
    <!-- .Right side -->
  </div>
</nav>
<!-- .#Sidebar toggles (mobile) -->

            <main class="p-4 lg:pt-[var(--header-padding)]">
              <div class="container mx-auto lg:flex lg:items-start">
                <article class="lg:order-2 lg:w-8/12 lg:flex-none lg:px-12">
                  
<!-- #Breadcrumb -->
<nav class="flex flex-wrap items-center gap-1 text-sm">
  
  <a
    href="index.html"
    class="text-secondary-content/80 hover:text-accent-content hover:underline"
  >
    FLINT 3.5.0-dev documentation
  </a>

  

  
  <span
    class="icon-[prime--arrow-right] text-secondary-content/50"
  ></span>
  <span class="text-secondary-content/80"><strong>fmpz_mat.h</strong> – matrices over the integers</span>
</nav>
<!-- .#Breadcrumb -->

                  
                  <main role="main">
  <section id="fmpz-mat-h-matrices-over-the-integers">
<span id="fmpz-mat"></span><h1><strong>fmpz_mat.h</strong> – matrices over the integers<a class="headerlink" href="#fmpz-mat-h-matrices-over-the-integers" title="Link to this heading">¶</a></h1>
<p>The <a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">fmpz_mat_t</span></code></a> data type represents dense matrices of
multiprecision integers, implemented using <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><code class="xref c c-type docutils literal notranslate"><span class="pre">fmpz</span></code></a> vectors.</p>
<p>No automatic resizing is performed: in general, the user must provide
matrices of correct dimensions for both input and output variables.
Output variables are <em>not</em> allowed to be aliased with input variables
unless otherwise noted.</p>
<p>Matrices are indexed from zero: an <span class="math notranslate nohighlight">\(m \times n\)</span> matrix has rows of
index <span class="math notranslate nohighlight">\(0,1,\ldots,m-1\)</span> and columns of index <span class="math notranslate nohighlight">\(0,1,\ldots,n-1\)</span>. One or
both of <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span> may be zero.</p>
<p>Elements of a matrix can be read or written using the
<code class="docutils literal notranslate"><span class="pre">fmpz_mat_entry</span></code> macro, which returns a reference to the entry at a
given row and column index. This reference can be passed as an input
or output <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">fmpz_t</span></code></a> variable to any function in the <code class="docutils literal notranslate"><span class="pre">fmpz</span></code>
module for direct manipulation.</p>
<section id="simple-example">
<h2>Simple example<a class="headerlink" href="#simple-example" title="Link to this heading">¶</a></h2>
<p>The following example creates the <span class="math notranslate nohighlight">\(2 \times 2\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span> with value
<span class="math notranslate nohighlight">\(2i+j\)</span> at row <span class="math notranslate nohighlight">\(i\)</span> and column <span class="math notranslate nohighlight">\(j\)</span>, computes <span class="math notranslate nohighlight">\(B = A^2\)</span>, and prints both
matrices.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;fmpz.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;fmpz_mat.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="n">fmpz_mat_t</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="w">    </span><span class="n">fmpz_mat_t</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="w">    </span><span class="n">fmpz_mat_init</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmpz_mat_init</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">fmpz_set_ui</span><span class="p">(</span><span class="n">fmpz_mat_entry</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmpz_mat_mul</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">);</span>
<span class="w">    </span><span class="n">flint_printf</span><span class="p">(</span><span class="s">&quot;A = </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmpz_mat_print_pretty</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="w">    </span><span class="n">flint_printf</span><span class="p">(</span><span class="s">&quot;A^2 = </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmpz_mat_print_pretty</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmpz_mat_clear</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="w">    </span><span class="n">fmpz_mat_clear</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The output is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span>
<span class="p">[[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">]]</span>
<span class="n">A</span><span class="o">^</span><span class="mi">2</span> <span class="o">=</span>
<span class="p">[[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span> <span class="mi">11</span><span class="p">]]</span>
</pre></div>
</div>
</section>
<section id="types-macros-and-constants">
<h2>Types, macros and constants<a class="headerlink" href="#types-macros-and-constants" title="Link to this heading">¶</a></h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.fmpz_mat_struct">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_struct</span></span></span><a class="headerlink" href="#c.fmpz_mat_struct" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.fmpz_mat_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_t</span></span></span><a class="headerlink" href="#c.fmpz_mat_t" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

</section>
<section id="memory-management">
<h2>Memory management<a class="headerlink" href="#memory-management" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">rows</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">cols</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises a matrix with the given number of rows and columns for use.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears the given matrix.</p>
</dd></dl>

</section>
<section id="basic-assignment-and-manipulation">
<h2>Basic assignment and manipulation<a class="headerlink" href="#basic-assignment-and-manipulation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">mat1</span></code> to a copy of <code class="docutils literal notranslate"><span class="pre">mat2</span></code>. The dimensions of
<code class="docutils literal notranslate"><span class="pre">mat1</span></code> and <code class="docutils literal notranslate"><span class="pre">mat2</span></code> must be the same.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_init_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_init_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">src</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_init_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises the matrix <code class="docutils literal notranslate"><span class="pre">mat</span></code> to the same size as <code class="docutils literal notranslate"><span class="pre">src</span></code> and
sets it to a copy of <code class="docutils literal notranslate"><span class="pre">src</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_nrows">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_nrows</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_nrows" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_ncols">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_ncols</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_ncols" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns respectively the number of rows and columns of the matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_swap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_swap</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat1</span></span>, <a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_swap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Swaps two matrices. The dimensions of <code class="docutils literal notranslate"><span class="pre">mat1</span></code> and <code class="docutils literal notranslate"><span class="pre">mat2</span></code>
are allowed to be different.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_swap_entrywise">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_swap_entrywise</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat1</span></span>, <a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_swap_entrywise" title="Link to this definition">¶</a><br /></dt>
<dd><p>Swaps two matrices by swapping the individual entries rather than swapping
the contents of the structs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_entry">
<a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_entry</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_entry" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a reference to the entry of <code class="docutils literal notranslate"><span class="pre">mat</span></code> at row <span class="math notranslate nohighlight">\(i\)</span> and column <span class="math notranslate nohighlight">\(j\)</span>.
This reference can be passed as an input or output variable to any
function in the <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> module for direct manipulation.</p>
<p>Both <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> must not exceed the dimensions of the matrix.</p>
<p>This function is implemented as a macro.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_zero">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_zero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets all entries of <code class="docutils literal notranslate"><span class="pre">mat</span></code> to 0.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_one">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_one</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">mat</span></code> to the unit matrix, having ones on the main diagonal
and zeroes elsewhere. If <code class="docutils literal notranslate"><span class="pre">mat</span></code> is nonsquare, it is set to the
truncation of a unit matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_swap_rows">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_swap_rows</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">perm</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_swap_rows" title="Link to this definition">¶</a><br /></dt>
<dd><p>Swaps rows <code class="docutils literal notranslate"><span class="pre">r</span></code> and <code class="docutils literal notranslate"><span class="pre">s</span></code> of <code class="docutils literal notranslate"><span class="pre">mat</span></code>.  If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the
permutation of the rows will also be applied to <code class="docutils literal notranslate"><span class="pre">perm</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_swap_cols">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_swap_cols</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">perm</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_swap_cols" title="Link to this definition">¶</a><br /></dt>
<dd><p>Swaps columns <code class="docutils literal notranslate"><span class="pre">r</span></code> and <code class="docutils literal notranslate"><span class="pre">s</span></code> of <code class="docutils literal notranslate"><span class="pre">mat</span></code>.  If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the
permutation of the columns will also be applied to <code class="docutils literal notranslate"><span class="pre">perm</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_invert_rows">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_invert_rows</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">perm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_invert_rows" title="Link to this definition">¶</a><br /></dt>
<dd><p>Swaps rows <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-</span> <span class="pre">i</span></code> of <code class="docutils literal notranslate"><span class="pre">mat</span></code> for <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">r/2</span></code>, where
<code class="docutils literal notranslate"><span class="pre">r</span></code> is the number of rows of <code class="docutils literal notranslate"><span class="pre">mat</span></code>. If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the
permutation of the rows will also be applied to <code class="docutils literal notranslate"><span class="pre">perm</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_invert_cols">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_invert_cols</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">perm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_invert_cols" title="Link to this definition">¶</a><br /></dt>
<dd><p>Swaps columns <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">-</span> <span class="pre">i</span></code> of <code class="docutils literal notranslate"><span class="pre">mat</span></code> for <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">c/2</span></code>, where
<code class="docutils literal notranslate"><span class="pre">c</span></code> is the number of columns of <code class="docutils literal notranslate"><span class="pre">mat</span></code>. If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the
permutation of the columns will also be applied to <code class="docutils literal notranslate"><span class="pre">perm</span></code>.</p>
</dd></dl>

</section>
<section id="window">
<h2>Window<a class="headerlink" href="#window" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_window_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_window_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">window</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c1</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">r2</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_window_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initializes the matrix <code class="docutils literal notranslate"><span class="pre">window</span></code> to be an <code class="docutils literal notranslate"><span class="pre">r2</span> <span class="pre">-</span> <span class="pre">r1</span></code> by
<code class="docutils literal notranslate"><span class="pre">c2</span> <span class="pre">-</span> <span class="pre">c1</span></code> submatrix of <code class="docutils literal notranslate"><span class="pre">mat</span></code> whose <code class="docutils literal notranslate"><span class="pre">(0,0)</span></code> entry
is the <code class="docutils literal notranslate"><span class="pre">(r1,</span> <span class="pre">c1)</span></code> entry of <code class="docutils literal notranslate"><span class="pre">mat</span></code>. The memory for the
elements of <code class="docutils literal notranslate"><span class="pre">window</span></code> is shared with <code class="docutils literal notranslate"><span class="pre">mat</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_window_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_window_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">window</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_window_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears the matrix <code class="docutils literal notranslate"><span class="pre">window</span></code> and releases any memory that it
uses. Note that the memory to the underlying matrix that
<code class="docutils literal notranslate"><span class="pre">window</span></code> points to is not freed.</p>
</dd></dl>

</section>
<section id="random-matrix-generation">
<h2>Random matrix generation<a class="headerlink" href="#random-matrix-generation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randbits">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randbits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randbits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the entries of <code class="docutils literal notranslate"><span class="pre">mat</span></code> to random signed integers whose absolute
values have the given number of binary bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randtest">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randtest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the entries of <code class="docutils literal notranslate"><span class="pre">mat</span></code> to random signed integers whose
absolute values have a random number of bits up to the given number
of bits inclusive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randintrel">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randintrel</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randintrel" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">mat</span></code> to be a random <em>integer relations</em> matrix, with
signed entries up to the given number of bits.</p>
<p>The number of columns of <code class="docutils literal notranslate"><span class="pre">mat</span></code> must be equal to one more than
the number of rows. The format of the matrix is a set of random integers
in the left hand column and an identity matrix in the remaining square
submatrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randsimdioph">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randsimdioph</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randsimdioph" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">mat</span></code> to a random <em>simultaneous diophantine</em> matrix.</p>
<p>The matrix must be square. The top left entry is set to <code class="docutils literal notranslate"><span class="pre">2^bits2</span></code>.
The remainder of that row is then set to signed random integers of the
given number of binary bits. The remainder of the first column is zero.
Running down the rest of the diagonal are the values <code class="docutils literal notranslate"><span class="pre">2^bits</span></code> with
all remaining entries zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randntrulike">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randntrulike</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randntrulike" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets a square matrix <code class="docutils literal notranslate"><span class="pre">mat</span></code> of even dimension to a random
<em>NTRU like</em> matrix.</p>
<p>The matrix is broken into four square submatrices. The top left submatrix
is set to the identity. The bottom left submatrix is set to the zero
matrix. The bottom right submatrix is set to <span class="math notranslate nohighlight">\(q\)</span> times the identity matrix.
Finally the top right submatrix has the following format. A random vector
<span class="math notranslate nohighlight">\(h\)</span> of length <span class="math notranslate nohighlight">\(r/2\)</span> is created, with random signed entries of the given
number of bits. Then entry <span class="math notranslate nohighlight">\((i, j)\)</span> of the submatrix is set to
<span class="math notranslate nohighlight">\(h[i + j \bmod{r/2}]\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randntrulike2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randntrulike2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randntrulike2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets a square matrix <code class="docutils literal notranslate"><span class="pre">mat</span></code> of even dimension to a random
<em>NTRU like</em> matrix.</p>
<p>The matrix is broken into four square submatrices. The top left submatrix
is set to <span class="math notranslate nohighlight">\(q\)</span> times the identity matrix. The top right submatrix is set to
the zero matrix. The bottom right submatrix is set to the identity matrix.
Finally the bottom left submatrix has the following format. A random vector
<span class="math notranslate nohighlight">\(h\)</span> of length <span class="math notranslate nohighlight">\(r/2\)</span> is created, with random signed entries of the given
number of bits. Then entry <span class="math notranslate nohighlight">\((i, j)\)</span> of the submatrix is set to
<span class="math notranslate nohighlight">\(h[i + j \bmod{r/2}]\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randajtai">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randajtai</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">alpha</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randajtai" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets a square matrix <code class="docutils literal notranslate"><span class="pre">mat</span></code> to a random <em>ajtai</em> matrix.
The diagonal entries <span class="math notranslate nohighlight">\((i, i)\)</span> are set to a random entry in the range
<span class="math notranslate nohighlight">\([1, 2^{b-1}]\)</span> inclusive where <span class="math notranslate nohighlight">\(b = \lfloor(2 r - i)^\alpha\rfloor\)</span> for some
double parameter <span class="math notranslate nohighlight">\(\alpha\)</span>. The entries below the diagonal in column <span class="math notranslate nohighlight">\(i\)</span>
are set to a random entry in the range <span class="math notranslate nohighlight">\((-2^b + 1, 2^b - 1)\)</span> whilst the
entries to the right of the diagonal in row <span class="math notranslate nohighlight">\(i\)</span> are set to zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randpermdiag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randpermdiag</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">diag</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randpermdiag" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">mat</span></code> to a random permutation of the rows and columns of a
given diagonal matrix. The diagonal matrix is specified in the form of
an array of the <span class="math notranslate nohighlight">\(n\)</span> initial entries on the main diagonal.</p>
<p>The return value is <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(1\)</span> depending on whether the permutation is
even or odd.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randrank">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randrank</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">rank</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randrank" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">mat</span></code> to a random sparse matrix with the given rank,
having exactly as many non-zero elements as the rank, with the
nonzero elements being random integers of the given bit size.</p>
<p>The matrix can be transformed into a dense matrix with unchanged
rank by subsequently calling <a class="reference internal" href="#c.fmpz_mat_randops" title="fmpz_mat_randops"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_randops()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randdet">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randdet</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">det</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randdet" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">mat</span></code> to a random sparse matrix with minimal number of
nonzero entries such that its determinant has the given value.</p>
<p>Note that the matrix will be zero if <code class="docutils literal notranslate"><span class="pre">det</span></code> is zero.
In order to generate a non-zero singular matrix, the function
<a class="reference internal" href="#c.fmpz_mat_randrank" title="fmpz_mat_randrank"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_randrank()</span></code></a> can be used.</p>
<p>The matrix can be transformed into a dense matrix with unchanged
determinant by subsequently calling <a class="reference internal" href="#c.fmpz_mat_randops" title="fmpz_mat_randops"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_randops()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_randops">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_randops</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">count</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_randops" title="Link to this definition">¶</a><br /></dt>
<dd><p>Randomises <code class="docutils literal notranslate"><span class="pre">mat</span></code> by performing elementary row or column operations.
More precisely, at most <code class="docutils literal notranslate"><span class="pre">count</span></code> random additions or subtractions of
distinct rows and columns will be performed. This leaves the rank
(and for square matrices, the determinant) unchanged.</p>
</dd></dl>

</section>
<section id="input-and-output">
<h2>Input and output<a class="headerlink" href="#input-and-output" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_fprint">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_fprint</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_fprint" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the given matrix to the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>.  The format is
the number of rows, a space, the number of columns, two spaces, then
a space separated list of coefficients, one row after the other.</p>
<p>In case of success, returns a positive value;  otherwise, returns
a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_fprint_pretty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_fprint_pretty</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_fprint_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the given matrix to the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>.  The format is an
opening square bracket, then on each line a row of the matrix, followed
by a closing square bracket. Each row is written as an opening square
bracket followed by a space separated list of coefficients followed
by a closing square bracket.</p>
<p>In case of success, returns a positive value;  otherwise, returns
a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_print">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_print</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the given matrix to the stream <code class="docutils literal notranslate"><span class="pre">stdout</span></code>.  For further
details, see <a class="reference internal" href="#c.fmpz_mat_fprint" title="fmpz_mat_fprint"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_fprint()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_print_pretty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_print_pretty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_print_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the given matrix to <code class="docutils literal notranslate"><span class="pre">stdout</span></code>.  For further details,
see <a class="reference internal" href="#c.fmpz_mat_fprint_pretty" title="fmpz_mat_fprint_pretty"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_fprint_pretty()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_fread">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_fread</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_fread" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a matrix from the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>, storing the result
in <code class="docutils literal notranslate"><span class="pre">mat</span></code>.  The expected format is the number of rows, a
space, the number of columns, two spaces, then a space separated
list of coefficients, one row after the other.</p>
<p>In case of success, returns a positive number.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_read">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_read</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a matrix from <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, storing the result
in <code class="docutils literal notranslate"><span class="pre">mat</span></code>.</p>
<p>In case of success, returns a positive number.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

</section>
<section id="comparison">
<h2>Comparison<a class="headerlink" href="#comparison" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_equal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_equal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_equal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a non-zero value if <code class="docutils literal notranslate"><span class="pre">mat1</span></code> and <code class="docutils literal notranslate"><span class="pre">mat2</span></code> have
the same dimensions and entries, and zero otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_zero">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a non-zero value if all entries <code class="docutils literal notranslate"><span class="pre">mat</span></code> are zero, and
otherwise returns zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_one">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_one</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a non-zero value if <code class="docutils literal notranslate"><span class="pre">mat</span></code> is the unit matrix or the truncation
of a unit matrix, and otherwise returns zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_empty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_empty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a non-zero value if the number of rows or the number of
columns in <code class="docutils literal notranslate"><span class="pre">mat</span></code> is zero, and otherwise returns
zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_square">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_square</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_square" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a non-zero value if the number of rows is equal to the
number of columns in <code class="docutils literal notranslate"><span class="pre">mat</span></code>, and otherwise returns zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_zero_row">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_zero_row</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_zero_row" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a non-zero value if row <span class="math notranslate nohighlight">\(i\)</span> of <code class="docutils literal notranslate"><span class="pre">mat</span></code> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_equal_col">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_equal_col</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">M</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_equal_col" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if columns <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span> of the matrix <span class="math notranslate nohighlight">\(M\)</span> are equal, otherwise
returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_equal_row">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_equal_row</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">M</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_equal_row" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if rows <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span> of the matrix <span class="math notranslate nohighlight">\(M\)</span> are equal, otherwise
returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

</section>
<section id="transpose">
<h2>Transpose<a class="headerlink" href="#transpose" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_transpose">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_transpose</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_transpose" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(B\)</span> to <span class="math notranslate nohighlight">\(A^T\)</span>, the transpose of <span class="math notranslate nohighlight">\(A\)</span>. Dimensions must be compatible.
Aliasing is allowed for square matrices.</p>
</dd></dl>

</section>
<section id="concatenate">
<h2>Concatenate<a class="headerlink" href="#concatenate" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_concat_vertical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_concat_vertical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_concat_vertical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to vertical concatenation of (<code class="docutils literal notranslate"><span class="pre">mat1</span></code>, <code class="docutils literal notranslate"><span class="pre">mat2</span></code>)
in that order. Matrix dimensions: <code class="docutils literal notranslate"><span class="pre">mat1</span></code>: <span class="math notranslate nohighlight">\(m \times n\)</span>,
<code class="docutils literal notranslate"><span class="pre">mat2</span></code>: <span class="math notranslate nohighlight">\(k \times n\)</span>, <code class="docutils literal notranslate"><span class="pre">res</span></code>: <span class="math notranslate nohighlight">\((m + k) \times n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_concat_horizontal">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_concat_horizontal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_concat_horizontal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to horizontal concatenation of (<code class="docutils literal notranslate"><span class="pre">mat1</span></code>, <code class="docutils literal notranslate"><span class="pre">mat2</span></code>)
in that order. Matrix dimensions: <code class="docutils literal notranslate"><span class="pre">mat1</span></code>: <span class="math notranslate nohighlight">\(m \times n\)</span>,
<code class="docutils literal notranslate"><span class="pre">mat2</span></code>: <span class="math notranslate nohighlight">\(m \times k\)</span>, <code class="docutils literal notranslate"><span class="pre">res</span></code>: <span class="math notranslate nohighlight">\(m \times (n + k)\)</span>.</p>
</dd></dl>

</section>
<section id="modular-reduction-and-reconstruction">
<h2>Modular reduction and reconstruction<a class="headerlink" href="#modular-reduction-and-reconstruction" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_get_nmod_mat">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_get_nmod_mat</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Amod</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_get_nmod_mat" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the entries of <code class="docutils literal notranslate"><span class="pre">Amod</span></code> to the entries of <code class="docutils literal notranslate"><span class="pre">A</span></code> reduced
by the modulus of <code class="docutils literal notranslate"><span class="pre">Amod</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_set_nmod_mat">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_set_nmod_mat</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Amod</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_set_nmod_mat" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the entries of <code class="docutils literal notranslate"><span class="pre">Amod</span></code> to the residues in <code class="docutils literal notranslate"><span class="pre">Amod</span></code>,
normalised to the interval <span class="math notranslate nohighlight">\(-m/2 &lt;= r &lt; m/2\)</span> where <span class="math notranslate nohighlight">\(m\)</span> is the modulus.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_set_nmod_mat_unsigned">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_set_nmod_mat_unsigned</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Amod</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_set_nmod_mat_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the entries of <code class="docutils literal notranslate"><span class="pre">Amod</span></code> to the residues in <code class="docutils literal notranslate"><span class="pre">Amod</span></code>,
normalised to the interval <span class="math notranslate nohighlight">\(0 &lt;= r &lt; m\)</span> where <span class="math notranslate nohighlight">\(m\)</span> is the modulus.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_CRT_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_CRT_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat2</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_CRT_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">mat1</span></code> with entries modulo <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">mat2</span></code>
with modulus <span class="math notranslate nohighlight">\(n\)</span>, sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the CRT reconstruction modulo <span class="math notranslate nohighlight">\(mn\)</span>
with entries satisfying <span class="math notranslate nohighlight">\(-mn/2 &lt;= c &lt; mn/2\)</span> (if sign = 1)
or <span class="math notranslate nohighlight">\(0 &lt;= c &lt; mn\)</span> (if sign = 0).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_multi_mod_ui_precomp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_multi_mod_ui_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">residues</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nres</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_comb_t</span></span><span class="w"> </span><span class="n"><span class="pre">comb</span></span>, <span class="n"><span class="pre">fmpz_comb_temp_t</span></span><span class="w"> </span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_multi_mod_ui_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets each of the <code class="docutils literal notranslate"><span class="pre">nres</span></code> matrices in <code class="docutils literal notranslate"><span class="pre">residues</span></code> to <code class="docutils literal notranslate"><span class="pre">mat</span></code> reduced modulo
the modulus of the respective matrix, given precomputed <code class="docutils literal notranslate"><span class="pre">comb</span></code> and
<code class="docutils literal notranslate"><span class="pre">comb_temp</span></code> structures.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">fmpz.h</span></code> must be included <strong>before</strong> <code class="docutils literal notranslate"><span class="pre">fmpz_mat.h</span></code> in order for
this function to be declared.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_multi_mod_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_multi_mod_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">residues</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nres</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_multi_mod_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets each of the <code class="docutils literal notranslate"><span class="pre">nres</span></code> matrices in <code class="docutils literal notranslate"><span class="pre">residues</span></code> to <code class="docutils literal notranslate"><span class="pre">mat</span></code>
reduced modulo the modulus of the respective matrix.</p>
<p>This function is provided for convenience purposes.
For reducing or reconstructing multiple integer matrices over the same
set of moduli, it is faster to use <code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_mod_precomp</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_multi_CRT_ui_precomp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_multi_CRT_ui_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">residues</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nres</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_comb_t</span></span><span class="w"> </span><span class="n"><span class="pre">comb</span></span>, <span class="n"><span class="pre">fmpz_comb_temp_t</span></span><span class="w"> </span><span class="n"><span class="pre">temp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_multi_CRT_ui_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reconstructs <code class="docutils literal notranslate"><span class="pre">mat</span></code> from its images modulo the <code class="docutils literal notranslate"><span class="pre">nres</span></code> matrices in
<code class="docutils literal notranslate"><span class="pre">residues</span></code>, given precomputed <code class="docutils literal notranslate"><span class="pre">comb</span></code> and <code class="docutils literal notranslate"><span class="pre">comb_temp</span></code> structures.</p>
<p>Note: <code class="docutils literal notranslate"><span class="pre">fmpz.h</span></code> must be included <strong>before</strong> <code class="docutils literal notranslate"><span class="pre">fmpz_mat.h</span></code> in order for
this function to be declared.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_multi_CRT_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_multi_CRT_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">residues</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">nres</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_multi_CRT_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reconstructs <code class="docutils literal notranslate"><span class="pre">mat</span></code> from its images modulo the <code class="docutils literal notranslate"><span class="pre">nres</span></code> matrices
in <code class="docutils literal notranslate"><span class="pre">residues</span></code>.</p>
<p>This function is provided for convenience purposes.
For reducing or reconstructing multiple integer matrices over the same
set of moduli, it is faster to use <a class="reference internal" href="#c.fmpz_mat_multi_CRT_ui_precomp" title="fmpz_mat_multi_CRT_ui_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_multi_CRT_ui_precomp()</span></code></a>.</p>
</dd></dl>

</section>
<section id="addition-and-subtraction">
<h2>Addition and subtraction<a class="headerlink" href="#addition-and-subtraction" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_add</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">C</span></code> to the elementwise sum <span class="math notranslate nohighlight">\(A + B\)</span>. All inputs must
be of the same size. Aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_sub</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">C</span></code> to the elementwise difference <span class="math notranslate nohighlight">\(A - B\)</span>. All inputs must
be of the same size. Aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_neg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_neg</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_neg" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">B</span></code> to the elementwise negation of <code class="docutils literal notranslate"><span class="pre">A</span></code>. Both inputs
must be of the same size. Aliasing is allowed.</p>
</dd></dl>

</section>
<section id="matrix-scalar-arithmetic">
<h2>Matrix-scalar arithmetic<a class="headerlink" href="#matrix-scalar-arithmetic" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_mul_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_mul_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_mul_si" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_mul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_mul_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_mul_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_mul_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_mul_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_mul_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">A*c</span></code> where <code class="docutils literal notranslate"><span class="pre">A</span></code> is an <code class="docutils literal notranslate"><span class="pre">fmpz_mat_t</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>
is a scalar respectively of type <code class="docutils literal notranslate"><span class="pre">slong</span></code>, <code class="docutils literal notranslate"><span class="pre">ulong</span></code>,
or <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code>. The dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must
be compatible.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_addmul_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_addmul_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_addmul_si" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_addmul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_addmul_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_addmul_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_addmul_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_addmul_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_addmul_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">+</span> <span class="pre">A*c</span></code> where <code class="docutils literal notranslate"><span class="pre">A</span></code> is an <code class="docutils literal notranslate"><span class="pre">fmpz_mat_t</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>
is a scalar respectively of type <code class="docutils literal notranslate"><span class="pre">slong</span></code>, <code class="docutils literal notranslate"><span class="pre">ulong</span></code>,
or <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code>. The dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must
be compatible.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_submul_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_submul_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_submul_si" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_submul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_submul_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_submul_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_submul_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_submul_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_submul_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">-</span> <span class="pre">A*c</span></code> where <code class="docutils literal notranslate"><span class="pre">A</span></code> is an <code class="docutils literal notranslate"><span class="pre">fmpz_mat_t</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>
is a scalar respectively of type <code class="docutils literal notranslate"><span class="pre">slong</span></code>, <code class="docutils literal notranslate"><span class="pre">ulong</span></code>,
or <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code>. The dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must
be compatible.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_addmul_nmod_mat_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_addmul_nmod_mat_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_addmul_nmod_mat_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_addmul_nmod_mat_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_addmul_nmod_mat_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_addmul_nmod_mat_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">+</span> <span class="pre">A*c</span></code> where <code class="docutils literal notranslate"><span class="pre">A</span></code> is an <code class="docutils literal notranslate"><span class="pre">nmod_mat_t</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>
is a scalar respectively of type <code class="docutils literal notranslate"><span class="pre">ulong</span></code> or <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code>.
The dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must be compatible.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_divexact_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_divexact_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_divexact_si" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_divexact_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_divexact_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_divexact_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_divexact_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_divexact_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_divexact_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">/</span> <span class="pre">c</span></code>, where <code class="docutils literal notranslate"><span class="pre">B</span></code> is an <code class="docutils literal notranslate"><span class="pre">fmpz_mat_t</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>
is a scalar respectively of type <code class="docutils literal notranslate"><span class="pre">slong</span></code>, <code class="docutils literal notranslate"><span class="pre">ulong</span></code>,
or <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code>, which is assumed to divide all elements of
<code class="docutils literal notranslate"><span class="pre">B</span></code> exactly.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_mul_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_mul_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_mul_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the matrix <code class="docutils literal notranslate"><span class="pre">B</span></code> to the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, of the same dimensions,
multiplied by <span class="math notranslate nohighlight">\(2^{exp}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_tdiv_q_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_tdiv_q_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_tdiv_q_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the matrix <code class="docutils literal notranslate"><span class="pre">B</span></code> to the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, of the same dimensions,
divided by <span class="math notranslate nohighlight">\(2^{exp}\)</span>, rounding down towards zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_scalar_smod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_scalar_smod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">P</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_scalar_smod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the matrix <code class="docutils literal notranslate"><span class="pre">B</span></code> to the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, of the same dimensions,
with each entry reduced modulo <span class="math notranslate nohighlight">\(P\)</span> in the symmetric moduli system. We
require <span class="math notranslate nohighlight">\(P &gt; 0\)</span>.</p>
</dd></dl>

</section>
<section id="matrix-multiplication">
<h2>Matrix multiplication<a class="headerlink" href="#matrix-multiplication" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_mul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">C</span></code> to the matrix product <span class="math notranslate nohighlight">\(C = A B\)</span>. The matrices must have
compatible dimensions for matrix multiplication. Aliasing
is allowed.</p>
<p>This function automatically switches between classical and
multimodular multiplication, based on a heuristic comparison of
the dimensions and entry sizes.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_mul_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">C</span></code> to the matrix product <span class="math notranslate nohighlight">\(C = A B\)</span> computed using
classical matrix algorithm.</p>
<p>The matrices must have compatible dimensions for matrix multiplication.
No aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_mul_waksman">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul_waksman</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul_waksman" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">C</span></code> to the matrix product <span class="math notranslate nohighlight">\(C = A B\)</span> computed using
Waksman multiplication, which does only <span class="math notranslate nohighlight">\(n^3/2 + O(n^2)\)</span>
products, but many additions. This is good for small matrices
with large entries.</p>
<p>The matrices must have compatible dimensions for matrix multiplication.
No aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_mul_strassen">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul_strassen</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul_strassen" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(C = AB\)</span>. Dimensions must be compatible for matrix multiplication.
<span class="math notranslate nohighlight">\(C\)</span> is not allowed to be aliased with <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(B\)</span>. Uses Strassen
multiplication (the Strassen-Winograd variant).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_mul_multi_mod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_mul_multi_mod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_mul_multi_mod" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_mul_multi_mod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul_multi_mod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul_multi_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">C</span></code> to the matrix product <span class="math notranslate nohighlight">\(C = AB\)</span> computed using a multimodular
algorithm. <span class="math notranslate nohighlight">\(C\)</span> is computed modulo several small prime numbers
and reconstructed using the Chinese Remainder Theorem. This generally
becomes more efficient than classical multiplication for large matrices.</p>
<p>The absolute value of the elements of <span class="math notranslate nohighlight">\(C\)</span> should be <span class="math notranslate nohighlight">\(&lt; 2^{\text{bits}}\)</span>,
and <code class="docutils literal notranslate"><span class="pre">sign</span></code> should be <span class="math notranslate nohighlight">\(0\)</span> if the entries of <span class="math notranslate nohighlight">\(C\)</span> are known to be nonnegative
and <span class="math notranslate nohighlight">\(1\)</span> otherwise. The function
<a class="reference internal" href="#c.fmpz_mat_mul_multi_mod" title="fmpz_mat_mul_multi_mod"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_mul_multi_mod()</span></code></a> calculates a rigorous bound automatically.
If the default bound is too pessimistic, <a class="reference internal" href="#c._fmpz_mat_mul_multi_mod" title="_fmpz_mat_mul_multi_mod"><code class="xref c c-func docutils literal notranslate"><span class="pre">_fmpz_mat_mul_multi_mod()</span></code></a>
can be used with a custom bound.</p>
<p>The matrices must have compatible dimensions for matrix multiplication.
No aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_mul_blas">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul_blas</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul_blas" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tries to set <span class="math notranslate nohighlight">\(C = AB\)</span> using BLAS and returns <span class="math notranslate nohighlight">\(1\)</span> for success and <span class="math notranslate nohighlight">\(0\)</span> for failure.
Dimensions must be compatible for matrix multiplication. No aliasing is allowed.
This function currently will fail if the matrices are empty, their dimensions are too large, or their max bits size is over one million bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_mul_fft">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul_fft</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul_fft" title="Link to this definition">¶</a><br /></dt>
<dd><p>Aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_sqr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_sqr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_sqr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">B</span></code> to the square of the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, which must be
a square matrix. Aliasing is allowed.
The function calls <a class="reference internal" href="#c.fmpz_mat_mul" title="fmpz_mat_mul"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_mul()</span></code></a> for dimensions less than 12 and
calls <a class="reference internal" href="#c.fmpz_mat_sqr_bodrato" title="fmpz_mat_sqr_bodrato"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_sqr_bodrato()</span></code></a> for cases in which the latter is faster.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_sqr_bodrato">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_sqr_bodrato</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_sqr_bodrato" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">B</span></code> to the square of the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, which must be
a square matrix. Aliasing is allowed.
The Bodrato algorithm is described in <a class="reference internal" href="references.html#bodrato2010" id="id1"><span>[Bodrato2010]</span></a>.
It is highly efficient for squaring matrices which satisfy both the
following conditions: (a) large elements,  (b) dimensions less than 150.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_pow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_pow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_pow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">B</span></code> to the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> raised to the power <code class="docutils literal notranslate"><span class="pre">e</span></code>,
where <code class="docutils literal notranslate"><span class="pre">A</span></code> must be a square matrix. Aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_mul_small">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_mul_small</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_mul_small" title="Link to this definition">¶</a><br /></dt>
<dd><p>This internal function sets <span class="math notranslate nohighlight">\(C\)</span> to the matrix product <span class="math notranslate nohighlight">\(C = A B\)</span> computed
using classical matrix algorithm assuming that all entries of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>
are small, that is, have bits <span class="math notranslate nohighlight">\(\le FLINT\_BITS - 2\)</span>. No aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_mul_double_word">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_mul_double_word</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_mul_double_word" title="Link to this definition">¶</a><br /></dt>
<dd><dl class="simple">
<dt>This function is only for internal use and assumes that either:</dt><dd><ul class="simple">
<li><p>the entries of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are all nonnegative and strictly less than <span class="math notranslate nohighlight">\(2^{2*FLINT\_BITS}\)</span>, or</p></li>
<li><p>the entries of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are all strictly less than <span class="math notranslate nohighlight">\(2^{2*FLINT\_BITS - 1}\)</span> in absolute value.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_mul_fmpz_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul_fmpz_vec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">blen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul_fmpz_vec" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_mul_fmpz_vec_ptr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_mul_fmpz_vec_ptr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">blen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_mul_fmpz_vec_ptr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute a matrix-vector product of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">(b,</span> <span class="pre">blen)</span></code> and store the result in <code class="docutils literal notranslate"><span class="pre">c</span></code>.
The vector <code class="docutils literal notranslate"><span class="pre">(b,</span> <span class="pre">blen)</span></code> is either truncated or zero-extended to the number of columns of <code class="docutils literal notranslate"><span class="pre">A</span></code>.
The number of entries written to <code class="docutils literal notranslate"><span class="pre">c</span></code> is always equal to the number of rows of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_fmpz_vec_mul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_fmpz_vec_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">alen</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_fmpz_vec_mul" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_fmpz_vec_mul_ptr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_fmpz_vec_mul_ptr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">alen</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_fmpz_vec_mul_ptr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute a vector-matrix product of <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">alen)</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> and store the result in <code class="docutils literal notranslate"><span class="pre">c</span></code>.
The vector <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">alen)</span></code> is either truncated or zero-extended to the number of rows of <code class="docutils literal notranslate"><span class="pre">B</span></code>.
The number of entries written to <code class="docutils literal notranslate"><span class="pre">c</span></code> is always equal to the number of columns of <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
</dd></dl>

</section>
<section id="inverse">
<h2>Inverse<a class="headerlink" href="#inverse" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_inv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_inv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Ainv</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_inv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets (<code class="docutils literal notranslate"><span class="pre">Ainv</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) to the inverse matrix of <code class="docutils literal notranslate"><span class="pre">A</span></code>.
Returns 1 if <code class="docutils literal notranslate"><span class="pre">A</span></code> is nonsingular and 0 if <code class="docutils literal notranslate"><span class="pre">A</span></code> is singular.
Aliasing of <code class="docutils literal notranslate"><span class="pre">Ainv</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed.</p>
<p>The denominator is not guaranteed to be minimal, but is guaranteed
to be a divisor of the determinant of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>This function uses a direct formula for matrices of size two or less,
and otherwise solves for the identity matrix using
fraction-free LU decomposition.</p>
</dd></dl>

</section>
<section id="kronecker-product">
<h2>Kronecker product<a class="headerlink" href="#kronecker-product" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_kronecker_product">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_kronecker_product</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">C</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_kronecker_product" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">C</span></code> to the Kronecker product of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
</dd></dl>

</section>
<section id="content">
<h2>Content<a class="headerlink" href="#content" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_content">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_content</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat_gcd</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_content" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">mat_gcd</span></code> as the gcd of all the elements of the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>.
Returns 0 if the matrix is empty.</p>
</dd></dl>

</section>
<section id="trace">
<h2>Trace<a class="headerlink" href="#trace" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_trace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_trace</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">trace</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_trace" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the trace of the matrix, i.e. the sum of the entries on
the main diagonal. The matrix is required to be square.</p>
</dd></dl>

</section>
<section id="determinant">
<h2>Determinant<a class="headerlink" href="#determinant" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">det</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">det</span></code> to the determinant of the square matrix <span class="math notranslate nohighlight">\(A\)</span>.
The matrix of dimension <span class="math notranslate nohighlight">\(0 \times 0\)</span> is defined to have determinant 1.</p>
<p>This function automatically chooses between <a class="reference internal" href="#c.fmpz_mat_det_cofactor" title="fmpz_mat_det_cofactor"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_det_cofactor()</span></code></a>,
<a class="reference internal" href="#c.fmpz_mat_det_bareiss" title="fmpz_mat_det_bareiss"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_det_bareiss()</span></code></a>, <a class="reference internal" href="#c.fmpz_mat_det_modular" title="fmpz_mat_det_modular"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_det_modular()</span></code></a> and
<a class="reference internal" href="#c.fmpz_mat_det_modular_accelerated" title="fmpz_mat_det_modular_accelerated"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_det_modular_accelerated()</span></code></a>
(with <code class="docutils literal notranslate"><span class="pre">proved</span></code> = 1), depending on the size of the matrix
and its entries.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det_cofactor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det_cofactor</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">det</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det_cofactor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">det</span></code> to the determinant of the square matrix <span class="math notranslate nohighlight">\(A\)</span>
computed using direct cofactor expansion. This function only
supports matrices up to size <span class="math notranslate nohighlight">\(4 \times 4\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det_bareiss">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det_bareiss</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">det</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det_bareiss" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">det</span></code> to the determinant of the square matrix <span class="math notranslate nohighlight">\(A\)</span>
computed using the Bareiss algorithm. A copy of the input matrix is
row reduced using fraction-free Gaussian elimination, and the
determinant is read off from the last element on the main
diagonal.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">det</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">det</span></code> to the determinant of the square matrix <span class="math notranslate nohighlight">\(A\)</span>
(if <code class="docutils literal notranslate"><span class="pre">proved</span></code> = 1), or a probabilistic value for the
determinant (<code class="docutils literal notranslate"><span class="pre">proved</span></code> = 0), computed using a multimodular
algorithm.</p>
<p>The determinant is computed modulo several small primes and
reconstructed using the Chinese Remainder Theorem.
With <code class="docutils literal notranslate"><span class="pre">proved</span></code> = 1, sufficiently many primes are chosen
to satisfy the bound computed by <code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_bound</span></code>.
With <code class="docutils literal notranslate"><span class="pre">proved</span></code> = 0, the determinant is considered determined
if it remains unchanged modulo several consecutive primes
(currently if their product exceeds <span class="math notranslate nohighlight">\(2^{100}\)</span>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det_modular_accelerated">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det_modular_accelerated</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">det</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det_modular_accelerated" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">det</span></code> to the determinant of the square matrix <span class="math notranslate nohighlight">\(A\)</span>
(if <code class="docutils literal notranslate"><span class="pre">proved</span></code> = 1), or a probabilistic value for the
determinant (<code class="docutils literal notranslate"><span class="pre">proved</span></code> = 0), computed using a multimodular
algorithm.</p>
<p>This function uses the same basic algorithm as <code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_modular</span></code>,
but instead of computing <span class="math notranslate nohighlight">\(\det(A)\)</span> directly, it generates a divisor <span class="math notranslate nohighlight">\(d\)</span>
of <span class="math notranslate nohighlight">\(\det(A)\)</span> and then computes <span class="math notranslate nohighlight">\(x = \det(A) / d\)</span> modulo several
small primes not dividing <span class="math notranslate nohighlight">\(d\)</span>. This typically accelerates the
computation by requiring fewer primes for large matrices, since <span class="math notranslate nohighlight">\(d\)</span>
with high probability will be nearly as large as the determinant.
This trick is described in <a class="reference internal" href="references.html#abbottbronsteinmulders1999" id="id2"><span>[AbbottBronsteinMulders1999]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det_modular_given_divisor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det_modular_given_divisor</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">det</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det_modular_given_divisor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a positive divisor <span class="math notranslate nohighlight">\(d\)</span> of <span class="math notranslate nohighlight">\(\det(A)\)</span>, sets <code class="docutils literal notranslate"><span class="pre">det</span></code> to the
determinant of the square matrix <span class="math notranslate nohighlight">\(A\)</span> (if <code class="docutils literal notranslate"><span class="pre">proved</span></code> = 1), or a
probabilistic value for the determinant (<code class="docutils literal notranslate"><span class="pre">proved</span></code> = 0), computed
using a multimodular algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det_bound">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det_bound</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bound</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det_bound" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">bound</span></code> to a nonnegative integer <span class="math notranslate nohighlight">\(B\)</span> such that
<span class="math notranslate nohighlight">\(|\det(A)| \le B\)</span>. Assumes <span class="math notranslate nohighlight">\(A\)</span> to be a square matrix.
The bound is computed from the Hadamard inequality
<span class="math notranslate nohighlight">\(|\det(A)| \le \prod \|a_i\|_2\)</span> where the product is taken
over the rows <span class="math notranslate nohighlight">\(a_i\)</span> of <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det_bound_nonzero">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det_bound_nonzero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bound</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det_bound_nonzero" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_bound()</span></code> but excludes zero columns. For use with
non-square matrices.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_det_divisor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_det_divisor</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_det_divisor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(d\)</span> to some positive divisor of the determinant of the given
square matrix <span class="math notranslate nohighlight">\(A\)</span>, if the determinant is nonzero. If <span class="math notranslate nohighlight">\(|\det(A)| = 0\)</span>,
<span class="math notranslate nohighlight">\(d\)</span> will always be set to zero.</p>
<p>A divisor is obtained by solving <span class="math notranslate nohighlight">\(Ax = b\)</span> for an arbitrarily chosen
right-hand side <span class="math notranslate nohighlight">\(b\)</span> using Dixon’s algorithm and computing the least
common multiple of the denominators in <span class="math notranslate nohighlight">\(x\)</span>. This yields a divisor <span class="math notranslate nohighlight">\(d\)</span>
such that <span class="math notranslate nohighlight">\(|\det(A)| / d\)</span> is tiny with very high probability.</p>
</dd></dl>

</section>
<section id="permanent">
<h2>Permanent<a class="headerlink" href="#permanent" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_permanent">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_permanent</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_permanent" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the permanent of the square matrix <em>A</em>, returning 1
on success. If the matrix is too large, returns 0.</p>
</dd></dl>

</section>
<section id="transforms">
<h2>Transforms<a class="headerlink" href="#transforms" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_similarity">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_similarity</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_similarity" title="Link to this definition">¶</a><br /></dt>
<dd><p>Applies a similarity transform to the <span class="math notranslate nohighlight">\(n\times n\)</span> matrix <span class="math notranslate nohighlight">\(M\)</span> in-place.</p>
<p>If <span class="math notranslate nohighlight">\(P\)</span> is the <span class="math notranslate nohighlight">\(n\times n\)</span> identity matrix the zero entries of whose row
<span class="math notranslate nohighlight">\(r\)</span> (<span class="math notranslate nohighlight">\(0\)</span>-indexed) have been replaced by <span class="math notranslate nohighlight">\(d\)</span>, this transform is equivalent
to <span class="math notranslate nohighlight">\(M = P^{-1}MP\)</span>.</p>
<p>Similarity transforms preserve the determinant, characteristic polynomial
and minimal polynomial.</p>
</dd></dl>

</section>
<section id="characteristic-polynomial">
<h2>Characteristic polynomial<a class="headerlink" href="#characteristic-polynomial" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_charpoly_berkowitz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_charpoly_berkowitz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_charpoly_berkowitz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(cp,</span> <span class="pre">n+1)</span></code> to the characteristic polynomial of
an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_charpoly_berkowitz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_charpoly_berkowitz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_poly.html#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_charpoly_berkowitz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the characteristic polynomial of length <span class="math notranslate nohighlight">\(n + 1\)</span> of
an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix. Uses an <span class="math notranslate nohighlight">\(O(n^4)\)</span> algorithm based on the
method of Berkowitz.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_charpoly_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_charpoly_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_charpoly_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(cp,</span> <span class="pre">n+1)</span></code> to the characteristic polynomial of
an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_charpoly_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_charpoly_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_poly.html#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_charpoly_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the characteristic polynomial of length <span class="math notranslate nohighlight">\(n + 1\)</span> of
an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix. Uses a modular method based on an <span class="math notranslate nohighlight">\(O(n^3)\)</span>
method over <span class="math notranslate nohighlight">\(\mathbb{Z}/n\mathbb{Z}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_charpoly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_charpoly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_charpoly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(cp,</span> <span class="pre">n+1)</span></code> to the characteristic polynomial of
an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_charpoly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_charpoly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_poly.html#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_charpoly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the characteristic polynomial of length <span class="math notranslate nohighlight">\(n + 1\)</span> of
an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix.</p>
</dd></dl>

</section>
<section id="minimal-polynomial">
<h2>Minimal polynomial<a class="headerlink" href="#minimal-polynomial" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_minpoly_modular">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_minpoly_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_minpoly_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(cp,</span> <span class="pre">n+1)</span></code> to the modular polynomial of
an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix and returns its length.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_minpoly_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_minpoly_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_poly.html#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_minpoly_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the minimal polynomial of an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix.
Uses a modular method based on an average time <span class="math notranslate nohighlight">\(O(n^3)\)</span>, worst case
<span class="math notranslate nohighlight">\(O(n^4)\)</span> method over <span class="math notranslate nohighlight">\(\mathbb{Z}/n\mathbb{Z}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_minpoly">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_minpoly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_minpoly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">cp</span></code> to the minimal polynomial of an <span class="math notranslate nohighlight">\(n \times n\)</span> square
matrix and returns its length.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_minpoly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_minpoly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_poly.html#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">cp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_minpoly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the minimal polynomial of an <span class="math notranslate nohighlight">\(n \times n\)</span> square matrix.</p>
</dd></dl>

</section>
<section id="rank">
<h2>Rank<a class="headerlink" href="#rank" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_rank">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_rank</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_rank" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the rank, that is, the number of linearly independent columns
(equivalently, rows), of <span class="math notranslate nohighlight">\(A\)</span>. The rank is computed by row reducing
a copy of <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd></dl>

</section>
<section id="column-partitioning">
<h2>Column partitioning<a class="headerlink" href="#column-partitioning" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_col_partition">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_col_partition</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">part</span></span>, <a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">M</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">short_circuit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_col_partition" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number <span class="math notranslate nohighlight">\(p\)</span> of distinct columns of <span class="math notranslate nohighlight">\(M\)</span> (or <span class="math notranslate nohighlight">\(0\)</span> if the flag
<code class="docutils literal notranslate"><span class="pre">short_circuit</span></code> is set and this number is greater than the number
of rows of <span class="math notranslate nohighlight">\(M\)</span>). The entries of array <code class="docutils literal notranslate"><span class="pre">part</span></code> are set to values in
<span class="math notranslate nohighlight">\([0, p)\)</span> such that two entries of part are equal iff the corresponding
columns of <span class="math notranslate nohighlight">\(M\)</span> are equal. This function is used in van Hoeij polynomial
factoring.</p>
</dd></dl>

</section>
<section id="nonsingular-solving">
<h2>Nonsingular solving<a class="headerlink" href="#nonsingular-solving" title="Link to this heading">¶</a></h2>
<p>The following functions allow solving matrix-matrix equations <span class="math notranslate nohighlight">\(AX = B\)</span>
where the system matrix <span class="math notranslate nohighlight">\(A\)</span> is square and has full rank. The solving
is implicitly done over the field of rational numbers: except
where otherwise noted, an integer matrix <span class="math notranslate nohighlight">\(\hat X\)</span> and a separate
denominator <span class="math notranslate nohighlight">\(d\)</span> (<code class="docutils literal notranslate"><span class="pre">den</span></code>) are computed such that <span class="math notranslate nohighlight">\(A(\hat X/d) = b\)</span>,
equivalently such that <span class="math notranslate nohighlight">\(A\hat X = bd\)</span> holds over the integers.
No guarantee is made that the numerators and denominator
are reduced to lowest terms, but the denominator is always guaranteed
to be a divisor of the determinant of <span class="math notranslate nohighlight">\(A\)</span>. If <span class="math notranslate nohighlight">\(A\)</span> is singular,
<code class="docutils literal notranslate"><span class="pre">den</span></code> will be set to zero and the elements of the solution
vector or matrix will have undefined values. No aliasing is
allowed between arguments.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_solve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_solve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_solve" title="Link to this definition">¶</a><br /></dt>
<dd><p>Solves the equation <span class="math notranslate nohighlight">\(AX = B\)</span> for nonsingular <span class="math notranslate nohighlight">\(A\)</span>. More precisely, computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span>.
Returns 1 if <span class="math notranslate nohighlight">\(A\)</span> is nonsingular and 0 if <span class="math notranslate nohighlight">\(A\)</span> is singular.
The computed denominator will not generally be minimal.</p>
<p>This function uses Cramer’s rule for small systems and
fraction-free LU decomposition followed by fraction-free forward
and back substitution for larger systems.</p>
<p>Note that for very large systems, it is faster to compute a modular
solution using <code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_dixon</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_solve_fflu">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_solve_fflu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_solve_fflu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Solves the equation <span class="math notranslate nohighlight">\(AX = B\)</span> for nonsingular <span class="math notranslate nohighlight">\(A\)</span>. More precisely, computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span>.
Returns 1 if <span class="math notranslate nohighlight">\(A\)</span> is nonsingular and 0 if <span class="math notranslate nohighlight">\(A\)</span> is singular.
The computed denominator will not generally be minimal.</p>
<p>Uses fraction-free LU decomposition followed by fraction-free
forward and back substitution.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_solve_fflu_precomp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_solve_fflu_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">perm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">FFLU</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_solve_fflu_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs fraction-free forward and back substitution given a precomputed
fraction-free LU decomposition and corresponding permutation. If no
impossible division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. This does not
mean the system has a solution, however a return value of <span class="math notranslate nohighlight">\(0\)</span> can only
occur if the system is insoluble.</p>
<p>If the return value is <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(r\)</span> is the rank of the matrix <span class="math notranslate nohighlight">\(A\)</span> whose FFLU
we have, then the first <span class="math notranslate nohighlight">\(r\)</span> rows of <span class="math notranslate nohighlight">\(p(A)y = p(b)d\)</span> hold, where <span class="math notranslate nohighlight">\(d\)</span> is the
denominator of the FFLU. The remaining rows must be checked by the caller.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_solve_cramer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_solve_cramer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_solve_cramer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Solves the equation <span class="math notranslate nohighlight">\(AX = B\)</span> for nonsingular <span class="math notranslate nohighlight">\(A\)</span>. More precisely, computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span>.
Returns 1 if <span class="math notranslate nohighlight">\(A\)</span> is nonsingular and 0 if <span class="math notranslate nohighlight">\(A\)</span> is singular.</p>
<p>Uses Cramer’s rule. Only systems of size up to <span class="math notranslate nohighlight">\(3 \times 3\)</span> are allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_solve_bound">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_solve_bound</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">D</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_solve_bound" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that <span class="math notranslate nohighlight">\(A\)</span> is nonsingular, computes integers <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(D\)</span>
such that the reduced numerators and denominators <span class="math notranslate nohighlight">\(n/d\)</span> in
<span class="math notranslate nohighlight">\(A^{-1} B\)</span> satisfy the bounds <span class="math notranslate nohighlight">\(0 \le |n| \le N\)</span> and <span class="math notranslate nohighlight">\(0 \le d \le D\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_solve_dixon">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_solve_dixon</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">M</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_solve_dixon" title="Link to this definition">¶</a><br /></dt>
<dd><p>Solves <span class="math notranslate nohighlight">\(AX = B\)</span> given a nonsingular square matrix <span class="math notranslate nohighlight">\(A\)</span> and a matrix <span class="math notranslate nohighlight">\(B\)</span> of
compatible dimensions, using a modular algorithm. In particular,
Dixon’s p-adic lifting algorithm is used (currently a non-adaptive version).
This is generally the preferred method for large dimensions.</p>
<p>More precisely, this function computes an integer <span class="math notranslate nohighlight">\(M\)</span> and an integer
matrix <span class="math notranslate nohighlight">\(X\)</span> such that <span class="math notranslate nohighlight">\(AX = B \bmod M\)</span> and such that all the reduced
numerators and denominators of the elements <span class="math notranslate nohighlight">\(x = p/q\)</span> in the full
solution satisfy <span class="math notranslate nohighlight">\(2|p|q &lt; M\)</span>. As such, the explicit rational solution
matrix can be recovered uniquely by passing the output of this
function to <code class="docutils literal notranslate"><span class="pre">fmpq_mat_set_fmpz_mat_mod</span></code>.</p>
<p>A nonzero value is returned if <span class="math notranslate nohighlight">\(A\)</span> is nonsingular. If <span class="math notranslate nohighlight">\(A\)</span> is singular,
zero is returned and the values of the output variables will be
undefined.</p>
<p>Aliasing between input and output matrices is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_mat_solve_dixon_den">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_mat_solve_dixon_den</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_mat.html#c.nmod_mat_t" title="nmod_mat_t"><span class="n"><span class="pre">nmod_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Ainv</span></span>, <a class="reference internal" href="flint.html#c.ulong" title="ulong"><span class="n"><span class="pre">ulong</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">D</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_mat_solve_dixon_den" title="Link to this definition">¶</a><br /></dt>
<dd><p>Solves the equation <span class="math notranslate nohighlight">\(AX = B\)</span> for nonsingular <span class="math notranslate nohighlight">\(A\)</span>. More precisely, computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span> using a
<code class="docutils literal notranslate"><span class="pre">p</span></code>-adic algorithm for the supplied prime <code class="docutils literal notranslate"><span class="pre">p</span></code>. The values <code class="docutils literal notranslate"><span class="pre">N</span></code> and
<code class="docutils literal notranslate"><span class="pre">D</span></code> are absolute value bounds for the numerator and denominator of the
solution.</p>
<p>Uses the Dixon lifting algorithm with early termination once the lifting
stabilises.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_solve_dixon_den">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_solve_dixon_den</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_solve_dixon_den" title="Link to this definition">¶</a><br /></dt>
<dd><p>Solves the equation <span class="math notranslate nohighlight">\(AX = B\)</span> for nonsingular <span class="math notranslate nohighlight">\(A\)</span>. More precisely, computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span>.
Returns 1 if <span class="math notranslate nohighlight">\(A\)</span> is nonsingular and 0 if <span class="math notranslate nohighlight">\(A\)</span> is singular.
The computed denominator will not generally be minimal.</p>
<p>Uses the Dixon lifting algorithm with early termination once the lifting
stabilises.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_solve_multi_mod_den">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_solve_multi_mod_den</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_solve_multi_mod_den" title="Link to this definition">¶</a><br /></dt>
<dd><p>Solves the equation <span class="math notranslate nohighlight">\(AX = B\)</span> for nonsingular <span class="math notranslate nohighlight">\(A\)</span>. More precisely, computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span>.
Returns 1 if <span class="math notranslate nohighlight">\(A\)</span> is nonsingular and 0 if <span class="math notranslate nohighlight">\(A\)</span> is singular.
The computed denominator will not generally be minimal.</p>
<p>Uses a Chinese remainder algorithm with early termination once the lifting
stabilises.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_can_solve_multi_mod_den">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_can_solve_multi_mod_den</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_can_solve_multi_mod_den" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if the system <span class="math notranslate nohighlight">\(AX = B\)</span> can be solved. If so it computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span>. The
computed denominator will not generally be minimal.</p>
<p>Uses a Chinese remainder algorithm.</p>
<p>Note that the matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> may have any shape as long as they have
the same number of rows.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_can_solve_fflu">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_can_solve_fflu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_can_solve_fflu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if the system <span class="math notranslate nohighlight">\(AX = B\)</span> can be solved. If so it computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span>. The
computed denominator will not generally be minimal.</p>
<p>Uses a fraction free LU decomposition algorithm.</p>
<p>Note that the matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> may have any shape as long as they have
the same number of rows.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_can_solve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_can_solve</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">X</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_can_solve" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if the system <span class="math notranslate nohighlight">\(AX = B\)</span> can be solved. If so it computes
(<code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) such that <span class="math notranslate nohighlight">\(AX = B \times \operatorname{den}\)</span>. The
computed denominator will not generally be minimal.</p>
<p>Note that the matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> may have any shape as long as they have
the same number of rows.</p>
</dd></dl>

</section>
<section id="row-reduction">
<h2>Row reduction<a class="headerlink" href="#row-reduction" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_find_pivot_any">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_find_pivot_any</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mat</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">start_row</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">end_row</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_find_pivot_any" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempts to find a pivot entry for row reduction.
Returns a row index <span class="math notranslate nohighlight">\(r\)</span> between <code class="docutils literal notranslate"><span class="pre">start_row</span></code> (inclusive) and
<code class="docutils literal notranslate"><span class="pre">stop_row</span></code> (exclusive) such that column <span class="math notranslate nohighlight">\(c\)</span> in <code class="docutils literal notranslate"><span class="pre">mat</span></code> has
a nonzero entry on row <span class="math notranslate nohighlight">\(r\)</span>, or returns -1 if no such entry exists.</p>
<p>This implementation simply chooses the first nonzero entry
it encounters. This is likely to be a nearly optimal choice if all
entries in the matrix have roughly the same size, but can lead to
unnecessary coefficient growth if the entries vary in size.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_fflu">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_fflu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">perm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">rank_check</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_fflu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Uses fraction-free Gaussian elimination to set (<code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) to a
fraction-free LU decomposition of <code class="docutils literal notranslate"><span class="pre">A</span></code> and returns the
rank of <code class="docutils literal notranslate"><span class="pre">A</span></code>. Aliasing of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> is allowed.</p>
<p>Pivot elements are chosen with <code class="docutils literal notranslate"><span class="pre">fmpz_mat_find_pivot_any</span></code>.
If <code class="docutils literal notranslate"><span class="pre">perm</span></code> is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the permutation of
rows in the matrix will also be applied to <code class="docutils literal notranslate"><span class="pre">perm</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">rank_check</span></code> is set, the function aborts and returns 0 if the
matrix is detected not to have full rank without completing the
elimination.</p>
<p>The denominator <code class="docutils literal notranslate"><span class="pre">den</span></code> is set to <span class="math notranslate nohighlight">\(\pm \operatorname{det}(S)\)</span> where
<span class="math notranslate nohighlight">\(S\)</span> is an appropriate submatrix of <span class="math notranslate nohighlight">\(A\)</span> (<span class="math notranslate nohighlight">\(S = A\)</span> if <span class="math notranslate nohighlight">\(A\)</span> is square)
and the sign is decided by the parity of the permutation. Note that the
determinant is not generally the minimal denominator.</p>
<p>The fraction-free LU decomposition is defined in <a class="reference internal" href="references.html#nakturwil1997" id="id3"><span>[NakTurWil1997]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_rref">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_rref</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_rref" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets (<code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) to the reduced row echelon form of <code class="docutils literal notranslate"><span class="pre">A</span></code>
and returns the rank of <code class="docutils literal notranslate"><span class="pre">A</span></code>. Aliasing of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>
is allowed.</p>
<p>The algorithm used chooses between <code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref_fflu</span></code> and
<code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref_mul</span></code> based on the dimensions of the input matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_rref_fflu">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_rref_fflu</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_rref_fflu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets (<code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) to the reduced row echelon form of <code class="docutils literal notranslate"><span class="pre">A</span></code>
and returns the rank of <code class="docutils literal notranslate"><span class="pre">A</span></code>. Aliasing of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>
is allowed.</p>
<p>The algorithm proceeds by first computing a row echelon form using
<code class="docutils literal notranslate"><span class="pre">fmpz_mat_fflu</span></code>. Letting the upper part of this matrix be
<span class="math notranslate nohighlight">\((U | V) P\)</span> where <span class="math notranslate nohighlight">\(U\)</span> is full rank upper triangular and <span class="math notranslate nohighlight">\(P\)</span> is a
permutation matrix, we obtain the rref by setting <span class="math notranslate nohighlight">\(V\)</span> to <span class="math notranslate nohighlight">\(U^{-1} V\)</span>
using back substitution. Scaling each completed row in the back
substitution to the denominator <code class="docutils literal notranslate"><span class="pre">den</span></code>, we avoid introducing
new fractions. This strategy is equivalent to the fraction-free
Gauss-Jordan elimination in <a class="reference internal" href="references.html#nakturwil1997" id="id4"><span>[NakTurWil1997]</span></a>, but faster since
only the part <span class="math notranslate nohighlight">\(V\)</span> corresponding to the null space has to be updated.</p>
<p>The denominator <code class="docutils literal notranslate"><span class="pre">den</span></code> is set to <span class="math notranslate nohighlight">\(\pm \operatorname{det}(S)\)</span> where
<span class="math notranslate nohighlight">\(S\)</span> is an appropriate submatrix of <span class="math notranslate nohighlight">\(A\)</span> (<span class="math notranslate nohighlight">\(S = A\)</span> if <span class="math notranslate nohighlight">\(A\)</span> is square).
Note that the determinant is not generally the minimal denominator.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_rref_mul">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_rref_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_rref_mul" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets (<code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">den</span></code>) to the reduced row echelon form of <code class="docutils literal notranslate"><span class="pre">A</span></code>
and returns the rank of <code class="docutils literal notranslate"><span class="pre">A</span></code>. Aliasing of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>
is allowed.</p>
<p>The algorithm works by computing the reduced row echelon form of <code class="docutils literal notranslate"><span class="pre">A</span></code>
modulo a prime <span class="math notranslate nohighlight">\(p\)</span> using <code class="docutils literal notranslate"><span class="pre">nmod_mat_rref</span></code>. The pivot columns and rows
of this matrix will then define a non-singular submatrix of <code class="docutils literal notranslate"><span class="pre">A</span></code>,
nonsingular solving and matrix multiplication can then be used to determine
the reduced row echelon form of the whole of <code class="docutils literal notranslate"><span class="pre">A</span></code>. This procedure is
described in <a class="reference internal" href="references.html#stein2007" id="id5"><span>[Stein2007]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_in_rref_with_rank">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_in_rref_with_rank</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">rank</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_in_rref_with_rank" title="Link to this definition">¶</a><br /></dt>
<dd><p>Checks that the matrix <span class="math notranslate nohighlight">\(A/den\)</span> is in reduced row echelon form of rank
<code class="docutils literal notranslate"><span class="pre">rank</span></code>, returns 1 if so and 0 otherwise.</p>
</dd></dl>

</section>
<section id="strong-echelon-form-and-howell-form">
<h2>Strong echelon form and Howell form<a class="headerlink" href="#strong-echelon-form-and-howell-form" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_strong_echelon_form_mod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_strong_echelon_form_mod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mod</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_strong_echelon_form_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Transforms <span class="math notranslate nohighlight">\(A\)</span> such that <span class="math notranslate nohighlight">\(A\)</span> modulo <code class="docutils literal notranslate"><span class="pre">mod</span></code> is the strong echelon form
of the input matrix modulo <code class="docutils literal notranslate"><span class="pre">mod</span></code>. The Howell form and the strong
echelon form are equal up to permutation of the rows, see <a class="reference internal" href="references.html#fiehof2014" id="id6"><span>[FieHof2014]</span></a>
for a definition of the strong echelon form and the algorithm used here.</p>
<p><span class="math notranslate nohighlight">\(A\)</span> must have at least as many rows as columns.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_howell_form_mod">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_howell_form_mod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mod</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_howell_form_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Transforms <span class="math notranslate nohighlight">\(A\)</span> such that <span class="math notranslate nohighlight">\(A\)</span> modulo <code class="docutils literal notranslate"><span class="pre">mod</span></code> is the Howell form of the
input matrix modulo <code class="docutils literal notranslate"><span class="pre">mod</span></code>.
For a definition of the Howell form see <a class="reference internal" href="references.html#stomul1998" id="id7"><span>[StoMul1998]</span></a>. The Howell form
is computed by first putting <span class="math notranslate nohighlight">\(A\)</span> into strong echelon form and then ordering
the rows.</p>
<p><span class="math notranslate nohighlight">\(A\)</span> must have at least as many rows as columns.</p>
</dd></dl>

</section>
<section id="nullspace">
<h2>Nullspace<a class="headerlink" href="#nullspace" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_nullspace">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_nullspace</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_nullspace" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes a basis for the right rational nullspace of <span class="math notranslate nohighlight">\(A\)</span> and returns
the dimension of the nullspace (or nullity). <span class="math notranslate nohighlight">\(B\)</span> is set to a matrix with
linearly independent columns and maximal rank such that <span class="math notranslate nohighlight">\(AB = 0\)</span>
(i.e. <span class="math notranslate nohighlight">\(Ab = 0\)</span> for each column <span class="math notranslate nohighlight">\(b\)</span> in <span class="math notranslate nohighlight">\(B\)</span>), and the rank of <span class="math notranslate nohighlight">\(B\)</span> is
returned.</p>
<p>In general, the entries in <span class="math notranslate nohighlight">\(B\)</span> will not be minimal: in particular,
the pivot entries in <span class="math notranslate nohighlight">\(B\)</span> will generally differ from unity.
<span class="math notranslate nohighlight">\(B\)</span> must be allocated with sufficient space to represent the result
(at most <span class="math notranslate nohighlight">\(n \times n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of columns of <span class="math notranslate nohighlight">\(A\)</span>).</p>
</dd></dl>

</section>
<section id="echelon-form">
<h2>Echelon form<a class="headerlink" href="#echelon-form" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_rref_fraction_free">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_rref_fraction_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">perm</span></span>, <a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">den</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_rref_fraction_free" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">B</span></code> and an integer <code class="docutils literal notranslate"><span class="pre">den</span></code> such that
<code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">/</span> <span class="pre">den</span></code> is the unique row reduced echelon form (RREF) of <code class="docutils literal notranslate"><span class="pre">A</span></code>
and returns the rank, i.e. the number of nonzero rows in <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed, with an in-place
computation being more efficient. The size of <code class="docutils literal notranslate"><span class="pre">B</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>The permutation order will be written to <code class="docutils literal notranslate"><span class="pre">perm</span></code> unless this
argument is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. That is, row <code class="docutils literal notranslate"><span class="pre">i</span></code> of the output matrix will
correspond to row <code class="docutils literal notranslate"><span class="pre">perm[i]</span></code> of the input matrix.</p>
<p>The denominator will always be a divisor of the determinant of (some
submatrix of) <span class="math notranslate nohighlight">\(A\)</span>, but is not guaranteed to be minimal or canonical in
any other sense.</p>
</dd></dl>

</section>
<section id="hermite-normal-form">
<h2>Hermite normal form<a class="headerlink" href="#hermite-normal-form" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hnf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hnf</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hnf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> such that <code class="docutils literal notranslate"><span class="pre">H</span></code> is the unique (row)
Hermite normal form of <code class="docutils literal notranslate"><span class="pre">A</span></code>. The algorithm used is selected from the
implementations in FLINT to be the one most likely to be optimal, based on
the characteristics of the input matrix.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">H</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hnf_transform">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hnf_transform</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hnf_transform" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> such that <code class="docutils literal notranslate"><span class="pre">H</span></code> is the unique (row)
Hermite normal form of <code class="docutils literal notranslate"><span class="pre">A</span></code> along with the transformation matrix
<code class="docutils literal notranslate"><span class="pre">U</span></code> such that <span class="math notranslate nohighlight">\(UA = H\)</span>. The algorithm used is selected from the
implementations in FLINT as per <code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf</span></code>.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">H</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">U</span></code> must be square of compatible
dimension (having the same number of rows as <code class="docutils literal notranslate"><span class="pre">A</span></code>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hnf_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hnf_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hnf_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> such that <code class="docutils literal notranslate"><span class="pre">H</span></code> is the unique (row)
Hermite normal form of <code class="docutils literal notranslate"><span class="pre">A</span></code>. The algorithm used is straightforward and
is described, for example, in [Algorithm 2.4.4] <a class="reference internal" href="references.html#coh1996" id="id8"><span>[Coh1996]</span></a>.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">H</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hnf_xgcd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hnf_xgcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hnf_xgcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> such that <code class="docutils literal notranslate"><span class="pre">H</span></code> is the unique (row)
Hermite normal form of <code class="docutils literal notranslate"><span class="pre">A</span></code>. The algorithm used is an improvement on the
basic algorithm and uses extended gcds to speed up computation, this method
is described, for example, in [Algorithm 2.4.5] <a class="reference internal" href="references.html#coh1996" id="id9"><span>[Coh1996]</span></a>.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">H</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hnf_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hnf_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">D</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hnf_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> such that <code class="docutils literal notranslate"><span class="pre">H</span></code> is the unique (row)
Hermite normal form of the <span class="math notranslate nohighlight">\(m\times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, where <code class="docutils literal notranslate"><span class="pre">A</span></code> is
assumed to be of rank <span class="math notranslate nohighlight">\(n\)</span> and <code class="docutils literal notranslate"><span class="pre">D</span></code> is known to be a positive multiple of
the determinant of the non-zero rows of <code class="docutils literal notranslate"><span class="pre">H</span></code>. The algorithm used here is
due to Domich, Kannan and Trotter <a class="reference internal" href="references.html#domkantro1987" id="id10"><span>[DomKanTro1987]</span></a> and is also described
in [Algorithm 2.4.8] <a class="reference internal" href="references.html#coh1996" id="id11"><span>[Coh1996]</span></a>.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">H</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hnf_modular_eldiv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hnf_modular_eldiv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">D</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hnf_modular_eldiv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Transforms the <span class="math notranslate nohighlight">\(m\times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> into Hermite normal form,
where <code class="docutils literal notranslate"><span class="pre">A</span></code> is assumed to be of rank <span class="math notranslate nohighlight">\(n\)</span> and <code class="docutils literal notranslate"><span class="pre">D</span></code> is known to be a
positive multiple of the largest elementary divisor of <code class="docutils literal notranslate"><span class="pre">A</span></code>.
The algorithm used here is described in <a class="reference internal" href="references.html#fiehof2014" id="id12"><span>[FieHof2014]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hnf_minors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hnf_minors</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hnf_minors" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> such that <code class="docutils literal notranslate"><span class="pre">H</span></code> is the unique (row)
Hermite normal form of the <span class="math notranslate nohighlight">\(m\times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, where <code class="docutils literal notranslate"><span class="pre">A</span></code> is
assumed to be of rank <span class="math notranslate nohighlight">\(n\)</span>. The algorithm used here is due to Kannan and
Bachem <a class="reference internal" href="references.html#kanbac1979" id="id13"><span>[KanBac1979]</span></a> and takes the principal minors to Hermite normal
form in turn.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">H</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hnf_pernet_stein">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hnf_pernet_stein</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hnf_pernet_stein" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> such that <code class="docutils literal notranslate"><span class="pre">H</span></code> is the unique (row)
Hermite normal form of the <span class="math notranslate nohighlight">\(m\times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>. The algorithm used
here is due to Pernet and Stein <a class="reference internal" href="references.html#pernetstein2010" id="id14"><span>[PernetStein2010]</span></a>.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">H</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_in_hnf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_in_hnf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_in_hnf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Checks that the given matrix is in Hermite normal form, returns 1 if so and
0 otherwise.</p>
</dd></dl>

</section>
<section id="smith-normal-form">
<h2>Smith normal form<a class="headerlink" href="#smith-normal-form" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_snf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_snf</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">S</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_snf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">S</span></code> such that <code class="docutils literal notranslate"><span class="pre">S</span></code> is the unique Smith
normal form of <code class="docutils literal notranslate"><span class="pre">A</span></code>. The algorithm used is selected from the
implementations in FLINT to be the one most likely to be optimal, based on
the characteristics of the input matrix.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">S</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_snf_diagonal">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_snf_diagonal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">S</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_snf_diagonal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">S</span></code> such that <code class="docutils literal notranslate"><span class="pre">S</span></code> is the unique Smith
normal form of the diagonal matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>. The algorithm used simply takes
gcds of pairs on the diagonal in turn until the Smith form is obtained.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">S</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_snf_kannan_bachem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_snf_kannan_bachem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">S</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_snf_kannan_bachem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">S</span></code> such that <code class="docutils literal notranslate"><span class="pre">S</span></code> is the unique Smith
normal form of the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>. The algorithm used here is due
to Kannan and Bachem <a class="reference internal" href="references.html#kanbac1979" id="id15"><span>[KanBac1979]</span></a></p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">S</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_snf_iliopoulos">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_snf_iliopoulos</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">S</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mod</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_snf_iliopoulos" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes an integer matrix <code class="docutils literal notranslate"><span class="pre">S</span></code> such that <code class="docutils literal notranslate"><span class="pre">S</span></code> is the unique Smith
normal form of the nonsingular <span class="math notranslate nohighlight">\(n\times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>. The algorithm
used is due to Iliopoulos <a class="reference internal" href="references.html#iliopoulos1989" id="id16"><span>[Iliopoulos1989]</span></a>.</p>
<p>Aliasing of <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> is allowed. The size of <code class="docutils literal notranslate"><span class="pre">S</span></code> must be
the same as that of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_in_snf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_in_snf</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_in_snf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Checks that the given matrix is in Smith normal form, returns 1 if so and 0
otherwise.</p>
</dd></dl>

</section>
<section id="special-matrices">
<h2>Special matrices<a class="headerlink" href="#special-matrices" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_gram">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_gram</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_gram" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">B</span></code> to the Gram matrix of the <span class="math notranslate nohighlight">\(m\)</span>-dimensional lattice <code class="docutils literal notranslate"><span class="pre">L</span></code> in
<span class="math notranslate nohighlight">\(n\)</span>-dimensional Euclidean space <span class="math notranslate nohighlight">\(R^n\)</span> spanned by the rows of
the <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>. Dimensions must be compatible.
<code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are allowed to be the same object if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a
square matrix.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_hadamard">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_hadamard</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_hadamard" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns nonzero iff <span class="math notranslate nohighlight">\(H\)</span> is a Hadamard matrix, meaning
that it is a square matrix, only has entries that are <span class="math notranslate nohighlight">\(\pm 1\)</span>,
and satisfies <span class="math notranslate nohighlight">\(H^T = n H^{-1}\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the matrix size.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_hadamard">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_hadamard</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_hadamard" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempts to set the matrix <span class="math notranslate nohighlight">\(H\)</span> to a Hadamard matrix, returning 1 if
successful and 0 if unsuccessful.</p>
<p>A Hadamard matrix of size <span class="math notranslate nohighlight">\(n\)</span> can only exist if <span class="math notranslate nohighlight">\(n\)</span> is 1, 2,
or a multiple of 4. It is not known whether a
Hadamard matrix exists for every size that is a multiple of 4.
This function uses the Paley construction, which
succeeds for all <span class="math notranslate nohighlight">\(n\)</span> of the form <span class="math notranslate nohighlight">\(n = 2^e\)</span> or <span class="math notranslate nohighlight">\(n = 2^e (q + 1)\)</span> where
<span class="math notranslate nohighlight">\(q\)</span> is an odd prime power. Orders <span class="math notranslate nohighlight">\(n\)</span> for which Hadamard matrices are
known to exist but for which this construction fails are
92, 116, 156, … (OEIS A046116).</p>
</dd></dl>

</section>
<section id="conversions">
<h2>Conversions<a class="headerlink" href="#conversions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_get_d_mat">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_get_d_mat</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_get_d_mat" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_get_d_mat_transpose">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_get_d_mat_transpose</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_get_d_mat_transpose" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the entries of <em>B</em> as doubles corresponding to the entries of <em>A</em> and
the transpose of <em>A</em>, respectively, rounding down towards zero if the latter
cannot be represented exactly. The return value is -1 if any entry of <code class="docutils literal notranslate"><span class="pre">A</span></code>
is too large to fit in the normal range of a double, and 0 otherwise.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires <code class="docutils literal notranslate"><span class="pre">d_mat.h</span></code> to be included before <code class="docutils literal notranslate"><span class="pre">fmpz_mat.h</span></code> in order to
declare these functions.</p>
</div>
</section>
<section id="cholesky-decomposition">
<h2>Cholesky Decomposition<a class="headerlink" href="#cholesky-decomposition" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_chol_d">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_chol_d</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_chol_d" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">R</span></code>, the Cholesky factor of a symmetric, positive definite
matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> using the Cholesky decomposition process. (Sets <code class="docutils literal notranslate"><span class="pre">R</span></code>
such that <span class="math notranslate nohighlight">\(A = RR^{T}\)</span> where <code class="docutils literal notranslate"><span class="pre">R</span></code> is a lower triangular matrix.)</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires <code class="docutils literal notranslate"><span class="pre">d_mat.h</span></code> to be included before <code class="docutils literal notranslate"><span class="pre">fmpz_mat.h</span></code> in order to
declare this function.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_spd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_spd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_spd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">A</span></code> is symmetric and positive definite (in particular
square).</p>
<p>We first attempt a numerical <span class="math notranslate nohighlight">\(LDL^T\)</span> decomposition using
<a class="reference internal" href="arb_mat.html#c.arb_mat_ldl" title="arb_mat_ldl"><code class="xref c c-func docutils literal notranslate"><span class="pre">arb_mat_ldl()</span></code></a>. If we cannot guarantee that <span class="math notranslate nohighlight">\(A\)</span> is positive definite,
we use an exact method instead, computing the characteristic polynomial of
<span class="math notranslate nohighlight">\(A\)</span> and applying Descartes’ rule of signs.</p>
</dd></dl>

</section>
<section id="lll">
<h2>LLL<a class="headerlink" href="#lll" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_reduced">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_reduced</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">delta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_reduced" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_is_reduced_gram">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_reduced_gram</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">delta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_reduced_gram" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a non-zero value if the basis <code class="docutils literal notranslate"><span class="pre">A</span></code> is LLL-reduced with factor
(<code class="docutils literal notranslate"><span class="pre">delta</span></code>, <code class="docutils literal notranslate"><span class="pre">eta</span></code>), and otherwise returns zero.
The second version assumes <code class="docutils literal notranslate"><span class="pre">A</span></code> is the Gram matrix of the basis.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_is_reduced_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_reduced_with_removal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">delta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">newd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_reduced_with_removal" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mat_is_reduced_gram_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_is_reduced_gram_with_removal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">delta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">newd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_is_reduced_gram_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a non-zero value if the basis <code class="docutils literal notranslate"><span class="pre">A</span></code> is LLL-reduced with factor
(<code class="docutils literal notranslate"><span class="pre">delta</span></code>, <code class="docutils literal notranslate"><span class="pre">eta</span></code>) for each of the first <code class="docutils literal notranslate"><span class="pre">newd</span></code> vectors and the squared
Gram-Schmidt length of each of the remaining <span class="math notranslate nohighlight">\(i\)</span>-th vectors
(where <span class="math notranslate nohighlight">\(i \ge\)</span> <code class="docutils literal notranslate"><span class="pre">newd</span></code>) is greater than <code class="docutils literal notranslate"><span class="pre">gs_B</span></code>, and otherwise returns zero.
The second version assumes <code class="docutils literal notranslate"><span class="pre">A</span></code> is the Gram matrix of the basis.</p>
</dd></dl>

</section>
<section id="classical-lll">
<h2>Classical LLL<a class="headerlink" href="#classical-lll" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_lll_original">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_lll_original</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delta</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">eta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_lll_original" title="Link to this definition">¶</a><br /></dt>
<dd><p>Takes a basis <span class="math notranslate nohighlight">\(x_1, x_2, \ldots, x_m\)</span> of the lattice <span class="math notranslate nohighlight">\(L \subset R^n\)</span> (as
the rows of a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>). The output is a (<code class="docutils literal notranslate"><span class="pre">delta</span></code>,
<code class="docutils literal notranslate"><span class="pre">eta</span></code>)-reduced basis <span class="math notranslate nohighlight">\(y_1, y_2, \ldots, y_m\)</span> of the lattice <span class="math notranslate nohighlight">\(L\)</span> (as
the rows of the same <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>).</p>
</dd></dl>

</section>
<section id="modified-lll">
<h2>Modified LLL<a class="headerlink" href="#modified-lll" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mat_lll_storjohann">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mat_lll_storjohann</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">delta</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">eta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mat_lll_storjohann" title="Link to this definition">¶</a><br /></dt>
<dd><p>Takes a basis <span class="math notranslate nohighlight">\(x_1, x_2, \ldots, x_m\)</span> of the lattice <span class="math notranslate nohighlight">\(L \subset R^n\)</span> (as
the rows of a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>). The output is an (<code class="docutils literal notranslate"><span class="pre">delta</span></code>,
<code class="docutils literal notranslate"><span class="pre">eta</span></code>)-reduced basis <span class="math notranslate nohighlight">\(y_1, y_2, \ldots, y_m\)</span> of the lattice <span class="math notranslate nohighlight">\(L\)</span> (as
the rows of the same <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>). Uses a modified version of
LLL, which has better complexity in terms of the lattice dimension,
introduced by Storjohann.</p>
<p>See “Faster Algorithms for Integer Lattice Basis Reduction.” Technical
Report 249. Zurich, Switzerland: Department Informatik, ETH. July 30,
1996.</p>
</dd></dl>

</section>
</section>

</main>

                  
<!-- #Article navigation -->
<nav class="my-8">
  <ul
    class="text-secondary-content flex justify-between gap-4"
  >
    
      <li class="flex flex-col gap-1">
        <span class="flex items-center text-xs font-light">
          <span class="icon-[prime--angle-left]"></span>
          Previous
        </span>
        <a
          class="hover:text-accent-content text-sm underline"
          href="fmpz_factor.html"
          title="Previous article"
          ><strong>fmpz_factor.h</strong> – integer factorisation</a
        >
      </li>
    
    
      <li class="flex flex-col gap-1 lg:items-end">
        <span class="flex items-center text-xs font-light">
          Next
          <span class="icon-[prime--angle-right]"></span>
        </span>
        <a
          class="hover:text-accent-content text-sm underline"
          href="fmpz_lll.html"
          title="Next article"
          ><strong>fmpz_lll.h</strong> – LLL reduction</a
        >
      </li>
    
  </ul>
</nav>
<!-- .#Article navigation -->
                  
<!-- #Article footer -->
<footer
  class="article-footer border-base-200 text-secondary-content/80 my-4 border-t pt-8 text-sm"
>
  <div class="flex flex-col justify-between gap-4 lg:flex-row">
    <div class="article-footer__left">
      
      
    </div>
    <div class="article-footer__right">
      
      
    </div>
  </div>
</footer>
<!-- .#Article footer -->
                </article>

                <!-- #Primary drawer (desktop) -->
                <nav
                  class="lg:sticky lg:top-[calc(var(--header-height)+var(--header-padding))] lg:h-[calc(100vh-var(--header-height)-calc(var(--header-padding)*2))] lg:overflow-y-auto scrollbar-overlay hidden lg:order-1 lg:block lg:w-2/12 lg:flex-none"
                >
                  


  <div class="global-toc">
    <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html"><strong>Building, testing and installing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="bug_reporting.html"><strong>Bug reporting</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing to FLINT</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html"><strong>Contributors</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html"><strong>Memory management</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="portability.html"><strong>Portability</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="threading.html"><strong>Threading</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flint.html"><strong>flint.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html"><strong>profiler.h</strong> – performance profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread_pool.html"><strong>thread_pool.h</strong> – thread pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpoly.html"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_vectors.html"><strong>machine_vectors.h</strong> – SIMD-accelerated operations on fixed-length vectors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generic rings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gr.html"><strong>gr.h</strong> – generic structures and their elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_implementing.html"><strong>gr.h (continued)</strong> – implementing rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_domains.html"><strong>gr.h (continued)</strong> – builtin domains and types</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_generic.html"><strong>gr_generic.h</strong> – basic algorithms and fallback implementations for generic elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_special.html"><strong>gr_special.h</strong> – special arithmetic and transcendental functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_vec.html"><strong>gr_vec.h</strong> – vectors over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mat.html"><strong>gr_mat.h</strong> – dense matrices over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_poly.html"><strong>gr_poly.h</strong> – dense univariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mpoly.html"><strong>gr_mpoly.h</strong> – sparse multivariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_series.html"><strong>gr_series.h</strong> – formal power series over generic rings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_generic.html"><strong>Generic rings</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ulong_extras.html"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz.html"><strong>fmpz.h</strong> – integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_vec.html"><strong>fmpz_vec.h</strong> – vectors of integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_factor.html"><strong>fmpz_factor.h</strong> – integer factorisation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>fmpz_mat.h</strong> – matrices over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_lll.html"><strong>fmpz_lll.h</strong> – LLL reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly.html"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_mat.html"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_factor.html"><strong>fmpz_poly_factor.h</strong> – factorisation of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly.html"><strong>fmpz_mpoly.h</strong> – multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_factor.html"><strong>fmpz_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="long_extras.html"><strong>long_extras.h</strong> – support functions for signed word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="longlong.html"><strong>longlong.h</strong> – support functions for multi-word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_extras.html"><strong>mpn_extras.h</strong> – support functions for limb arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="aprcl.html"><strong>aprcl.h</strong> – APRCL primality testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arith.html"><strong>arith.h</strong> – arithmetic and special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft_small.html"><strong>fft_small.h</strong> – FFT modulo word-size primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="qsieve.html"><strong>qsieve.h</strong> – Quadratic sieve</a></li>
<li class="toctree-l1"><a class="reference internal" href="radix.html"><strong>radix.h</strong> – multiprecision arithmetic in general radix</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index_integers.html"><strong>Integers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Rational numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fmpq.html"><strong>fmpq.h</strong> – rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_vec.html"><strong>fmpq_vec.h</strong> – vectors over rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mat.html"><strong>fmpq_mat.h</strong> – matrices over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_poly.html"><strong>fmpq_poly.h</strong> – univariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly_factor.html"><strong>fmpq_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly.html"><strong>fmpq_mpoly.h</strong> – multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_q.html"><strong>fmpz_poly_q.h</strong> – rational functions over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_q.html"><strong>fmpz_mpoly_q.h</strong> – multivariate rational functions over Q</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_rationals.html"><strong>Rational numbers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers mod n</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nmod.html"><strong>nmod.h</strong> – integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_vec.html"><strong>nmod_vec.h</strong> – vectors over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mat.html"><strong>nmod_mat.h</strong> – matrices over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly.html"><strong>nmod_poly.h</strong> – univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_mat.html"><strong>nmod_poly_mat.h</strong> – matrices of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_factor.html"><strong>nmod_poly_factor.h</strong> – factorisation of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly.html"><strong>nmod_mpoly.h</strong> – multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly_factor.html"><strong>nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_mod.html"><strong>mpn_mod.h</strong> – integers mod n (packed multi-word n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod.html"><strong>fmpz_mod.h</strong> – arithmetic modulo integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_vec.html"><strong>fmpz_mod_vec.h</strong> – vectors over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mat.html"><strong>fmpz_mod_mat.h</strong> – matrices over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly.html"><strong>fmpz_mod_poly.h</strong> – polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly_factor.html"><strong>fmpz_mod_poly_factor.h</strong> – factorisation of polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly.html"><strong>fmpz_mod_mpoly.h</strong> – polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_factor.html"><strong>fmpz_mod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_q.html"><strong>fmpz_mod_mpoly_q.h</strong> – multivariate rational functions over Z/mZ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers_mod.html"><strong>Integers mod n</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Groups and other structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="perm.html"><strong>perm.h</strong> – permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="qfb.html"><strong>qfb.h</strong> – binary quadratic forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dirichlet.html"><strong>dirichlet.h</strong> – Dirichlet characters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlog.html"><strong>dlog.h</strong> – discrete logarithms mod ulong primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="bool_mat.html"><strong>bool_mat.h</strong> – matrices over booleans</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Number fields and algebraic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nf.html"><strong>nf.h</strong> – number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="nf_elem.html"><strong>nf_elem.h</strong> – number field elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpzi.html"><strong>fmpzi.h</strong> – Gaussian integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qqbar.html"><strong>qqbar.h</strong> – algebraic numbers represented by minimal polynomials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Feature overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using ball arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Technical conventions and potential issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_arb.html">Arb example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="mag.html"><strong>mag.h</strong> – fixed-precision unsigned floating-point numbers for bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="nfloat.html"><strong>nfloat.h</strong> – packed floating-point numbers with n-word precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="arf.html"><strong>arf.h</strong> – arbitrary-precision floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acf.html"><strong>acf.h</strong> – complex floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb.html"><strong>arb.h</strong> – real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb.html"><strong>acb.h</strong> – complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_poly.html"><strong>arb_poly.h</strong> – polynomials over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_poly.html"><strong>acb_poly.h</strong> – polynomials over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fmpz_poly.html"><strong>arb_fmpz_poly.h</strong> – extra methods for integer polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dft.html"><strong>acb_dft.h</strong> – Discrete Fourier transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_mat.html"><strong>arb_mat.h</strong> – matrices over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_mat.html"><strong>acb_mat.h</strong> – matrices over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_hypgeom.html"><strong>acb_hypgeom.h</strong> – hypergeometric functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_hypgeom.html"><strong>arb_hypgeom.h</strong> – hypergeometric functions of real variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_elliptic.html"><strong>acb_elliptic.h</strong> – elliptic integrals and functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_modular.html"><strong>acb_modular.h</strong> – modular forms of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_theta.html"><strong>acb_theta.h</strong> – Riemann theta functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dirichlet.html"><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bernoulli.html"><strong>bernoulli.h</strong> – support for Bernoulli numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypgeom.html"><strong>hypgeom.h</strong> – support for hypergeometric series</a></li>
<li class="toctree-l1"><a class="reference internal" href="partitions.html"><strong>partitions.h</strong> – computation of the partition function</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_calc.html"><strong>arb_calc.h</strong> – calculus with real-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_calc.html"><strong>acb_calc.h</strong> – calculus with complex-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fpwrap.html"><strong>arb_fpwrap.h</strong> – floating-point wrappers of Arb mathematical functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_extras.html"><strong>fmpz_extras.h</strong> – extra methods for FLINT integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">General formulas and bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">Algorithms for mathematical constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma.html">Algorithms for the gamma function</a></li>
<li class="toctree-l1"><a class="reference internal" href="hurwitz.html">Algorithms for the Hurwitz zeta function</a></li>
<li class="toctree-l1"><a class="reference internal" href="polylogarithms.html">Algorithms for polylogarithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergeometric.html">Algorithms for hypergeometric functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="agm.html">Algorithms for the arithmetic-geometric mean</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_arb.html"><strong>Real and complex numbers (Arb)</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_calcium.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_calcium.html">Calcium example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="calcium.html"><strong>calcium.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca.html"><strong>ca.h</strong> – exact real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_vec.html"><strong>ca_vec.h</strong> – vectors of real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_poly.html"><strong>ca_poly.h</strong> – dense univariate polynomials over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_mat.html"><strong>ca_mat.h</strong> – matrices over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_ext.html"><strong>ca_ext.h</strong> – real and complex extension numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_field.html"><strong>ca_field.h</strong> – extension fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr.html"><strong>fexpr.h</strong> – flat-packed symbolic expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr_builtin.html"><strong>fexpr_builtin.h</strong> – builtin symbols</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite fields</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq.html"><strong>fq.h</strong> – finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default.html"><strong>fq_default.h</strong> – unified finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_vec.html"><strong>fq_vec.h</strong> – vectors over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_mat.html"><strong>fq_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_mat.html"><strong>fq_default_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly.html"><strong>fq_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly.html"><strong>fq_default_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly_factor.html"><strong>fq_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly_factor.html"><strong>fq_default_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_embed.html"><strong>fq_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod.html"><strong>fq_nmod.h</strong> – finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_vec.html"><strong>fq_nmod_vec.h</strong> – vectors over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mat.html"><strong>fq_nmod_mat.h</strong> – matrices over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly.html"><strong>fq_nmod_poly.h</strong> – univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly_factor.html"><strong>fq_nmod_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_embed.html"><strong>fq_nmod_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly.html"><strong>fq_nmod_mpoly.h</strong> – multivariate polynomials over finite fields of word-sized characteristic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly_factor.html"><strong>fq_nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over finite fields of word-sized characteristic</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_zech.html"><strong>fq_zech.h</strong> – finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_vec.html"><strong>fq_zech_vec.h</strong> – vectors over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_mat.html"><strong>fq_zech_mat.h</strong> – matrices over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly.html"><strong>fq_zech_poly.h</strong> – univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly_factor.html"><strong>fq_zech_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_embed.html"><strong>fq_zech_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">p-adic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="padic.html"><strong>padic.h</strong> – p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_poly.html"><strong>padic_poly.h</strong> – polynomials over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_mat.html"><strong>padic_mat.h</strong> – matrices over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qadic.html"><strong>qadic.h</strong> – unramified extensions over p-adic numbers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Floating-point support code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="double_extras.html"><strong>double_extras.h</strong> – support functions for double arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="double_interval.html"><strong>double_interval.h</strong> – double-precision interval arithmetic and helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_vec.html"><strong>d_vec.h</strong> – double precision vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_mat.html"><strong>d_mat.h</strong> – double precision matrices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_flint.html"><strong>flint_ctypes</strong> - Python interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Version history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="history.html">History and changes</a></li>
</ul>

  </div>

                </nav>
                <!-- .#Primary drawer (desktop) -->

                <!-- #Secondary drawer (desktop) -->
                <aside
                  class="lg:sticky lg:top-[calc(var(--header-height)+var(--header-padding))] lg:h-[calc(100vh-var(--header-height)-calc(var(--header-padding)*2))] lg:overflow-y-auto scrollbar-overlay hidden lg:order-3 lg:block lg:w-2/12 lg:flex-none"
                >
                  


  
    <div class="local-toc">
      <p class="local-toc__caption mt-0 mb-4 font-semibold uppercase">
        On this page
      </p>
      <ul>
<li><a class="reference internal" href="#"><strong>fmpz_mat.h</strong> – matrices over the integers</a><ul>
<li><a class="reference internal" href="#simple-example">Simple example</a></li>
<li><a class="reference internal" href="#types-macros-and-constants">Types, macros and constants</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_struct"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_struct</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_t"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_t</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-management">Memory management</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_init"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_init()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_clear"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_clear()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-assignment-and-manipulation">Basic assignment and manipulation</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_set"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_set()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_init_set"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_init_set()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_nrows"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_nrows()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_ncols"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_ncols()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_swap"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_swap()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_swap_entrywise"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_swap_entrywise()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_entry"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_entry()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_zero"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_zero()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_one"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_one()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_swap_rows"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_swap_rows()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_swap_cols"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_swap_cols()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_invert_rows"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_invert_rows()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_invert_cols"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_invert_cols()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#window">Window</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_window_init"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_window_init()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_window_clear"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_window_clear()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-matrix-generation">Random matrix generation</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_randbits"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randbits()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randtest"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randtest()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randintrel"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randintrel()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randsimdioph"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randsimdioph()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randntrulike"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randntrulike()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randntrulike2"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randntrulike2()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randajtai"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randajtai()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randpermdiag"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randpermdiag()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randrank"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randrank()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randdet"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randdet()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randops"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randops()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#input-and-output">Input and output</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_fprint"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fprint()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fprint_pretty"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fprint_pretty()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_print"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_print()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_print_pretty"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_print_pretty()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fread"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fread()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_read"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_read()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparison">Comparison</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_equal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_equal()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_zero"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_zero()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_one"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_one()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_empty"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_empty()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_square"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_square()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_zero_row"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_zero_row()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_equal_col"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_equal_col()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_equal_row"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_equal_row()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#transpose">Transpose</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_transpose"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_transpose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#concatenate">Concatenate</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_concat_vertical"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_concat_vertical()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_concat_horizontal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_concat_horizontal()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modular-reduction-and-reconstruction">Modular reduction and reconstruction</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_get_nmod_mat"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_get_nmod_mat()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_set_nmod_mat"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_set_nmod_mat()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_set_nmod_mat_unsigned"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_set_nmod_mat_unsigned()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_CRT_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_CRT_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_multi_mod_ui_precomp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_mod_ui_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_multi_mod_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_mod_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_multi_CRT_ui_precomp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_CRT_ui_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_multi_CRT_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_CRT_ui()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#addition-and-subtraction">Addition and subtraction</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_add"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_add()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_sub"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_sub()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_neg"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_neg()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-scalar-arithmetic">Matrix-scalar arithmetic</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_mul_si"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_mul_si()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_mul_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_mul_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_mul_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_mul_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_si"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_si()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_submul_si"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_submul_si()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_submul_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_submul_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_submul_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_submul_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_nmod_mat_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_nmod_mat_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_nmod_mat_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_nmod_mat_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_divexact_si"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_divexact_si()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_divexact_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_divexact_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_divexact_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_divexact_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_mul_2exp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_mul_2exp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_tdiv_q_2exp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_tdiv_q_2exp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_smod"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_smod()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-multiplication">Matrix multiplication</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_mul"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_classical"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_classical()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_waksman"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_waksman()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_strassen"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_strassen()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_mul_multi_mod"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_mul_multi_mod()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_multi_mod"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_multi_mod()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_blas"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_blas()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_fft"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_fft()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_sqr"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_sqr()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_sqr_bodrato"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_sqr_bodrato()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_pow"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_pow()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_mul_small"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_mul_small()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_mul_double_word"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_mul_double_word()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_fmpz_vec"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_fmpz_vec()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_fmpz_vec_ptr"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_fmpz_vec_ptr()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fmpz_vec_mul"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fmpz_vec_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fmpz_vec_mul_ptr"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fmpz_vec_mul_ptr()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#inverse">Inverse</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_inv"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_inv()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#kronecker-product">Kronecker product</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_kronecker_product"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_kronecker_product()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#content">Content</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_content"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_content()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trace">Trace</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_trace"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_trace()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#determinant">Determinant</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_det"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_cofactor"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_cofactor()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_bareiss"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_bareiss()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_modular"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_modular()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_modular_accelerated"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_modular_accelerated()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_modular_given_divisor"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_modular_given_divisor()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_bound"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_bound()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_bound_nonzero"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_bound_nonzero()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_divisor"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_divisor()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#permanent">Permanent</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_permanent"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_permanent()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#transforms">Transforms</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_similarity"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_similarity()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#characteristic-polynomial">Characteristic polynomial</a><ul>
<li><a class="reference internal" href="#c._fmpz_mat_charpoly_berkowitz"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_charpoly_berkowitz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_charpoly_berkowitz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_charpoly_berkowitz()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_charpoly_modular"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_charpoly_modular()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_charpoly_modular"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_charpoly_modular()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_charpoly"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_charpoly()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_charpoly"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_charpoly()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#minimal-polynomial">Minimal polynomial</a><ul>
<li><a class="reference internal" href="#c._fmpz_mat_minpoly_modular"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_minpoly_modular()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_minpoly_modular"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_minpoly_modular()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_minpoly"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_minpoly()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_minpoly"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_minpoly()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#rank">Rank</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_rank"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rank()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#column-partitioning">Column partitioning</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_col_partition"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_col_partition()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nonsingular-solving">Nonsingular solving</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_solve"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_fflu"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_fflu()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_fflu_precomp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_fflu_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_cramer"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_cramer()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_bound"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_bound()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_dixon"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_dixon()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_solve_dixon_den"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_solve_dixon_den()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_dixon_den"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_dixon_den()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_multi_mod_den"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_multi_mod_den()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_can_solve_multi_mod_den"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_can_solve_multi_mod_den()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_can_solve_fflu"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_can_solve_fflu()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_can_solve"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_can_solve()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#row-reduction">Row reduction</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_find_pivot_any"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_find_pivot_any()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fflu"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fflu()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_rref"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_rref_fflu"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref_fflu()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_rref_mul"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_in_rref_with_rank"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_in_rref_with_rank()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#strong-echelon-form-and-howell-form">Strong echelon form and Howell form</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_strong_echelon_form_mod"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_strong_echelon_form_mod()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_howell_form_mod"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_howell_form_mod()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nullspace">Nullspace</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_nullspace"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_nullspace()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#echelon-form">Echelon form</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_rref_fraction_free"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref_fraction_free()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hermite-normal-form">Hermite normal form</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_hnf"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_transform"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_transform()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_classical"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_classical()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_xgcd"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_xgcd()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_modular"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_modular()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_modular_eldiv"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_modular_eldiv()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_minors"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_minors()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_pernet_stein"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_pernet_stein()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_in_hnf"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_in_hnf()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#smith-normal-form">Smith normal form</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_snf"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_snf()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_snf_diagonal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_snf_diagonal()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_snf_kannan_bachem"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_snf_kannan_bachem()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_snf_iliopoulos"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_snf_iliopoulos()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_in_snf"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_in_snf()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-matrices">Special matrices</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_gram"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_gram()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_hadamard"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_hadamard()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hadamard"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hadamard()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#conversions">Conversions</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_get_d_mat"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_get_d_mat()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_get_d_mat_transpose"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_get_d_mat_transpose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#cholesky-decomposition">Cholesky Decomposition</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_chol_d"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_chol_d()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_spd"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_spd()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#lll">LLL</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_is_reduced"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_reduced_gram"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_gram()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_reduced_with_removal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_with_removal()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_reduced_gram_with_removal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_gram_with_removal()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#classical-lll">Classical LLL</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_lll_original"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_lll_original()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modified-lll">Modified LLL</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_lll_storjohann"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_lll_storjohann()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  

                </aside>
                <!-- .#Secondary drawer (desktop) -->
              </div>
            </main>

            
<footer class="p-4">
  <div
    class="text-secondary-content container mx-auto flex h-8 items-center justify-center text-center text-sm"
  >
    <div>
        Copyright &copy; 2009-2025, The FLINT development team
      <br class="lg:hidden" />
      Made with
      <a
        href="https://www.sphinx-doc.org"
        class="hover:text-accent-content underline"
        >Sphinx</a
      >
      and
      <a
        href="https://readcraft.io/sphinx-clarity-theme/?utm_source=sphinx_clarity_theme"
        class="hover:text-accent-content underline"
        >Clarity Theme for Sphinx </a
      >.
    </div>
  </div>
</footer>
          </div>

          
<!-- #Scroll to top -->
<div id="scroll-to-top" class="toast toast-end">
  <a
    class="btn btn-secondary btn-sm"
    href="#top"
    aria-label="Scroll to top"
  >
    Back to top
    <span class="icon-[prime--arrow-up] text-base"></span>
  </a>
</div>
<!-- .#Scroll to top -->
          
<!-- #Search dialog -->
<dialog id="searchModal" class="modal">
  <div class="modal-box absolute top-8 lg:top-16">
    <search>
      <form action="search.html" method="get">
        <label class="input input-xl w-full">
          <span class="icon-[prime--search] text-4xl"></span>
          <input
            type="search"
            class="grow"
            placeholder="Search the docs"
            name="q"
            placeholder="Search the documentation"
            aria-label="Search the documentation"
          />
          <kbd class="kbd kbd-lg p-4">Enter</kbd>
        </label>
      </form>
    </search>
    <p class="mt-4 text-sm">
      Press <kbd class="kbd">Enter</kbd> to search. Press
      <kbd class="kbd">Esc</kbd> or click outside to close.
    </p>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>close</button>
  </form>
</dialog>
<!-- .#Search dialog -->

          <!-- ====================================================== -->
          <!-- .Page content -->
          <!-- ====================================================== -->

          <!-- ====================================================== -->
          <!-- Secondary drawer after markup -->
          <!-- ====================================================== -->
        </div>
        <div class="drawer-side">
          <label
            for="secondary-drawer"
            class="drawer-overlay"
            aria-label="Close secondary sidebar"
          ></label>
          <div
            class="bg-base-100 text-base-content mt-[var(--header-height)] min-h-full w-80 overflow-y-auto p-4"
          >
            <!-- ==================================================== -->
            <!-- Secondary drawer (mobile) content -->
            <!-- ==================================================== -->
            <div class="text-xs">


  
    <div class="local-toc">
      <p class="local-toc__caption mt-0 mb-4 font-semibold uppercase">
        On this page
      </p>
      <ul>
<li><a class="reference internal" href="#"><strong>fmpz_mat.h</strong> – matrices over the integers</a><ul>
<li><a class="reference internal" href="#simple-example">Simple example</a></li>
<li><a class="reference internal" href="#types-macros-and-constants">Types, macros and constants</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_struct"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_struct</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_t"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_t</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-management">Memory management</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_init"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_init()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_clear"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_clear()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-assignment-and-manipulation">Basic assignment and manipulation</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_set"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_set()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_init_set"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_init_set()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_nrows"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_nrows()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_ncols"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_ncols()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_swap"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_swap()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_swap_entrywise"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_swap_entrywise()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_entry"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_entry()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_zero"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_zero()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_one"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_one()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_swap_rows"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_swap_rows()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_swap_cols"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_swap_cols()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_invert_rows"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_invert_rows()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_invert_cols"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_invert_cols()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#window">Window</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_window_init"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_window_init()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_window_clear"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_window_clear()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-matrix-generation">Random matrix generation</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_randbits"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randbits()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randtest"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randtest()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randintrel"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randintrel()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randsimdioph"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randsimdioph()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randntrulike"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randntrulike()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randntrulike2"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randntrulike2()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randajtai"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randajtai()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randpermdiag"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randpermdiag()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randrank"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randrank()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randdet"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randdet()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_randops"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_randops()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#input-and-output">Input and output</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_fprint"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fprint()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fprint_pretty"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fprint_pretty()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_print"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_print()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_print_pretty"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_print_pretty()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fread"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fread()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_read"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_read()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparison">Comparison</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_equal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_equal()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_zero"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_zero()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_one"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_one()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_empty"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_empty()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_square"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_square()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_zero_row"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_zero_row()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_equal_col"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_equal_col()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_equal_row"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_equal_row()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#transpose">Transpose</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_transpose"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_transpose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#concatenate">Concatenate</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_concat_vertical"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_concat_vertical()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_concat_horizontal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_concat_horizontal()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modular-reduction-and-reconstruction">Modular reduction and reconstruction</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_get_nmod_mat"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_get_nmod_mat()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_set_nmod_mat"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_set_nmod_mat()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_set_nmod_mat_unsigned"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_set_nmod_mat_unsigned()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_CRT_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_CRT_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_multi_mod_ui_precomp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_mod_ui_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_multi_mod_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_mod_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_multi_CRT_ui_precomp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_CRT_ui_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_multi_CRT_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_multi_CRT_ui()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#addition-and-subtraction">Addition and subtraction</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_add"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_add()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_sub"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_sub()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_neg"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_neg()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-scalar-arithmetic">Matrix-scalar arithmetic</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_mul_si"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_mul_si()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_mul_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_mul_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_mul_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_mul_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_si"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_si()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_submul_si"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_submul_si()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_submul_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_submul_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_submul_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_submul_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_nmod_mat_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_nmod_mat_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_addmul_nmod_mat_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_addmul_nmod_mat_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_divexact_si"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_divexact_si()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_divexact_ui"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_divexact_ui()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_divexact_fmpz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_divexact_fmpz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_mul_2exp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_mul_2exp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_tdiv_q_2exp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_tdiv_q_2exp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_scalar_smod"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_scalar_smod()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-multiplication">Matrix multiplication</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_mul"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_classical"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_classical()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_waksman"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_waksman()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_strassen"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_strassen()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_mul_multi_mod"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_mul_multi_mod()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_multi_mod"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_multi_mod()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_blas"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_blas()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_fft"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_fft()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_sqr"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_sqr()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_sqr_bodrato"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_sqr_bodrato()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_pow"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_pow()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_mul_small"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_mul_small()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_mul_double_word"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_mul_double_word()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_fmpz_vec"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_fmpz_vec()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_mul_fmpz_vec_ptr"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_mul_fmpz_vec_ptr()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fmpz_vec_mul"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fmpz_vec_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fmpz_vec_mul_ptr"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fmpz_vec_mul_ptr()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#inverse">Inverse</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_inv"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_inv()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#kronecker-product">Kronecker product</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_kronecker_product"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_kronecker_product()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#content">Content</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_content"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_content()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#trace">Trace</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_trace"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_trace()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#determinant">Determinant</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_det"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_cofactor"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_cofactor()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_bareiss"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_bareiss()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_modular"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_modular()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_modular_accelerated"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_modular_accelerated()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_modular_given_divisor"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_modular_given_divisor()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_bound"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_bound()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_bound_nonzero"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_bound_nonzero()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_det_divisor"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_det_divisor()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#permanent">Permanent</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_permanent"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_permanent()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#transforms">Transforms</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_similarity"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_similarity()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#characteristic-polynomial">Characteristic polynomial</a><ul>
<li><a class="reference internal" href="#c._fmpz_mat_charpoly_berkowitz"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_charpoly_berkowitz()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_charpoly_berkowitz"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_charpoly_berkowitz()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_charpoly_modular"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_charpoly_modular()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_charpoly_modular"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_charpoly_modular()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_charpoly"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_charpoly()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_charpoly"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_charpoly()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#minimal-polynomial">Minimal polynomial</a><ul>
<li><a class="reference internal" href="#c._fmpz_mat_minpoly_modular"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_minpoly_modular()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_minpoly_modular"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_minpoly_modular()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_minpoly"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_minpoly()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_minpoly"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_minpoly()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#rank">Rank</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_rank"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rank()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#column-partitioning">Column partitioning</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_col_partition"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_col_partition()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nonsingular-solving">Nonsingular solving</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_solve"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_fflu"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_fflu()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_fflu_precomp"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_fflu_precomp()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_cramer"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_cramer()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_bound"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_bound()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_dixon"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_dixon()</span></code></a></li>
<li><a class="reference internal" href="#c._fmpz_mat_solve_dixon_den"><code class="docutils literal notranslate"><span class="pre">_fmpz_mat_solve_dixon_den()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_dixon_den"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_dixon_den()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_solve_multi_mod_den"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_solve_multi_mod_den()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_can_solve_multi_mod_den"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_can_solve_multi_mod_den()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_can_solve_fflu"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_can_solve_fflu()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_can_solve"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_can_solve()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#row-reduction">Row reduction</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_find_pivot_any"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_find_pivot_any()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_fflu"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_fflu()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_rref"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_rref_fflu"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref_fflu()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_rref_mul"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref_mul()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_in_rref_with_rank"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_in_rref_with_rank()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#strong-echelon-form-and-howell-form">Strong echelon form and Howell form</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_strong_echelon_form_mod"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_strong_echelon_form_mod()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_howell_form_mod"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_howell_form_mod()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nullspace">Nullspace</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_nullspace"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_nullspace()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#echelon-form">Echelon form</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_rref_fraction_free"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_rref_fraction_free()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hermite-normal-form">Hermite normal form</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_hnf"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_transform"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_transform()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_classical"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_classical()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_xgcd"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_xgcd()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_modular"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_modular()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_modular_eldiv"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_modular_eldiv()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_minors"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_minors()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hnf_pernet_stein"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hnf_pernet_stein()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_in_hnf"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_in_hnf()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#smith-normal-form">Smith normal form</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_snf"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_snf()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_snf_diagonal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_snf_diagonal()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_snf_kannan_bachem"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_snf_kannan_bachem()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_snf_iliopoulos"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_snf_iliopoulos()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_in_snf"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_in_snf()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-matrices">Special matrices</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_gram"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_gram()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_hadamard"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_hadamard()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_hadamard"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_hadamard()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#conversions">Conversions</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_get_d_mat"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_get_d_mat()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_get_d_mat_transpose"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_get_d_mat_transpose()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#cholesky-decomposition">Cholesky Decomposition</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_chol_d"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_chol_d()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_spd"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_spd()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#lll">LLL</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_is_reduced"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_reduced_gram"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_gram()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_reduced_with_removal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_with_removal()</span></code></a></li>
<li><a class="reference internal" href="#c.fmpz_mat_is_reduced_gram_with_removal"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_gram_with_removal()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#classical-lll">Classical LLL</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_lll_original"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_lll_original()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modified-lll">Modified LLL</a><ul>
<li><a class="reference internal" href="#c.fmpz_mat_lll_storjohann"><code class="docutils literal notranslate"><span class="pre">fmpz_mat_lll_storjohann()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  
</div>
          </div>
        </div>
      </div>

      <!-- ========================================================== -->
      <!-- Primary drawer after markup -->
      <!-- ========================================================== -->
    </div>

    <div class="drawer-side">
      <label
        for="primary-drawer"
        aria-label="Close primary sidebar"
        class="drawer-overlay"
      ></label>
      <div
        class="bg-base-100 text-base-content mt-[var(--header-height)] min-h-full w-80 overflow-y-auto p-4"
      >
        <!-- ===================================================== -->
        <!-- Primary drawer (mobile) content -->
        <!-- ===================================================== -->
        <div class="text-xs">


  <div class="global-toc">
    <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html"><strong>Building, testing and installing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="bug_reporting.html"><strong>Bug reporting</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing to FLINT</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html"><strong>Contributors</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html"><strong>Memory management</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="portability.html"><strong>Portability</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="threading.html"><strong>Threading</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flint.html"><strong>flint.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html"><strong>profiler.h</strong> – performance profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread_pool.html"><strong>thread_pool.h</strong> – thread pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpoly.html"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_vectors.html"><strong>machine_vectors.h</strong> – SIMD-accelerated operations on fixed-length vectors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generic rings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gr.html"><strong>gr.h</strong> – generic structures and their elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_implementing.html"><strong>gr.h (continued)</strong> – implementing rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_domains.html"><strong>gr.h (continued)</strong> – builtin domains and types</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_generic.html"><strong>gr_generic.h</strong> – basic algorithms and fallback implementations for generic elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_special.html"><strong>gr_special.h</strong> – special arithmetic and transcendental functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_vec.html"><strong>gr_vec.h</strong> – vectors over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mat.html"><strong>gr_mat.h</strong> – dense matrices over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_poly.html"><strong>gr_poly.h</strong> – dense univariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mpoly.html"><strong>gr_mpoly.h</strong> – sparse multivariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_series.html"><strong>gr_series.h</strong> – formal power series over generic rings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_generic.html"><strong>Generic rings</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ulong_extras.html"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz.html"><strong>fmpz.h</strong> – integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_vec.html"><strong>fmpz_vec.h</strong> – vectors of integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_factor.html"><strong>fmpz_factor.h</strong> – integer factorisation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>fmpz_mat.h</strong> – matrices over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_lll.html"><strong>fmpz_lll.h</strong> – LLL reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly.html"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_mat.html"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_factor.html"><strong>fmpz_poly_factor.h</strong> – factorisation of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly.html"><strong>fmpz_mpoly.h</strong> – multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_factor.html"><strong>fmpz_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="long_extras.html"><strong>long_extras.h</strong> – support functions for signed word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="longlong.html"><strong>longlong.h</strong> – support functions for multi-word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_extras.html"><strong>mpn_extras.h</strong> – support functions for limb arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="aprcl.html"><strong>aprcl.h</strong> – APRCL primality testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arith.html"><strong>arith.h</strong> – arithmetic and special functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft.html"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft_small.html"><strong>fft_small.h</strong> – FFT modulo word-size primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="qsieve.html"><strong>qsieve.h</strong> – Quadratic sieve</a></li>
<li class="toctree-l1"><a class="reference internal" href="radix.html"><strong>radix.h</strong> – multiprecision arithmetic in general radix</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index_integers.html"><strong>Integers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Rational numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fmpq.html"><strong>fmpq.h</strong> – rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_vec.html"><strong>fmpq_vec.h</strong> – vectors over rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mat.html"><strong>fmpq_mat.h</strong> – matrices over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_poly.html"><strong>fmpq_poly.h</strong> – univariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly_factor.html"><strong>fmpq_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly.html"><strong>fmpq_mpoly.h</strong> – multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_q.html"><strong>fmpz_poly_q.h</strong> – rational functions over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_q.html"><strong>fmpz_mpoly_q.h</strong> – multivariate rational functions over Q</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_rationals.html"><strong>Rational numbers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers mod n</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nmod.html"><strong>nmod.h</strong> – integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_vec.html"><strong>nmod_vec.h</strong> – vectors over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mat.html"><strong>nmod_mat.h</strong> – matrices over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly.html"><strong>nmod_poly.h</strong> – univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_mat.html"><strong>nmod_poly_mat.h</strong> – matrices of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_factor.html"><strong>nmod_poly_factor.h</strong> – factorisation of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly.html"><strong>nmod_mpoly.h</strong> – multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly_factor.html"><strong>nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_mod.html"><strong>mpn_mod.h</strong> – integers mod n (packed multi-word n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod.html"><strong>fmpz_mod.h</strong> – arithmetic modulo integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_vec.html"><strong>fmpz_mod_vec.h</strong> – vectors over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mat.html"><strong>fmpz_mod_mat.h</strong> – matrices over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly.html"><strong>fmpz_mod_poly.h</strong> – polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly_factor.html"><strong>fmpz_mod_poly_factor.h</strong> – factorisation of polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly.html"><strong>fmpz_mod_mpoly.h</strong> – polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_factor.html"><strong>fmpz_mod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_q.html"><strong>fmpz_mod_mpoly_q.h</strong> – multivariate rational functions over Z/mZ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers_mod.html"><strong>Integers mod n</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Groups and other structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="perm.html"><strong>perm.h</strong> – permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="qfb.html"><strong>qfb.h</strong> – binary quadratic forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dirichlet.html"><strong>dirichlet.h</strong> – Dirichlet characters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlog.html"><strong>dlog.h</strong> – discrete logarithms mod ulong primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="bool_mat.html"><strong>bool_mat.h</strong> – matrices over booleans</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Number fields and algebraic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nf.html"><strong>nf.h</strong> – number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="nf_elem.html"><strong>nf_elem.h</strong> – number field elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpzi.html"><strong>fmpzi.h</strong> – Gaussian integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qqbar.html"><strong>qqbar.h</strong> – algebraic numbers represented by minimal polynomials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Feature overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using ball arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Technical conventions and potential issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_arb.html">Arb example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="mag.html"><strong>mag.h</strong> – fixed-precision unsigned floating-point numbers for bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="nfloat.html"><strong>nfloat.h</strong> – packed floating-point numbers with n-word precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="arf.html"><strong>arf.h</strong> – arbitrary-precision floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acf.html"><strong>acf.h</strong> – complex floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb.html"><strong>arb.h</strong> – real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb.html"><strong>acb.h</strong> – complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_poly.html"><strong>arb_poly.h</strong> – polynomials over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_poly.html"><strong>acb_poly.h</strong> – polynomials over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fmpz_poly.html"><strong>arb_fmpz_poly.h</strong> – extra methods for integer polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dft.html"><strong>acb_dft.h</strong> – Discrete Fourier transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_mat.html"><strong>arb_mat.h</strong> – matrices over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_mat.html"><strong>acb_mat.h</strong> – matrices over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_hypgeom.html"><strong>acb_hypgeom.h</strong> – hypergeometric functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_hypgeom.html"><strong>arb_hypgeom.h</strong> – hypergeometric functions of real variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_elliptic.html"><strong>acb_elliptic.h</strong> – elliptic integrals and functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_modular.html"><strong>acb_modular.h</strong> – modular forms of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_theta.html"><strong>acb_theta.h</strong> – Riemann theta functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dirichlet.html"><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bernoulli.html"><strong>bernoulli.h</strong> – support for Bernoulli numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypgeom.html"><strong>hypgeom.h</strong> – support for hypergeometric series</a></li>
<li class="toctree-l1"><a class="reference internal" href="partitions.html"><strong>partitions.h</strong> – computation of the partition function</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_calc.html"><strong>arb_calc.h</strong> – calculus with real-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_calc.html"><strong>acb_calc.h</strong> – calculus with complex-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fpwrap.html"><strong>arb_fpwrap.h</strong> – floating-point wrappers of Arb mathematical functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_extras.html"><strong>fmpz_extras.h</strong> – extra methods for FLINT integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">General formulas and bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">Algorithms for mathematical constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma.html">Algorithms for the gamma function</a></li>
<li class="toctree-l1"><a class="reference internal" href="hurwitz.html">Algorithms for the Hurwitz zeta function</a></li>
<li class="toctree-l1"><a class="reference internal" href="polylogarithms.html">Algorithms for polylogarithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergeometric.html">Algorithms for hypergeometric functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="agm.html">Algorithms for the arithmetic-geometric mean</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_arb.html"><strong>Real and complex numbers (Arb)</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_calcium.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_calcium.html">Calcium example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="calcium.html"><strong>calcium.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca.html"><strong>ca.h</strong> – exact real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_vec.html"><strong>ca_vec.h</strong> – vectors of real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_poly.html"><strong>ca_poly.h</strong> – dense univariate polynomials over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_mat.html"><strong>ca_mat.h</strong> – matrices over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_ext.html"><strong>ca_ext.h</strong> – real and complex extension numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_field.html"><strong>ca_field.h</strong> – extension fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr.html"><strong>fexpr.h</strong> – flat-packed symbolic expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr_builtin.html"><strong>fexpr_builtin.h</strong> – builtin symbols</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite fields</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq.html"><strong>fq.h</strong> – finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default.html"><strong>fq_default.h</strong> – unified finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_vec.html"><strong>fq_vec.h</strong> – vectors over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_mat.html"><strong>fq_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_mat.html"><strong>fq_default_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly.html"><strong>fq_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly.html"><strong>fq_default_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly_factor.html"><strong>fq_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly_factor.html"><strong>fq_default_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_embed.html"><strong>fq_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod.html"><strong>fq_nmod.h</strong> – finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_vec.html"><strong>fq_nmod_vec.h</strong> – vectors over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mat.html"><strong>fq_nmod_mat.h</strong> – matrices over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly.html"><strong>fq_nmod_poly.h</strong> – univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly_factor.html"><strong>fq_nmod_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_embed.html"><strong>fq_nmod_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly.html"><strong>fq_nmod_mpoly.h</strong> – multivariate polynomials over finite fields of word-sized characteristic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly_factor.html"><strong>fq_nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over finite fields of word-sized characteristic</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_zech.html"><strong>fq_zech.h</strong> – finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_vec.html"><strong>fq_zech_vec.h</strong> – vectors over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_mat.html"><strong>fq_zech_mat.h</strong> – matrices over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly.html"><strong>fq_zech_poly.h</strong> – univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly_factor.html"><strong>fq_zech_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_embed.html"><strong>fq_zech_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">p-adic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="padic.html"><strong>padic.h</strong> – p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_poly.html"><strong>padic_poly.h</strong> – polynomials over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_mat.html"><strong>padic_mat.h</strong> – matrices over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qadic.html"><strong>qadic.h</strong> – unramified extensions over p-adic numbers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Floating-point support code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="double_extras.html"><strong>double_extras.h</strong> – support functions for double arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="double_interval.html"><strong>double_interval.h</strong> – double-precision interval arithmetic and helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_vec.html"><strong>d_vec.h</strong> – double precision vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_mat.html"><strong>d_mat.h</strong> – double precision matrices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_flint.html"><strong>flint_ctypes</strong> - Python interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Version history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="history.html">History and changes</a></li>
</ul>

  </div>
</div>
      </div>
    </div>
  </div>


    
    <script
  defer
  src="_static/scripts/scroll-to-top.js"
></script>

<script>
  window.ScrollspyConfig = {
    rootMargin: "-120px 0px -60% 0px",
  };
</script>
<script defer src="_static/scripts/scrollspy.js"></script>
  <script src="_static/documentation_options.js?v=4cb41d1b"></script>
  <script src="_static/doctools.js?v=c73fddf3"></script>
  <script src="_static/sphinx_highlight.js?v=36527ec2"></script>
  <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    </body>
</html>