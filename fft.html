
<!doctype html>
<html
  lang="en"
  data-content_root="./"
  class="scroll-smooth [--header-height:calc(var(--spacing)*18)] [--header-padding:calc(var(--spacing)*12)]"
  id="top"
  
>
  <head>
    <title>fft.h – Schoenhage-Strassen FFT &mdash; FLINT 3.5.0-dev documentation</title>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="generator"
  content="Sphinx 9.1.0, Clarity Theme for Sphinx 0.1.1 (https://readcraft.io/sphinx-clarity-theme/)"
/>


<meta name="viewport" content="width=device-width, initial-scale=1" />



<script src="_static/scripts/dark-mode.js"></script>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=a5519fdd" />
    <link rel="stylesheet" type="text/css" href="_static/styles/output.css?v=71cc70a9" />



    
    
  </head>

  <body >
    
  <!-- ============================================================== -->
  <!-- Primary drawer before markup -->
  <!-- ============================================================== -->
  <div class="drawer">
    <input id="primary-drawer" type="checkbox" class="drawer-toggle" />
    <div class="drawer-content">
      <!-- ========================================================== -->
      <!-- Secondary drawer before markup -->
      <!-- ========================================================== -->
      <div class="drawer drawer-end">
        <input id="secondary-drawer" type="checkbox" class="drawer-toggle" />
        <div class="drawer-content">
          <!-- ====================================================== -->
          <!-- Page content -->
          <!-- ====================================================== -->
          <div class="bg-base-100 divide-base-200 divide-y">
            


<!-- Header -->
<header id="main-header" class="bg-base-100 sticky top-0 z-50">
  <div
    class="container mx-auto flex h-[var(--header-height)] items-center px-4 md:px-0"
  >
    <!-- Left side (logo) -->
    <div class="flex-1">
<a href="index.html">
  
  
    <span class="text-primary-content text-xl font-bold">
      
      FLINT 3.5.0-dev documentation
    </span>
  
</a></div>

    <!-- Right side -->
    <div class="flex flex-1 items-center justify-end">
      <!-- #Header menu (desktop) -->
      <div class="hidden lg:block">
        <!-- `[&_li]:self-center` - If a content of <li> is the button, the "self-center" required to properly vertically align it -->
        <!-- `[&_li>a]:px-2 [&_li>a]:py-3` - Tweaks default menu ugly padding that doesn't match to buttons padding -->
        <ul
          class="menu menu-horizontal text-secondary-content gap-2 [&_li]:self-center [&_li>a]:px-2 [&_li>a]:py-3"
        >
          
        </ul>
      </div>
      <!-- .#Header menu (desktop) -->

      <!-- #Search button -->
      <div class="tooltip tooltip-bottom" data-tip="Search">
        <button
          class="btn btn-ghost btn-secondary"
          onclick="searchModal.showModal()"
        >
          <span class="icon-[prime--search] text-2xl"></span>
        </button>
      </div>
      <!-- .#Search button -->

      
  
  


      
  <!-- #Mode select -->
  <div class="tooltip tooltip-bottom" data-tip="Light/dark mode">
    <button class="btn btn-ghost btn-secondary">
      <label class="swap swap-rotate">
        <!-- this hidden checkbox controls the state -->
        <input type="checkbox" onclick="toggleMode()" />
        <!-- light mode icon -->
        <span class="icon-[prime--sun] swap-on text-2xl"></span>
        <!-- dark mode icon -->
        <span class="icon-[prime--moon] swap-off text-2xl"></span>
      </label>
    </button>
  </div>
  <!-- .#Mode select -->


      <!-- #Header menu (mobile) -->
      <details class="dropdown dropdown-left lg:hidden">
        <summary class="btn btn-secondary aspect-square" aria-label="Menu">
          <span class="icon-[prime--bars]"></span>
          <span class="sr-only">Menu</span>
        </summary>
        <!-- `[&_li>a.btn]:justify-start` - If a content of <li> is the button, it should be aligned to the start (left) -->
        <ul
          class="menu dropdown-content bg-base-100 rounded-box dark:border-base-200 z-1 w-52 p-2 shadow-sm dark:border [&_li>a.btn]:justify-start"
        >
          
        </ul>
      </details>
      <!-- .#Header menu (mobile) -->
    </div>
  </div>
</header>
            
<!-- #Sidebar toggles (mobile) -->
<nav class="p-4 lg:hidden">
  <div class="container mx-auto flex items-center justify-between text-sm">
    <!-- Left side -->
    <div>
      
        <button
          class="btn btn-secondary btn-sm text-secondary-content/80 font-normal"
        >
          <label
            for="primary-drawer"
            class="flex cursor-pointer items-center gap-1"
          >
            <span class="icon-[prime--align-left] text-xl"></span>
            Table of Contents
          </label>
        </button>
      
    </div>
    <!-- .Left side -->
    <!-- Right side -->
    <div>
      
        <button
          class="btn btn-secondary btn-sm text-secondary-content/80 font-normal"
        >
          <label
            for="secondary-drawer"
            class="flex cursor-pointer items-center gap-1"
          >
            This page
            <span class="icon-[prime--align-right] text-xl"></span>
          </label>
        </button>
      
    </div>
    <!-- .Right side -->
  </div>
</nav>
<!-- .#Sidebar toggles (mobile) -->

            <main class="p-4 lg:pt-[var(--header-padding)]">
              <div class="container mx-auto lg:flex lg:items-start">
                <article class="lg:order-2 lg:w-8/12 lg:flex-none lg:px-12">
                  
<!-- #Breadcrumb -->
<nav class="flex flex-wrap items-center gap-1 text-sm">
  
  <a
    href="index.html"
    class="text-secondary-content/80 hover:text-accent-content hover:underline"
  >
    FLINT 3.5.0-dev documentation
  </a>

  

  
  <span
    class="icon-[prime--arrow-right] text-secondary-content/50"
  ></span>
  <span class="text-secondary-content/80"><strong>fft.h</strong> – Schoenhage-Strassen FFT</span>
</nav>
<!-- .#Breadcrumb -->

                  
                  <main role="main">
  <section id="fft-h-schoenhage-strassen-fft">
<span id="fft"></span><h1><strong>fft.h</strong> – Schoenhage-Strassen FFT<a class="headerlink" href="#fft-h-schoenhage-strassen-fft" title="Link to this heading">¶</a></h1>
<section id="split-combine-fft-coefficients">
<h2>Split/combine FFT coefficients<a class="headerlink" href="#split-combine-fft-coefficients" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fft_split_limbs">
<span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_split_limbs</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">total_limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">coeff_limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">output_limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_split_limbs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Split an integer <code class="docutils literal notranslate"><span class="pre">(limbs,</span> <span class="pre">total_limbs)</span></code> into coefficients of length
<code class="docutils literal notranslate"><span class="pre">coeff_limbs</span></code> limbs and store as the coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>
which are assumed to have space for <code class="docutils literal notranslate"><span class="pre">output_limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> limbs per
coefficient. The coefficients of the polynomial do not need to be zeroed
before calling this function, however the number of coefficients written
is returned by the function and any coefficients beyond this point are
not touched.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_split_bits">
<span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_split_bits</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">total_limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">output_limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_split_bits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Split an integer <code class="docutils literal notranslate"><span class="pre">(limbs,</span> <span class="pre">total_limbs)</span></code> into coefficients of the
given number of <code class="docutils literal notranslate"><span class="pre">bits</span></code> and store as the coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>
which are assumed to have space for <code class="docutils literal notranslate"><span class="pre">output_limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> limbs per
coefficient. The coefficients of the polynomial do not need to be zeroed
before calling this function, however the number of coefficients written
is returned by the function and any coefficients beyond this point are
not touched.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_combine_limbs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_combine_limbs</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">length</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">coeff_limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">output_limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">total_limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_combine_limbs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluate the polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code> of the given <code class="docutils literal notranslate"><span class="pre">length</span></code> at
<code class="docutils literal notranslate"><span class="pre">B^coeff_limbs</span></code>, where <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">2^FLINT_BITS</span></code>, and add the
result to the integer <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">total_limbs)</span></code> throwing away any bits
that exceed the given number of limbs. The polynomial coefficients are
assumed to have at least <code class="docutils literal notranslate"><span class="pre">output_limbs</span></code> limbs each, however any
additional limbs are ignored.</p>
<p>If the integer is initially zero the result will just be the evaluation
of the polynomial.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_combine_bits">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_combine_bits</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">length</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">output_limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">total_limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_combine_bits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluate the polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code> of the given <code class="docutils literal notranslate"><span class="pre">length</span></code> at
<code class="docutils literal notranslate"><span class="pre">2^bits</span></code> and add the result to the integer
<code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">total_limbs)</span></code> throwing away any bits that exceed the given
number of limbs. The polynomial coefficients are assumed to have at least
<code class="docutils literal notranslate"><span class="pre">output_limbs</span></code> limbs each, however any additional limbs are ignored.
If the integer is initially zero the result will just be the evaluation
of the polynomial.</p>
</dd></dl>

</section>
<section id="test-helper-functions">
<h2>Test helper functions<a class="headerlink" href="#test-helper-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fermat_to_mpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fermat_to_mpz</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fermat_to_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert the Fermat number <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">limbs)</span></code> modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> to
an <code class="docutils literal notranslate"><span class="pre">mpz_t</span> <span class="pre">m</span></code>. Assumes <code class="docutils literal notranslate"><span class="pre">m</span></code> has been initialised. This function
is used only in test code.</p>
</dd></dl>

</section>
<section id="arithmetic-modulo-a-generalised-fermat-number">
<h2>Arithmetic modulo a generalised Fermat number<a class="headerlink" href="#arithmetic-modulo-a-generalised-fermat-number" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpn_negmod_2expp1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpn_negmod_2expp1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpn_negmod_2expp1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">z</span></code> to the negation of the Fermat number <span class="math notranslate nohighlight">\(a\)</span> modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code>.
The input <code class="docutils literal notranslate"><span class="pre">a</span></code> is expected to be fully reduced, and the output is fully reduced.
Aliasing is permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpn_addmod_2expp1_1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpn_addmod_2expp1_1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <span class="n"><span class="pre">mp_limb_signed_t</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpn_addmod_2expp1_1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Adds the signed limb <code class="docutils literal notranslate"><span class="pre">c</span></code> to the generalised Fermat number <code class="docutils literal notranslate"><span class="pre">r</span></code>
modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code>. The compiler should be able to inline
this for the case that there is no overflow from the first limb.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpn_normmod_2expp1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpn_normmod_2expp1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpn_normmod_2expp1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">t</span></code> a signed integer of <code class="docutils literal notranslate"><span class="pre">limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> limbs in two’s
complement format, reduce <code class="docutils literal notranslate"><span class="pre">t</span></code> to the corresponding value modulo the
generalised Fermat number <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code>, where
<code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">2^FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpn_mul_2expmod_2expp1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpn_mul_2expmod_2expp1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpn_mul_2expmod_2expp1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">i1</span></code> a signed integer of <code class="docutils literal notranslate"><span class="pre">limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> limbs in two’s
complement format reduced modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> up to some
overflow, compute <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">i1*2^d</span></code> modulo <span class="math notranslate nohighlight">\(p\)</span>. The result will not
necessarily be fully reduced. The number of bits <code class="docutils literal notranslate"><span class="pre">d</span></code> must be
nonnegative and less than <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>. Aliasing is permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpn_div_2expmod_2expp1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpn_div_2expmod_2expp1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpn_div_2expmod_2expp1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">i1</span></code> a signed integer of <code class="docutils literal notranslate"><span class="pre">limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> limbs in two’s
complement format reduced modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> up to some
overflow, compute <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">i1/2^d</span></code> modulo <span class="math notranslate nohighlight">\(p\)</span>. The result will not
necessarily be fully reduced. The number of bits <code class="docutils literal notranslate"><span class="pre">d</span></code> must be
nonnegative and less than <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>. Aliasing is permitted.</p>
</dd></dl>

</section>
<section id="generic-butterflies">
<h2>Generic butterflies<a class="headerlink" href="#generic-butterflies" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fft_adjust">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_adjust</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_adjust" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">r</span></code> to <code class="docutils literal notranslate"><span class="pre">i1</span></code> times <span class="math notranslate nohighlight">\(z^i\)</span> modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> where
<span class="math notranslate nohighlight">\(z\)</span> corresponds to multiplication by <span class="math notranslate nohighlight">\(2^w\)</span>. This can be thought of as part
of a butterfly operation. We require <span class="math notranslate nohighlight">\(0 \leq i &lt; n\)</span> where <span class="math notranslate nohighlight">\(nw =\)</span>
<code class="docutils literal notranslate"><span class="pre">limbs*FLINT_BITS</span></code>. Aliasing is not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_adjust_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_adjust_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_adjust_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">r</span></code> to <code class="docutils literal notranslate"><span class="pre">i1</span></code> times <span class="math notranslate nohighlight">\(z^i\)</span> modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> where
<span class="math notranslate nohighlight">\(z\)</span> corresponds to multiplication by <span class="math notranslate nohighlight">\(\sqrt{2}^w\)</span>. This can be thought of
as part of a butterfly operation. We require <span class="math notranslate nohighlight">\(0 \leq i &lt; 2\cdot n\)</span> and odd
where <span class="math notranslate nohighlight">\(nw =\)</span> <code class="docutils literal notranslate"><span class="pre">limbs*FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.butterfly_lshB">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">butterfly_lshB</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">u</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.butterfly_lshB" title="Link to this definition">¶</a><br /></dt>
<dd><p>We are given two integers <code class="docutils literal notranslate"><span class="pre">i1</span></code> and <code class="docutils literal notranslate"><span class="pre">i2</span></code> modulo
<code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> which are not necessarily normalised. We compute
<code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">(i1</span> <span class="pre">+</span> <span class="pre">i2)*B^x</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">(i1</span> <span class="pre">-</span> <span class="pre">i2)*B^y</span></code> modulo <span class="math notranslate nohighlight">\(p\)</span>. Aliasing
between inputs and outputs is not permitted. We require <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code> to be less than <code class="docutils literal notranslate"><span class="pre">limbs</span></code> and nonnegative.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.butterfly_rshB">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">butterfly_rshB</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">u</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.butterfly_rshB" title="Link to this definition">¶</a><br /></dt>
<dd><p>We are given two integers <code class="docutils literal notranslate"><span class="pre">i1</span></code> and <code class="docutils literal notranslate"><span class="pre">i2</span></code> modulo
<code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> which are not necessarily normalised. We compute
<code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">(i1</span> <span class="pre">+</span> <span class="pre">i2)/B^x</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">(i1</span> <span class="pre">-</span> <span class="pre">i2)/B^y</span></code> modulo <span class="math notranslate nohighlight">\(p\)</span>. Aliasing
between inputs and outputs is not permitted. We require <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code> to be less than <code class="docutils literal notranslate"><span class="pre">limbs</span></code> and nonnegative.</p>
</dd></dl>

</section>
<section id="radix-2-transforms">
<h2>Radix 2 transforms<a class="headerlink" href="#radix-2-transforms" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fft_butterfly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_butterfly</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_butterfly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">i1</span> <span class="pre">+</span> <span class="pre">i2</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">z1^i*(i1</span> <span class="pre">-</span> <span class="pre">i2)</span></code> modulo
<code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> where <code class="docutils literal notranslate"><span class="pre">z1</span> <span class="pre">=</span> <span class="pre">exp(Pi*I/n)</span></code> corresponds to
multiplication by <span class="math notranslate nohighlight">\(2^w\)</span>. Requires <span class="math notranslate nohighlight">\(0 \leq i &lt; n\)</span> where <span class="math notranslate nohighlight">\(nw =\)</span>
<code class="docutils literal notranslate"><span class="pre">limbs*FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_butterfly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_butterfly</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_butterfly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">i1</span> <span class="pre">+</span> <span class="pre">z1^i*i2</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">i1</span> <span class="pre">-</span>&#160; <span class="pre">z1^i*i2</span></code> modulo
<code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> where <code class="docutils literal notranslate"><span class="pre">z1</span> <span class="pre">=</span> <span class="pre">exp(-Pi*I/n)</span></code> corresponds to
division by <span class="math notranslate nohighlight">\(2^w\)</span>. Requires <span class="math notranslate nohighlight">\(0 \leq i &lt; 2n\)</span> where <span class="math notranslate nohighlight">\(nw =\)</span>
<code class="docutils literal notranslate"><span class="pre">limbs*FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_radix2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_radix2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_radix2" title="Link to this definition">¶</a><br /></dt>
<dd><p>The radix 2 DIF FFT works as follows:</p>
<p>Input: <code class="docutils literal notranslate"><span class="pre">[i0,</span> <span class="pre">i1,</span> <span class="pre">...,</span> <span class="pre">i(m-1)]</span></code>, for <span class="math notranslate nohighlight">\(m = 2n\)</span> a power of <span class="math notranslate nohighlight">\(2\)</span>.</p>
<p>Output: <code class="docutils literal notranslate"><span class="pre">[r0,</span> <span class="pre">r1,</span> <span class="pre">...,</span> <span class="pre">r(m-1)]</span></code> <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">FFT[i0,</span> <span class="pre">i1,</span> <span class="pre">...,</span> <span class="pre">i(m-1)]</span></code>.</p>
<p>Algorithm:</p>
<div class="line-block">
<div class="line"><span class="math notranslate nohighlight">\(\bullet\)</span> Recursively compute <code class="docutils literal notranslate"><span class="pre">[r0,</span> <span class="pre">r2,</span> <span class="pre">r4,</span> <span class="pre">....,</span> <span class="pre">r(m-2)]</span></code></div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">FFT[i0+i(m/2),</span> <span class="pre">i1+i(m/2+1),</span> <span class="pre">...,</span> <span class="pre">i(m/2-1)+i(m-1)]</span></code></div>
<div class="line"><br /></div>
</div>
<div class="line"><span class="math notranslate nohighlight">\(\bullet\)</span> Let <code class="docutils literal notranslate"><span class="pre">[t0,</span> <span class="pre">t1,</span> <span class="pre">...,</span> <span class="pre">t(m/2-1)]</span></code></div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">[i0-i(m/2),</span> <span class="pre">i1-i(m/2+1),</span> <span class="pre">...,</span> <span class="pre">i(m/2-1)-i(m-1)]</span></code></div>
<div class="line"><br /></div>
</div>
<div class="line"><span class="math notranslate nohighlight">\(\bullet\)</span> Let <code class="docutils literal notranslate"><span class="pre">[u0,</span> <span class="pre">u1,</span> <span class="pre">...,</span> <span class="pre">u(m/2-1)]</span></code></div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">[z1^0*t0,</span> <span class="pre">z1^1*t1,</span> <span class="pre">...,</span> <span class="pre">z1^(m/2-1)*t(m/2-1)]</span></code></div>
<div class="line">where <code class="docutils literal notranslate"><span class="pre">z1</span> <span class="pre">=</span> <span class="pre">exp(2*Pi*I/m)</span></code> corresponds to multiplication by <span class="math notranslate nohighlight">\(2^w\)</span>.</div>
<div class="line"><br /></div>
</div>
<div class="line"><span class="math notranslate nohighlight">\(\bullet\)</span> Recursively compute <code class="docutils literal notranslate"><span class="pre">[r1,</span> <span class="pre">r3,</span> <span class="pre">...,</span> <span class="pre">r(m-1)]</span></code></div>
<div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">FFT[u0,</span> <span class="pre">u1,</span> <span class="pre">...,</span> <span class="pre">u(m/2-1)]</span></code></div>
</div>
</div>
<p>The parameters are as follows:</p>
<p><span class="math notranslate nohighlight">\(\bullet\)</span> <code class="docutils literal notranslate"><span class="pre">2*n</span></code> is the length of the input and output arrays</p>
<dl class="simple">
<dt><span class="math notranslate nohighlight">\(\bullet\)</span> <span class="math notranslate nohighlight">\(w\)</span> is such that <span class="math notranslate nohighlight">\(2^w\)</span> is an <span class="math notranslate nohighlight">\(2n\)</span>-th root of unity in the ring <span class="math notranslate nohighlight">\(\mathbf{Z}/p\mathbf{Z}\)</span> that we are working in, i.e. <span class="math notranslate nohighlight">\(p = 2^{wn} + 1\)</span> (here <span class="math notranslate nohighlight">\(n\)</span> is divisible by</dt><dd><p><code class="docutils literal notranslate"><span class="pre">GMP_LIMB_BITS</span></code>)</p>
</dd>
<dt><span class="math notranslate nohighlight">\(\bullet\)</span> <code class="docutils literal notranslate"><span class="pre">ii</span></code> is the array of inputs (each input is an</dt><dd><p>array of limbs of length <code class="docutils literal notranslate"><span class="pre">wn/GMP_LIMB_BITS</span> <span class="pre">+</span> <span class="pre">1</span></code> (the
extra limbs being a “carry limb”). Outputs are written
in-place.</p>
</dd>
</dl>
<p>We require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64 and the two temporary space pointers to
point to blocks of size <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_truncate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_truncate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_truncate" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <code class="docutils literal notranslate"><span class="pre">fft_radix2</span></code> except that only the first <code class="docutils literal notranslate"><span class="pre">trunc</span></code>
coefficients of the output are computed and the input is regarded as
having (implied) zero coefficients from coefficient <code class="docutils literal notranslate"><span class="pre">trunc</span></code> onwards.
The coefficients must exist as the algorithm needs to use this extra
space, but their value is irrelevant. The value of <code class="docutils literal notranslate"><span class="pre">trunc</span></code> must be
divisible by 2.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_truncate1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_truncate1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_truncate1" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <code class="docutils literal notranslate"><span class="pre">fft_radix2</span></code> except that only the first <code class="docutils literal notranslate"><span class="pre">trunc</span></code>
coefficients of the output are computed. The transform still needs all
<span class="math notranslate nohighlight">\(2n\)</span> input coefficients to be specified.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_radix2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_radix2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_radix2" title="Link to this definition">¶</a><br /></dt>
<dd><p>The radix 2 DIF IFFT works as follows:</p>
<p>Input: <code class="docutils literal notranslate"><span class="pre">[i0,</span> <span class="pre">i1,</span> <span class="pre">...,</span> <span class="pre">i(m-1)]</span></code>, for <span class="math notranslate nohighlight">\(m = 2n\)</span> a power of <span class="math notranslate nohighlight">\(2\)</span>.</p>
<dl class="simple">
<dt>Output: <code class="docutils literal notranslate"><span class="pre">[r0,</span> <span class="pre">r1,</span> <span class="pre">...,</span> <span class="pre">r(m-1)]</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">IFFT[i0,</span> <span class="pre">i1,</span> <span class="pre">...,</span> <span class="pre">i(m-1)]</span></code>.</p>
</dd>
</dl>
<p>Algorithm:</p>
<dl class="simple">
<dt><span class="math notranslate nohighlight">\(\bullet\)</span> Recursively compute <code class="docutils literal notranslate"><span class="pre">[s0,</span> <span class="pre">s1,</span> <span class="pre">....,</span> <span class="pre">s(m/2-1)]</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">IFFT[i0,</span> <span class="pre">i2,</span> <span class="pre">...,</span> <span class="pre">i(m-2)]</span></code></p>
</dd>
<dt><span class="math notranslate nohighlight">\(\bullet\)</span> Recursively compute <code class="docutils literal notranslate"><span class="pre">[t(m/2),</span> <span class="pre">t(m/2+1),</span> <span class="pre">...,</span> <span class="pre">t(m-1)]</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">IFFT[i1,</span> <span class="pre">i3,</span> <span class="pre">...,</span> <span class="pre">i(m-1)]</span></code></p>
</dd>
<dt><span class="math notranslate nohighlight">\(\bullet\)</span> Let <code class="docutils literal notranslate"><span class="pre">[r0,</span> <span class="pre">r1,</span> <span class="pre">...,</span> <span class="pre">r(m/2-1)]</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">[s0+z1^0*t0,</span> <span class="pre">s1+z1^1*t1,</span> <span class="pre">...,</span> <span class="pre">s(m/2-1)+z1^(m/2-1)*t(m/2-1)]</span></code> where <code class="docutils literal notranslate"><span class="pre">z1</span> <span class="pre">=</span> <span class="pre">exp(-2*Pi*I/m)</span></code> corresponds to division by <span class="math notranslate nohighlight">\(2^w\)</span>.</p>
</dd>
<dt><span class="math notranslate nohighlight">\(\bullet\)</span> Let <code class="docutils literal notranslate"><span class="pre">[r(m/2),</span> <span class="pre">r(m/2+1),</span> <span class="pre">...,</span> <span class="pre">r(m-1)]</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">[s0-z1^0*t0,</span> <span class="pre">s1-z1^1*t1,</span> <span class="pre">...,</span> <span class="pre">s(m/2-1)-z1^(m/2-1)*t(m/2-1)]</span></code></p>
</dd>
</dl>
<p>The parameters are as follows:</p>
<dl class="simple">
<dt><span class="math notranslate nohighlight">\(\bullet\)</span> <code class="docutils literal notranslate"><span class="pre">2*n</span></code> is the length of the input and output</dt><dd><p>arrays</p>
</dd>
<dt><span class="math notranslate nohighlight">\(\bullet\)</span> <span class="math notranslate nohighlight">\(w\)</span> is such that <span class="math notranslate nohighlight">\(2^w\)</span> is an <span class="math notranslate nohighlight">\(2n\)</span>-th root of unity in the ring <span class="math notranslate nohighlight">\(\mathbf{Z}/p\mathbf{Z}\)</span> that we are working in, i.e. <span class="math notranslate nohighlight">\(p = 2^{wn} + 1\)</span> (here <span class="math notranslate nohighlight">\(n\)</span> is divisible by</dt><dd><p><code class="docutils literal notranslate"><span class="pre">GMP_LIMB_BITS</span></code>)</p>
</dd>
</dl>
<p><span class="math notranslate nohighlight">\(\bullet\)</span> <code class="docutils literal notranslate"><span class="pre">ii</span></code> is the array of inputs (each input is an array of limbs of length <code class="docutils literal notranslate"><span class="pre">wn/GMP_LIMB_BITS</span> <span class="pre">+</span> <span class="pre">1</span></code> (the extra limbs being a “carry limb”). Outputs are written in-place.</p>
<p>We require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64 and the two temporary space pointers
to point to blocks of size <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_truncate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_truncate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_truncate" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <code class="docutils literal notranslate"><span class="pre">ifft_radix2</span></code> except that the output is assumed to have
zeros from coefficient trunc onwards and only the first trunc
coefficients of the input are specified. The remaining coefficients need
to exist as the extra space is needed, but their value is irrelevant.
The value of <code class="docutils literal notranslate"><span class="pre">trunc</span></code> must be divisible by 2.</p>
<p>Although the implementation does not require it, we assume for simplicity
that <code class="docutils literal notranslate"><span class="pre">trunc</span></code> is greater than <span class="math notranslate nohighlight">\(n\)</span>. The algorithm begins by computing
the inverse transform of the first <span class="math notranslate nohighlight">\(n\)</span> coefficients of the input array.
The unspecified coefficients of the second half of the array are then
written: coefficient <code class="docutils literal notranslate"><span class="pre">trunc</span> <span class="pre">+</span> <span class="pre">i</span></code> is computed as a twist of
coefficient <code class="docutils literal notranslate"><span class="pre">i</span></code> by a root of unity. The values of these coefficients
are then equal to what they would have been if the inverse transform of
the right hand side of the input array had been computed with full data
from the start. The function <code class="docutils literal notranslate"><span class="pre">ifft_truncate1</span></code> is then called on the
entire right half of the input array with this auxiliary data filled in.
Finally a single layer of the IFFT is completed on all the coefficients
up to <code class="docutils literal notranslate"><span class="pre">trunc</span></code> being careful to note that this involves doubling the
coefficients from <code class="docutils literal notranslate"><span class="pre">trunc</span> <span class="pre">-</span> <span class="pre">n</span></code> up to <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_truncate1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_truncate1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_truncate1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the first <code class="docutils literal notranslate"><span class="pre">trunc</span></code> coefficients of the radix 2 inverse
transform assuming the first <code class="docutils literal notranslate"><span class="pre">trunc</span></code> coefficients are given and that
the remaining coefficients have been set to the value they would have if
an inverse transform had already been applied with full data.</p>
<p>The algorithm is the same as for <code class="docutils literal notranslate"><span class="pre">ifft_truncate</span></code> except that the
coefficients from <code class="docutils literal notranslate"><span class="pre">trunc</span></code> onwards after the inverse transform are
not inferred to be zero but the supplied values.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_butterfly_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_butterfly_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_butterfly_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(w = 2k + 1\)</span>, <span class="math notranslate nohighlight">\(i = 2j + 1\)</span>. Set <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">i1</span> <span class="pre">+</span> <span class="pre">i2</span></code>,
<code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">z1^i*(i1</span> <span class="pre">-</span> <span class="pre">i2)</span></code> modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> where
<code class="docutils literal notranslate"><span class="pre">z1^2</span> <span class="pre">=</span> <span class="pre">exp(Pi*I/n)</span></code> corresponds to multiplication by <span class="math notranslate nohighlight">\(2^w\)</span>. Requires
<span class="math notranslate nohighlight">\(0 \leq i &lt; 2n\)</span> where <span class="math notranslate nohighlight">\(nw =\)</span> <code class="docutils literal notranslate"><span class="pre">limbs*FLINT_BITS</span></code>.</p>
<p>Here <code class="docutils literal notranslate"><span class="pre">z1</span></code> corresponds to multiplication by <span class="math notranslate nohighlight">\(2^k\)</span> then multiplication
by <code class="docutils literal notranslate"><span class="pre">(2^(3nw/4)</span> <span class="pre">-</span> <span class="pre">2^(nw/4))</span></code>. We see <code class="docutils literal notranslate"><span class="pre">z1^i</span></code> corresponds to
multiplication by <code class="docutils literal notranslate"><span class="pre">(2^(3nw/4)</span> <span class="pre">-</span> <span class="pre">2^(nw/4))*2^(j+ik)</span></code>.</p>
<p>We first multiply by <code class="docutils literal notranslate"><span class="pre">2^(j</span> <span class="pre">+</span> <span class="pre">ik</span> <span class="pre">+</span> <span class="pre">wn/4)</span></code> then multiply by an
additional <code class="docutils literal notranslate"><span class="pre">2^(nw/2)</span></code> and subtract.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_butterfly_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_butterfly_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_butterfly_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(w = 2k + 1\)</span>, <span class="math notranslate nohighlight">\(i = 2j + 1\)</span>. Set <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">i1</span> <span class="pre">+</span> <span class="pre">z1^i*i2</span></code>,
<code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">i1</span> <span class="pre">-</span> <span class="pre">z1^i*i2</span></code> modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> where
<code class="docutils literal notranslate"><span class="pre">z1^2</span> <span class="pre">=</span> <span class="pre">exp(-Pi*I/n)</span></code> corresponds to division by <span class="math notranslate nohighlight">\(2^w\)</span>. Requires
<span class="math notranslate nohighlight">\(0 \leq i &lt; 2n\)</span> where <span class="math notranslate nohighlight">\(nw =\)</span> <code class="docutils literal notranslate"><span class="pre">limbs*FLINT_BITS</span></code>.</p>
<p>Here <code class="docutils literal notranslate"><span class="pre">z1</span></code> corresponds to division by <span class="math notranslate nohighlight">\(2^k\)</span> then division by
<code class="docutils literal notranslate"><span class="pre">(2^(3nw/4)</span> <span class="pre">-</span> <span class="pre">2^(nw/4))</span></code>. We see <code class="docutils literal notranslate"><span class="pre">z1^i</span></code> corresponds to division
by <code class="docutils literal notranslate"><span class="pre">(2^(3nw/4)</span> <span class="pre">-</span> <span class="pre">2^(nw/4))*2^(j+ik)</span></code> which is the same as division
by <code class="docutils literal notranslate"><span class="pre">2^(j+ik</span> <span class="pre">+</span> <span class="pre">1)</span></code> then multiplication by
<code class="docutils literal notranslate"><span class="pre">(2^(3nw/4)</span> <span class="pre">-</span> <span class="pre">2^(nw/4))</span></code>.</p>
<p>Of course, division by <code class="docutils literal notranslate"><span class="pre">2^(j+ik</span> <span class="pre">+</span> <span class="pre">1)</span></code> is the same as multiplication
by <code class="docutils literal notranslate"><span class="pre">2^(2*wn</span> <span class="pre">-</span> <span class="pre">j</span> <span class="pre">-</span> <span class="pre">ik</span> <span class="pre">-</span> <span class="pre">1)</span></code>. The exponent is positive as
<span class="math notranslate nohighlight">\(i \leq 2\cdot n\)</span>, <span class="math notranslate nohighlight">\(j &lt; n\)</span>, <span class="math notranslate nohighlight">\(k &lt; w/2\)</span>.</p>
<p>We first multiply by <code class="docutils literal notranslate"><span class="pre">2^(2*wn</span> <span class="pre">-</span> <span class="pre">j</span> <span class="pre">-</span> <span class="pre">ik</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">wn/4)</span></code> then multiply by
an additional <code class="docutils literal notranslate"><span class="pre">2^(nw/2)</span></code> and subtract.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_truncate_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_truncate_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_truncate_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">fft_truncate</span></code> except that the transform is twice the usual
length, i.e. length <span class="math notranslate nohighlight">\(4n\)</span> rather than <span class="math notranslate nohighlight">\(2n\)</span>. This is achieved by making use
of twiddles by powers of a square root of 2, not powers of 2 in the first
layer of the transform.</p>
<p>We require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64 and the three temporary space pointers
to point to blocks of size <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_truncate_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_truncate_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_truncate_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">ifft_truncate</span></code> except that the transform is twice the usual
length, i.e. length <span class="math notranslate nohighlight">\(4n\)</span> instead of <span class="math notranslate nohighlight">\(2n\)</span>. This is achieved by making use
of twiddles by powers of a square root of 2, not powers of 2 in the final
layer of the transform.</p>
<p>We require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64 and the three temporary space pointers
to point to blocks of size <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

</section>
<section id="matrix-fourier-transforms">
<h2>Matrix Fourier Transforms<a class="headerlink" href="#matrix-fourier-transforms" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fft_butterfly_twiddle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_butterfly_twiddle</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">u</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b1</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_butterfly_twiddle" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">2^b1*(s</span> <span class="pre">+</span> <span class="pre">t)</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">2^b2*(s</span> <span class="pre">-</span> <span class="pre">t)</span></code> modulo
<code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code>. This is used to compute
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">2^(ws*tw1)*(s</span> <span class="pre">+</span> <span class="pre">t)</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">2^(w+ws*tw2)*(s</span> <span class="pre">-</span> <span class="pre">t)</span></code> in the
matrix Fourier algorithm, i.e. effectively computing an ordinary butterfly
with additional twiddles by <code class="docutils literal notranslate"><span class="pre">z1^rc</span></code> for row <span class="math notranslate nohighlight">\(r\)</span> and column <span class="math notranslate nohighlight">\(c\)</span> of the
matrix of coefficients. Aliasing is not allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_butterfly_twiddle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_butterfly_twiddle</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">u</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b1</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_butterfly_twiddle" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">s/2^b1</span> <span class="pre">+</span> <span class="pre">t/2^b1)</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">s/2^b1</span> <span class="pre">-</span> <span class="pre">t/2^b1</span></code> modulo
<code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code>. This is used to compute
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">2^(-ws*tw1)*s</span> <span class="pre">+</span> <span class="pre">2^(-ws*tw2)*t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">2^(-ws*tw1)*s</span> <span class="pre">+</span> <span class="pre">2^(-ws*tw2)*t)</span></code> in the matrix Fourier algorithm,
i.e. effectively computing an ordinary butterfly with additional twiddles
by <code class="docutils literal notranslate"><span class="pre">z1^(-rc)</span></code> for row <span class="math notranslate nohighlight">\(r\)</span> and column <span class="math notranslate nohighlight">\(c\)</span> of the matrix of
coefficients. Aliasing is not allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_radix2_twiddle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_radix2_twiddle</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">is</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">ws</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">rs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_radix2_twiddle" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <code class="docutils literal notranslate"><span class="pre">fft_radix2</span></code> except that the coefficients are spaced by
<code class="docutils literal notranslate"><span class="pre">is</span></code> in the array <code class="docutils literal notranslate"><span class="pre">ii</span></code> and an additional twist by <code class="docutils literal notranslate"><span class="pre">z^c*i</span></code>
is applied to each coefficient where <span class="math notranslate nohighlight">\(i\)</span> starts at <span class="math notranslate nohighlight">\(r\)</span> and increases by
<code class="docutils literal notranslate"><span class="pre">rs</span></code> as one moves from one coefficient to the next. Here <code class="docutils literal notranslate"><span class="pre">z</span></code>
corresponds to multiplication by <code class="docutils literal notranslate"><span class="pre">2^ws</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_radix2_twiddle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_radix2_twiddle</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">is</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">ws</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">rs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_radix2_twiddle" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <code class="docutils literal notranslate"><span class="pre">ifft_radix2</span></code> except that the coefficients are spaced by
<code class="docutils literal notranslate"><span class="pre">is</span></code> in the array <code class="docutils literal notranslate"><span class="pre">ii</span></code> and an additional twist by
<code class="docutils literal notranslate"><span class="pre">z^(-c*i)</span></code> is applied to each coefficient where <span class="math notranslate nohighlight">\(i\)</span> starts at <span class="math notranslate nohighlight">\(r\)</span>
and increases by <code class="docutils literal notranslate"><span class="pre">rs</span></code> as one moves from one coefficient to the next.
Here <code class="docutils literal notranslate"><span class="pre">z</span></code> corresponds to multiplication by <code class="docutils literal notranslate"><span class="pre">2^ws</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_truncate1_twiddle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_truncate1_twiddle</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">is</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">ws</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">rs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_truncate1_twiddle" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">fft_radix2_twiddle</span></code> except that the transform is truncated
as per <code class="docutils literal notranslate"><span class="pre">fft_truncate1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_truncate1_twiddle">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_truncate1_twiddle</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">is</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">ws</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">rs</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_truncate1_twiddle" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">ifft_radix2_twiddle</span></code> except that the transform is truncated
as per <code class="docutils literal notranslate"><span class="pre">ifft_truncate1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_mfa_truncate_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_mfa_truncate_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_mfa_truncate_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is as per the <code class="docutils literal notranslate"><span class="pre">fft_truncate_sqrt2</span></code> function except that the
matrix Fourier algorithm is used for the left and right FFTs. The total
transform length is <span class="math notranslate nohighlight">\(4n\)</span> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2^depth</span></code> so that the left and
right transforms are both length <span class="math notranslate nohighlight">\(2n\)</span>. We require <code class="docutils literal notranslate"><span class="pre">trunc</span> <span class="pre">&gt;</span> <span class="pre">2*n</span></code> and
that <code class="docutils literal notranslate"><span class="pre">trunc</span></code> is divisible by <code class="docutils literal notranslate"><span class="pre">2*n1</span></code> (explained below). The coefficients
are produced in an order different from <code class="docutils literal notranslate"><span class="pre">fft_truncate_sqrt2</span></code>.</p>
<p>The matrix Fourier algorithm, which is applied to each transform of length
<span class="math notranslate nohighlight">\(2n\)</span>, works as follows. We set <code class="docutils literal notranslate"><span class="pre">n1</span></code> to a power of 2 about the square
root of <span class="math notranslate nohighlight">\(n\)</span>. The data is then thought of as a set of <code class="docutils literal notranslate"><span class="pre">n2</span></code> rows each
with <code class="docutils literal notranslate"><span class="pre">n1</span></code> columns (so that <code class="docutils literal notranslate"><span class="pre">n1*n2</span> <span class="pre">=</span> <span class="pre">2n</span></code>).</p>
<p>The length <span class="math notranslate nohighlight">\(2n\)</span> transform is then computed using a whole pile of short
transforms. These comprise <code class="docutils literal notranslate"><span class="pre">n1</span></code> column transforms of length <code class="docutils literal notranslate"><span class="pre">n2</span></code>
followed by some twiddles by roots of unity (namely <code class="docutils literal notranslate"><span class="pre">z^rc</span></code> where <span class="math notranslate nohighlight">\(r\)</span>
is the row and <span class="math notranslate nohighlight">\(c\)</span> the column within the data) followed by <code class="docutils literal notranslate"><span class="pre">n2</span></code>
row transforms of length <code class="docutils literal notranslate"><span class="pre">n1</span></code>. Along the way the data needs to be
rearranged due to the fact that the short transforms output the data in
binary reversed order compared with what is needed.</p>
<p>The matrix Fourier algorithm provides better cache locality by decomposing
the long length <span class="math notranslate nohighlight">\(2n\)</span> transforms into many transforms of about the square
root of the original length.</p>
<p>For better cache locality the sqrt2 layer of the full length <span class="math notranslate nohighlight">\(4n\)</span>
transform is folded in with the column FFTs performed as part of the first
matrix Fourier algorithm on the left half of the data.</p>
<p>The second half of the data requires a truncated version of the matrix
Fourier algorithm. This is achieved by truncating to an exact multiple of
the row length so that the row transforms are full length. Moreover, the
column transforms will then be truncated transforms and their truncated
length needs to be a multiple of 2. This explains the condition on
<code class="docutils literal notranslate"><span class="pre">trunc</span></code> given above.</p>
<p>To improve performance, the extra twiddles by roots of unity are combined
with the butterflies performed at the last layer of the column transforms.</p>
<p>We require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64 and the three temporary space pointers
to point to blocks of size <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_mfa_truncate_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_mfa_truncate_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_mfa_truncate_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is as per the <code class="docutils literal notranslate"><span class="pre">ifft_truncate_sqrt2</span></code> function except that the
matrix Fourier algorithm is used for the left and right IFFTs. The total
transform length is <span class="math notranslate nohighlight">\(4n\)</span> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2^depth</span></code> so that the left and
right transforms are both length <span class="math notranslate nohighlight">\(2n\)</span>. We require <code class="docutils literal notranslate"><span class="pre">trunc</span> <span class="pre">&gt;</span> <span class="pre">2*n</span></code> and
that <code class="docutils literal notranslate"><span class="pre">trunc</span></code> is divisible by <code class="docutils literal notranslate"><span class="pre">2*n1</span></code>.</p>
<p>We set <code class="docutils literal notranslate"><span class="pre">n1</span></code> to a power of 2 about the square root of <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>As per the matrix fourier FFT the sqrt2 layer is folded into the
final column IFFTs for better cache locality and the extra twiddles that
occur in the matrix Fourier algorithm are combined with the butterflied
performed at the first layer of the final column transforms.</p>
<p>We require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64 and the three temporary space pointers
to point to blocks of size <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_mfa_truncate_sqrt2_outer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_mfa_truncate_sqrt2_outer</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_mfa_truncate_sqrt2_outer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Just the outer layers of <code class="docutils literal notranslate"><span class="pre">fft_mfa_truncate_sqrt2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_mfa_truncate_sqrt2_inner">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_mfa_truncate_sqrt2_inner</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">jj</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_mfa_truncate_sqrt2_inner" title="Link to this definition">¶</a><br /></dt>
<dd><p>The inner layers of <code class="docutils literal notranslate"><span class="pre">fft_mfa_truncate_sqrt2</span></code> and
<code class="docutils literal notranslate"><span class="pre">ifft_mfa_truncate_sqrt2</span></code> combined with pointwise mults.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_mfa_truncate_sqrt2_outer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_mfa_truncate_sqrt2_outer</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_mfa_truncate_sqrt2_outer" title="Link to this definition">¶</a><br /></dt>
<dd><p>The outer layers of <code class="docutils literal notranslate"><span class="pre">ifft_mfa_truncate_sqrt2</span></code> combined with
normalisation.</p>
</dd></dl>

</section>
<section id="negacyclic-multiplication">
<h2>Negacyclic multiplication<a class="headerlink" href="#negacyclic-multiplication" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fft_negacyclic">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_negacyclic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_negacyclic" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">fft_radix2</span></code> except that it performs a sqrt2 negacyclic
transform of length <span class="math notranslate nohighlight">\(2n\)</span>. This is the same as the radix 2 transform
except that the <span class="math notranslate nohighlight">\(i\)</span>-th coefficient of the input is first multiplied by
<span class="math notranslate nohighlight">\(\sqrt{2}^{iw}\)</span>.</p>
<p>We require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64 and the two temporary space pointers to
point to blocks of size <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.ifft_negacyclic">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ifft_negacyclic</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.ifft_negacyclic" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">ifft_radix2</span></code> except that it performs a sqrt2 negacyclic
inverse transform of length <span class="math notranslate nohighlight">\(2n\)</span>. This is the same as the radix 2 inverse
transform except that the <span class="math notranslate nohighlight">\(i\)</span>-th coefficient of the output is finally
divided by <span class="math notranslate nohighlight">\(\sqrt{2}^{iw}\)</span>.</p>
<p>We require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64 and the two temporary space pointers to
point to blocks of size <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_naive_convolution_1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_naive_convolution_1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">jj</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_naive_convolution_1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs a naive negacyclic convolution of <code class="docutils literal notranslate"><span class="pre">ii</span></code> with <code class="docutils literal notranslate"><span class="pre">jj</span></code>,
both of length <span class="math notranslate nohighlight">\(m\)</span>, and sets <span class="math notranslate nohighlight">\(r\)</span> to the result. This is essentially
multiplication of polynomials modulo <span class="math notranslate nohighlight">\(x^m + 1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fft_mulmod_2expp1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fft_mulmod_2expp1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">r_limbs</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">depth</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fft_mulmod_2expp1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Multiply <code class="docutils literal notranslate"><span class="pre">i1</span></code> by <code class="docutils literal notranslate"><span class="pre">i2</span></code> modulo <code class="docutils literal notranslate"><span class="pre">B^r_limbs</span> <span class="pre">+</span> <span class="pre">1</span></code> where
<code class="docutils literal notranslate"><span class="pre">r_limbs</span> <span class="pre">=</span> <span class="pre">nw/FLINT_BITS</span></code> with <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2^depth</span></code>. Uses the
negacyclic FFT convolution CRT’d with a 1 limb naive convolution. We
require that <code class="docutils literal notranslate"><span class="pre">depth</span></code> and <code class="docutils literal notranslate"><span class="pre">w</span></code> have been selected as per the
wrapper <code class="docutils literal notranslate"><span class="pre">fft_mulmod_2expp1</span></code> below.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_adjust_limbs">
<a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_adjust_limbs</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_adjust_limbs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a number of limbs, returns a new number of limbs (no more than
the next power of 2) which will work with the Nussbaumer code. It is only
necessary to make this adjustment if
<code class="docutils literal notranslate"><span class="pre">limbs</span> <span class="pre">&gt;</span> <span class="pre">FFT_MULMOD_2EXPP1_CUTOFF</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_mulmod_2expp1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_mulmod_2expp1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_mulmod_2expp1" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">_fft_mulmod_2expp1</span></code> but with a tuned cutoff below which more
classical methods are used for the convolution. The temporary space is
required to fit <code class="docutils literal notranslate"><span class="pre">n*w</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> bits. There are no restrictions
on <span class="math notranslate nohighlight">\(n\)</span>, but if <code class="docutils literal notranslate"><span class="pre">limbs</span> <span class="pre">=</span> <span class="pre">n*w/FLINT_BITS</span></code> then if <code class="docutils literal notranslate"><span class="pre">limbs</span></code> exceeds
<code class="docutils literal notranslate"><span class="pre">FFT_MULMOD_2EXPP1_CUTOFF</span></code> the function <code class="docutils literal notranslate"><span class="pre">fft_adjust_limbs</span></code> must
be called to increase the number of limbs to an appropriate value.</p>
</dd></dl>

</section>
<section id="integer-multiplication">
<h2>Integer multiplication<a class="headerlink" href="#integer-multiplication" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mul_truncate_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mul_truncate_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n2</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">depth</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mul_truncate_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Integer multiplication using the radix 2 truncated sqrt2 transforms.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">(r1,</span> <span class="pre">n1</span> <span class="pre">+</span> <span class="pre">n2)</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">(i1,</span> <span class="pre">n1)</span></code> by
<code class="docutils literal notranslate"><span class="pre">(i2,</span> <span class="pre">n2)</span></code>. This is achieved through an FFT convolution of length at
most <code class="docutils literal notranslate"><span class="pre">2^(depth</span> <span class="pre">+</span> <span class="pre">2)</span></code> with coefficients of size <span class="math notranslate nohighlight">\(nw\)</span> bits where
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2^depth</span></code>. We require <code class="docutils literal notranslate"><span class="pre">depth</span> <span class="pre">&gt;=</span> <span class="pre">6</span></code>. The input data is
broken into chunks of data not exceeding <code class="docutils literal notranslate"><span class="pre">(nw</span> <span class="pre">-</span> <span class="pre">(depth</span> <span class="pre">+</span> <span class="pre">1))/2</span></code>
bits. If breaking the first integer into chunks of this size results in
<code class="docutils literal notranslate"><span class="pre">j1</span></code> coefficients and breaking the second integer results in
<code class="docutils literal notranslate"><span class="pre">j2</span></code> chunks then <code class="docutils literal notranslate"><span class="pre">j1</span> <span class="pre">+</span> <span class="pre">j2</span> <span class="pre">-</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">2^(depth</span> <span class="pre">+</span> <span class="pre">2)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2^depth</span></code> then we require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mul_mfa_truncate_sqrt2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mul_mfa_truncate_sqrt2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n2</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">depth</span></span>, <a class="reference internal" href="flint.html#c.flint_bitcnt_t" title="flint_bitcnt_t"><span class="n"><span class="pre">flint_bitcnt_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">w</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mul_mfa_truncate_sqrt2" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <code class="docutils literal notranslate"><span class="pre">mul_truncate_sqrt2</span></code> except that the cache friendly matrix
Fourier algorithm is used.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2^depth</span></code> then we require <span class="math notranslate nohighlight">\(nw\)</span> to be at least 64. Here we
also require <span class="math notranslate nohighlight">\(w\)</span> to be <span class="math notranslate nohighlight">\(2^i\)</span> for some <span class="math notranslate nohighlight">\(i \geq 0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.flint_mpn_mul_fft_main">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flint_mpn_mul_fft_main</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n1</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">i2</span></span>, <span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.flint_mpn_mul_fft_main" title="Link to this definition">¶</a><br /></dt>
<dd><p>The main integer multiplication routine. Sets <code class="docutils literal notranslate"><span class="pre">(r1,</span> <span class="pre">n1</span> <span class="pre">+</span> <span class="pre">n2)</span></code> to
<code class="docutils literal notranslate"><span class="pre">(i1,</span> <span class="pre">n1)</span></code> times <code class="docutils literal notranslate"><span class="pre">(i2,</span> <span class="pre">n2)</span></code>. We require <code class="docutils literal notranslate"><span class="pre">n1</span> <span class="pre">&gt;=</span> <span class="pre">n2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</dd></dl>

</section>
<section id="convolution">
<h2>Convolution<a class="headerlink" href="#convolution" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fft_convolution">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_convolution</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">jj</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">depth</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">trunc</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_convolution" title="Link to this definition">¶</a><br /></dt>
<dd><p>Perform an FFT convolution of <code class="docutils literal notranslate"><span class="pre">ii</span></code> with <code class="docutils literal notranslate"><span class="pre">jj</span></code>, both of length
<code class="docutils literal notranslate"><span class="pre">4*n</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2^depth</span></code>. Assume that all but the first
<code class="docutils literal notranslate"><span class="pre">trunc</span></code> coefficients of the output (placed in <code class="docutils literal notranslate"><span class="pre">ii</span></code>) are zero.
Each coefficient is taken modulo <code class="docutils literal notranslate"><span class="pre">B^limbs</span> <span class="pre">+</span> <span class="pre">1</span></code>. The temporary
spaces <code class="docutils literal notranslate"><span class="pre">t1</span></code>, <code class="docutils literal notranslate"><span class="pre">t2</span></code> and <code class="docutils literal notranslate"><span class="pre">s1</span></code> must have <code class="docutils literal notranslate"><span class="pre">limbs</span> <span class="pre">+</span> <span class="pre">1</span></code>
limbs of space and <code class="docutils literal notranslate"><span class="pre">tt</span></code> must have <code class="docutils literal notranslate"><span class="pre">2*(limbs</span> <span class="pre">+</span> <span class="pre">1)</span></code> of free
space.</p>
</dd></dl>

</section>
<section id="fft-precaching">
<h2>FFT Precaching<a class="headerlink" href="#fft-precaching" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fft_precache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_precache</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">jj</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">depth</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">trunc</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s1</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_precache" title="Link to this definition">¶</a><br /></dt>
<dd><p>Precompute the FFT of <code class="docutils literal notranslate"><span class="pre">jj</span></code> for use with precache functions. The
parameters are as for <code class="docutils literal notranslate"><span class="pre">fft_convolution</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fft_convolution_precache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fft_convolution_precache</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ii</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">jj</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">depth</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">limbs</span></span>, <a class="reference internal" href="flint.html#c.slong" title="slong"><span class="n"><span class="pre">slong</span></span></a><span class="w"> </span><span class="n"><span class="pre">trunc</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fft_convolution_precache" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">fft_convolution</span></code> except that it is assumed <code class="docutils literal notranslate"><span class="pre">fft_precache</span></code> has
been called on <code class="docutils literal notranslate"><span class="pre">jj</span></code> with the same parameters. This will then run faster
than if <code class="docutils literal notranslate"><span class="pre">fft_convolution</span></code> had been run with the original <code class="docutils literal notranslate"><span class="pre">jj</span></code>.</p>
</dd></dl>

</section>
</section>

</main>

                  
<!-- #Article navigation -->
<nav class="my-8">
  <ul
    class="text-secondary-content flex justify-between gap-4"
  >
    
      <li class="flex flex-col gap-1">
        <span class="flex items-center text-xs font-light">
          <span class="icon-[prime--angle-left]"></span>
          Previous
        </span>
        <a
          class="hover:text-accent-content text-sm underline"
          href="arith.html"
          title="Previous article"
          ><strong>arith.h</strong> – arithmetic and special functions</a
        >
      </li>
    
    
      <li class="flex flex-col gap-1 lg:items-end">
        <span class="flex items-center text-xs font-light">
          Next
          <span class="icon-[prime--angle-right]"></span>
        </span>
        <a
          class="hover:text-accent-content text-sm underline"
          href="fft_small.html"
          title="Next article"
          ><strong>fft_small.h</strong> – FFT modulo word-size primes</a
        >
      </li>
    
  </ul>
</nav>
<!-- .#Article navigation -->
                  
<!-- #Article footer -->
<footer
  class="article-footer border-base-200 text-secondary-content/80 my-4 border-t pt-8 text-sm"
>
  <div class="flex flex-col justify-between gap-4 lg:flex-row">
    <div class="article-footer__left">
      
      
    </div>
    <div class="article-footer__right">
      
      
    </div>
  </div>
</footer>
<!-- .#Article footer -->
                </article>

                <!-- #Primary drawer (desktop) -->
                <nav
                  class="lg:sticky lg:top-[calc(var(--header-height)+var(--header-padding))] lg:h-[calc(100vh-var(--header-height)-calc(var(--header-padding)*2))] lg:overflow-y-auto scrollbar-overlay hidden lg:order-1 lg:block lg:w-2/12 lg:flex-none"
                >
                  


  <div class="global-toc">
    <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html"><strong>Building, testing and installing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="bug_reporting.html"><strong>Bug reporting</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing to FLINT</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html"><strong>Contributors</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html"><strong>Memory management</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="portability.html"><strong>Portability</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="threading.html"><strong>Threading</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flint.html"><strong>flint.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html"><strong>profiler.h</strong> – performance profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread_pool.html"><strong>thread_pool.h</strong> – thread pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpoly.html"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_vectors.html"><strong>machine_vectors.h</strong> – SIMD-accelerated operations on fixed-length vectors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generic rings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gr.html"><strong>gr.h</strong> – generic structures and their elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_implementing.html"><strong>gr.h (continued)</strong> – implementing rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_domains.html"><strong>gr.h (continued)</strong> – builtin domains and types</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_generic.html"><strong>gr_generic.h</strong> – basic algorithms and fallback implementations for generic elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_special.html"><strong>gr_special.h</strong> – special arithmetic and transcendental functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_vec.html"><strong>gr_vec.h</strong> – vectors over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mat.html"><strong>gr_mat.h</strong> – dense matrices over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_poly.html"><strong>gr_poly.h</strong> – dense univariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mpoly.html"><strong>gr_mpoly.h</strong> – sparse multivariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_series.html"><strong>gr_series.h</strong> – formal power series over generic rings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_generic.html"><strong>Generic rings</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ulong_extras.html"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz.html"><strong>fmpz.h</strong> – integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_vec.html"><strong>fmpz_vec.h</strong> – vectors of integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_factor.html"><strong>fmpz_factor.h</strong> – integer factorisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mat.html"><strong>fmpz_mat.h</strong> – matrices over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_lll.html"><strong>fmpz_lll.h</strong> – LLL reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly.html"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_mat.html"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_factor.html"><strong>fmpz_poly_factor.h</strong> – factorisation of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly.html"><strong>fmpz_mpoly.h</strong> – multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_factor.html"><strong>fmpz_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="long_extras.html"><strong>long_extras.h</strong> – support functions for signed word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="longlong.html"><strong>longlong.h</strong> – support functions for multi-word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_extras.html"><strong>mpn_extras.h</strong> – support functions for limb arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="aprcl.html"><strong>aprcl.h</strong> – APRCL primality testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arith.html"><strong>arith.h</strong> – arithmetic and special functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft_small.html"><strong>fft_small.h</strong> – FFT modulo word-size primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="qsieve.html"><strong>qsieve.h</strong> – Quadratic sieve</a></li>
<li class="toctree-l1"><a class="reference internal" href="radix.html"><strong>radix.h</strong> – multiprecision arithmetic in general radix</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index_integers.html"><strong>Integers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Rational numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fmpq.html"><strong>fmpq.h</strong> – rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_vec.html"><strong>fmpq_vec.h</strong> – vectors over rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mat.html"><strong>fmpq_mat.h</strong> – matrices over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_poly.html"><strong>fmpq_poly.h</strong> – univariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly_factor.html"><strong>fmpq_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly.html"><strong>fmpq_mpoly.h</strong> – multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_q.html"><strong>fmpz_poly_q.h</strong> – rational functions over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_q.html"><strong>fmpz_mpoly_q.h</strong> – multivariate rational functions over Q</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_rationals.html"><strong>Rational numbers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers mod n</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nmod.html"><strong>nmod.h</strong> – integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_vec.html"><strong>nmod_vec.h</strong> – vectors over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mat.html"><strong>nmod_mat.h</strong> – matrices over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly.html"><strong>nmod_poly.h</strong> – univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_mat.html"><strong>nmod_poly_mat.h</strong> – matrices of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_factor.html"><strong>nmod_poly_factor.h</strong> – factorisation of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly.html"><strong>nmod_mpoly.h</strong> – multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly_factor.html"><strong>nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_mod.html"><strong>mpn_mod.h</strong> – integers mod n (packed multi-word n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod.html"><strong>fmpz_mod.h</strong> – arithmetic modulo integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_vec.html"><strong>fmpz_mod_vec.h</strong> – vectors over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mat.html"><strong>fmpz_mod_mat.h</strong> – matrices over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly.html"><strong>fmpz_mod_poly.h</strong> – polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly_factor.html"><strong>fmpz_mod_poly_factor.h</strong> – factorisation of polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly.html"><strong>fmpz_mod_mpoly.h</strong> – polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_factor.html"><strong>fmpz_mod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_q.html"><strong>fmpz_mod_mpoly_q.h</strong> – multivariate rational functions over Z/mZ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers_mod.html"><strong>Integers mod n</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Groups and other structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="perm.html"><strong>perm.h</strong> – permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="qfb.html"><strong>qfb.h</strong> – binary quadratic forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dirichlet.html"><strong>dirichlet.h</strong> – Dirichlet characters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlog.html"><strong>dlog.h</strong> – discrete logarithms mod ulong primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="bool_mat.html"><strong>bool_mat.h</strong> – matrices over booleans</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Number fields and algebraic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nf.html"><strong>nf.h</strong> – number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="nf_elem.html"><strong>nf_elem.h</strong> – number field elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpzi.html"><strong>fmpzi.h</strong> – Gaussian integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qqbar.html"><strong>qqbar.h</strong> – algebraic numbers represented by minimal polynomials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Feature overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using ball arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Technical conventions and potential issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_arb.html">Arb example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="mag.html"><strong>mag.h</strong> – fixed-precision unsigned floating-point numbers for bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="nfloat.html"><strong>nfloat.h</strong> – packed floating-point numbers with n-word precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="arf.html"><strong>arf.h</strong> – arbitrary-precision floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acf.html"><strong>acf.h</strong> – complex floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb.html"><strong>arb.h</strong> – real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb.html"><strong>acb.h</strong> – complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_poly.html"><strong>arb_poly.h</strong> – polynomials over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_poly.html"><strong>acb_poly.h</strong> – polynomials over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fmpz_poly.html"><strong>arb_fmpz_poly.h</strong> – extra methods for integer polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dft.html"><strong>acb_dft.h</strong> – Discrete Fourier transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_mat.html"><strong>arb_mat.h</strong> – matrices over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_mat.html"><strong>acb_mat.h</strong> – matrices over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_hypgeom.html"><strong>acb_hypgeom.h</strong> – hypergeometric functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_hypgeom.html"><strong>arb_hypgeom.h</strong> – hypergeometric functions of real variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_elliptic.html"><strong>acb_elliptic.h</strong> – elliptic integrals and functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_modular.html"><strong>acb_modular.h</strong> – modular forms of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_theta.html"><strong>acb_theta.h</strong> – Riemann theta functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dirichlet.html"><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bernoulli.html"><strong>bernoulli.h</strong> – support for Bernoulli numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypgeom.html"><strong>hypgeom.h</strong> – support for hypergeometric series</a></li>
<li class="toctree-l1"><a class="reference internal" href="partitions.html"><strong>partitions.h</strong> – computation of the partition function</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_calc.html"><strong>arb_calc.h</strong> – calculus with real-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_calc.html"><strong>acb_calc.h</strong> – calculus with complex-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fpwrap.html"><strong>arb_fpwrap.h</strong> – floating-point wrappers of Arb mathematical functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_extras.html"><strong>fmpz_extras.h</strong> – extra methods for FLINT integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">General formulas and bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">Algorithms for mathematical constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma.html">Algorithms for the gamma function</a></li>
<li class="toctree-l1"><a class="reference internal" href="hurwitz.html">Algorithms for the Hurwitz zeta function</a></li>
<li class="toctree-l1"><a class="reference internal" href="polylogarithms.html">Algorithms for polylogarithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergeometric.html">Algorithms for hypergeometric functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="agm.html">Algorithms for the arithmetic-geometric mean</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_arb.html"><strong>Real and complex numbers (Arb)</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_calcium.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_calcium.html">Calcium example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="calcium.html"><strong>calcium.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca.html"><strong>ca.h</strong> – exact real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_vec.html"><strong>ca_vec.h</strong> – vectors of real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_poly.html"><strong>ca_poly.h</strong> – dense univariate polynomials over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_mat.html"><strong>ca_mat.h</strong> – matrices over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_ext.html"><strong>ca_ext.h</strong> – real and complex extension numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_field.html"><strong>ca_field.h</strong> – extension fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr.html"><strong>fexpr.h</strong> – flat-packed symbolic expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr_builtin.html"><strong>fexpr_builtin.h</strong> – builtin symbols</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite fields</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq.html"><strong>fq.h</strong> – finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default.html"><strong>fq_default.h</strong> – unified finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_vec.html"><strong>fq_vec.h</strong> – vectors over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_mat.html"><strong>fq_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_mat.html"><strong>fq_default_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly.html"><strong>fq_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly.html"><strong>fq_default_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly_factor.html"><strong>fq_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly_factor.html"><strong>fq_default_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_embed.html"><strong>fq_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod.html"><strong>fq_nmod.h</strong> – finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_vec.html"><strong>fq_nmod_vec.h</strong> – vectors over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mat.html"><strong>fq_nmod_mat.h</strong> – matrices over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly.html"><strong>fq_nmod_poly.h</strong> – univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly_factor.html"><strong>fq_nmod_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_embed.html"><strong>fq_nmod_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly.html"><strong>fq_nmod_mpoly.h</strong> – multivariate polynomials over finite fields of word-sized characteristic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly_factor.html"><strong>fq_nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over finite fields of word-sized characteristic</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_zech.html"><strong>fq_zech.h</strong> – finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_vec.html"><strong>fq_zech_vec.h</strong> – vectors over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_mat.html"><strong>fq_zech_mat.h</strong> – matrices over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly.html"><strong>fq_zech_poly.h</strong> – univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly_factor.html"><strong>fq_zech_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_embed.html"><strong>fq_zech_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">p-adic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="padic.html"><strong>padic.h</strong> – p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_poly.html"><strong>padic_poly.h</strong> – polynomials over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_mat.html"><strong>padic_mat.h</strong> – matrices over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qadic.html"><strong>qadic.h</strong> – unramified extensions over p-adic numbers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Floating-point support code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="double_extras.html"><strong>double_extras.h</strong> – support functions for double arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="double_interval.html"><strong>double_interval.h</strong> – double-precision interval arithmetic and helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_vec.html"><strong>d_vec.h</strong> – double precision vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_mat.html"><strong>d_mat.h</strong> – double precision matrices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_flint.html"><strong>flint_ctypes</strong> - Python interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Version history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="history.html">History and changes</a></li>
</ul>

  </div>

                </nav>
                <!-- .#Primary drawer (desktop) -->

                <!-- #Secondary drawer (desktop) -->
                <aside
                  class="lg:sticky lg:top-[calc(var(--header-height)+var(--header-padding))] lg:h-[calc(100vh-var(--header-height)-calc(var(--header-padding)*2))] lg:overflow-y-auto scrollbar-overlay hidden lg:order-3 lg:block lg:w-2/12 lg:flex-none"
                >
                  


  
    <div class="local-toc">
      <p class="local-toc__caption mt-0 mb-4 font-semibold uppercase">
        On this page
      </p>
      <ul>
<li><a class="reference internal" href="#"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a><ul>
<li><a class="reference internal" href="#split-combine-fft-coefficients">Split/combine FFT coefficients</a><ul>
<li><a class="reference internal" href="#c.fft_split_limbs"><code class="docutils literal notranslate"><span class="pre">fft_split_limbs()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_split_bits"><code class="docutils literal notranslate"><span class="pre">fft_split_bits()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_combine_limbs"><code class="docutils literal notranslate"><span class="pre">fft_combine_limbs()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_combine_bits"><code class="docutils literal notranslate"><span class="pre">fft_combine_bits()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-helper-functions">Test helper functions</a><ul>
<li><a class="reference internal" href="#c.fermat_to_mpz"><code class="docutils literal notranslate"><span class="pre">fermat_to_mpz()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#arithmetic-modulo-a-generalised-fermat-number">Arithmetic modulo a generalised Fermat number</a><ul>
<li><a class="reference internal" href="#c.mpn_negmod_2expp1"><code class="docutils literal notranslate"><span class="pre">mpn_negmod_2expp1()</span></code></a></li>
<li><a class="reference internal" href="#c.mpn_addmod_2expp1_1"><code class="docutils literal notranslate"><span class="pre">mpn_addmod_2expp1_1()</span></code></a></li>
<li><a class="reference internal" href="#c.mpn_normmod_2expp1"><code class="docutils literal notranslate"><span class="pre">mpn_normmod_2expp1()</span></code></a></li>
<li><a class="reference internal" href="#c.mpn_mul_2expmod_2expp1"><code class="docutils literal notranslate"><span class="pre">mpn_mul_2expmod_2expp1()</span></code></a></li>
<li><a class="reference internal" href="#c.mpn_div_2expmod_2expp1"><code class="docutils literal notranslate"><span class="pre">mpn_div_2expmod_2expp1()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-butterflies">Generic butterflies</a><ul>
<li><a class="reference internal" href="#c.fft_adjust"><code class="docutils literal notranslate"><span class="pre">fft_adjust()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_adjust_sqrt2"><code class="docutils literal notranslate"><span class="pre">fft_adjust_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.butterfly_lshB"><code class="docutils literal notranslate"><span class="pre">butterfly_lshB()</span></code></a></li>
<li><a class="reference internal" href="#c.butterfly_rshB"><code class="docutils literal notranslate"><span class="pre">butterfly_rshB()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#radix-2-transforms">Radix 2 transforms</a><ul>
<li><a class="reference internal" href="#c.fft_butterfly"><code class="docutils literal notranslate"><span class="pre">fft_butterfly()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_butterfly"><code class="docutils literal notranslate"><span class="pre">ifft_butterfly()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_radix2"><code class="docutils literal notranslate"><span class="pre">fft_radix2()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_truncate"><code class="docutils literal notranslate"><span class="pre">fft_truncate()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_truncate1"><code class="docutils literal notranslate"><span class="pre">fft_truncate1()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_radix2"><code class="docutils literal notranslate"><span class="pre">ifft_radix2()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_truncate"><code class="docutils literal notranslate"><span class="pre">ifft_truncate()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_truncate1"><code class="docutils literal notranslate"><span class="pre">ifft_truncate1()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_butterfly_sqrt2"><code class="docutils literal notranslate"><span class="pre">fft_butterfly_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_butterfly_sqrt2"><code class="docutils literal notranslate"><span class="pre">ifft_butterfly_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">fft_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">ifft_truncate_sqrt2()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-fourier-transforms">Matrix Fourier Transforms</a><ul>
<li><a class="reference internal" href="#c.fft_butterfly_twiddle"><code class="docutils literal notranslate"><span class="pre">fft_butterfly_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_butterfly_twiddle"><code class="docutils literal notranslate"><span class="pre">ifft_butterfly_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_radix2_twiddle"><code class="docutils literal notranslate"><span class="pre">fft_radix2_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_radix2_twiddle"><code class="docutils literal notranslate"><span class="pre">ifft_radix2_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_truncate1_twiddle"><code class="docutils literal notranslate"><span class="pre">fft_truncate1_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_truncate1_twiddle"><code class="docutils literal notranslate"><span class="pre">ifft_truncate1_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_mfa_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">fft_mfa_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_mfa_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">ifft_mfa_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_mfa_truncate_sqrt2_outer"><code class="docutils literal notranslate"><span class="pre">fft_mfa_truncate_sqrt2_outer()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_mfa_truncate_sqrt2_inner"><code class="docutils literal notranslate"><span class="pre">fft_mfa_truncate_sqrt2_inner()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_mfa_truncate_sqrt2_outer"><code class="docutils literal notranslate"><span class="pre">ifft_mfa_truncate_sqrt2_outer()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#negacyclic-multiplication">Negacyclic multiplication</a><ul>
<li><a class="reference internal" href="#c.fft_negacyclic"><code class="docutils literal notranslate"><span class="pre">fft_negacyclic()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_negacyclic"><code class="docutils literal notranslate"><span class="pre">ifft_negacyclic()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_naive_convolution_1"><code class="docutils literal notranslate"><span class="pre">fft_naive_convolution_1()</span></code></a></li>
<li><a class="reference internal" href="#c._fft_mulmod_2expp1"><code class="docutils literal notranslate"><span class="pre">_fft_mulmod_2expp1()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_adjust_limbs"><code class="docutils literal notranslate"><span class="pre">fft_adjust_limbs()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_mulmod_2expp1"><code class="docutils literal notranslate"><span class="pre">fft_mulmod_2expp1()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#integer-multiplication">Integer multiplication</a><ul>
<li><a class="reference internal" href="#c.mul_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">mul_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.mul_mfa_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">mul_mfa_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.flint_mpn_mul_fft_main"><code class="docutils literal notranslate"><span class="pre">flint_mpn_mul_fft_main()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#convolution">Convolution</a><ul>
<li><a class="reference internal" href="#c.fft_convolution"><code class="docutils literal notranslate"><span class="pre">fft_convolution()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fft-precaching">FFT Precaching</a><ul>
<li><a class="reference internal" href="#c.fft_precache"><code class="docutils literal notranslate"><span class="pre">fft_precache()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_convolution_precache"><code class="docutils literal notranslate"><span class="pre">fft_convolution_precache()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  

                </aside>
                <!-- .#Secondary drawer (desktop) -->
              </div>
            </main>

            
<footer class="p-4">
  <div
    class="text-secondary-content container mx-auto flex h-8 items-center justify-center text-center text-sm"
  >
    <div>
        Copyright &copy; 2009-2025, The FLINT development team
      <br class="lg:hidden" />
      Made with
      <a
        href="https://www.sphinx-doc.org"
        class="hover:text-accent-content underline"
        >Sphinx</a
      >
      and
      <a
        href="https://readcraft.io/sphinx-clarity-theme/?utm_source=sphinx_clarity_theme"
        class="hover:text-accent-content underline"
        >Clarity Theme for Sphinx </a
      >.
    </div>
  </div>
</footer>
          </div>

          
<!-- #Scroll to top -->
<div id="scroll-to-top" class="toast toast-end">
  <a
    class="btn btn-secondary btn-sm"
    href="#top"
    aria-label="Scroll to top"
  >
    Back to top
    <span class="icon-[prime--arrow-up] text-base"></span>
  </a>
</div>
<!-- .#Scroll to top -->
          
<!-- #Search dialog -->
<dialog id="searchModal" class="modal">
  <div class="modal-box absolute top-8 lg:top-16">
    <search>
      <form action="search.html" method="get">
        <label class="input input-xl w-full">
          <span class="icon-[prime--search] text-4xl"></span>
          <input
            type="search"
            class="grow"
            placeholder="Search the docs"
            name="q"
            placeholder="Search the documentation"
            aria-label="Search the documentation"
          />
          <kbd class="kbd kbd-lg p-4">Enter</kbd>
        </label>
      </form>
    </search>
    <p class="mt-4 text-sm">
      Press <kbd class="kbd">Enter</kbd> to search. Press
      <kbd class="kbd">Esc</kbd> or click outside to close.
    </p>
  </div>
  <form method="dialog" class="modal-backdrop">
    <button>close</button>
  </form>
</dialog>
<!-- .#Search dialog -->

          <!-- ====================================================== -->
          <!-- .Page content -->
          <!-- ====================================================== -->

          <!-- ====================================================== -->
          <!-- Secondary drawer after markup -->
          <!-- ====================================================== -->
        </div>
        <div class="drawer-side">
          <label
            for="secondary-drawer"
            class="drawer-overlay"
            aria-label="Close secondary sidebar"
          ></label>
          <div
            class="bg-base-100 text-base-content mt-[var(--header-height)] min-h-full w-80 overflow-y-auto p-4"
          >
            <!-- ==================================================== -->
            <!-- Secondary drawer (mobile) content -->
            <!-- ==================================================== -->
            <div class="text-xs">


  
    <div class="local-toc">
      <p class="local-toc__caption mt-0 mb-4 font-semibold uppercase">
        On this page
      </p>
      <ul>
<li><a class="reference internal" href="#"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a><ul>
<li><a class="reference internal" href="#split-combine-fft-coefficients">Split/combine FFT coefficients</a><ul>
<li><a class="reference internal" href="#c.fft_split_limbs"><code class="docutils literal notranslate"><span class="pre">fft_split_limbs()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_split_bits"><code class="docutils literal notranslate"><span class="pre">fft_split_bits()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_combine_limbs"><code class="docutils literal notranslate"><span class="pre">fft_combine_limbs()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_combine_bits"><code class="docutils literal notranslate"><span class="pre">fft_combine_bits()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-helper-functions">Test helper functions</a><ul>
<li><a class="reference internal" href="#c.fermat_to_mpz"><code class="docutils literal notranslate"><span class="pre">fermat_to_mpz()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#arithmetic-modulo-a-generalised-fermat-number">Arithmetic modulo a generalised Fermat number</a><ul>
<li><a class="reference internal" href="#c.mpn_negmod_2expp1"><code class="docutils literal notranslate"><span class="pre">mpn_negmod_2expp1()</span></code></a></li>
<li><a class="reference internal" href="#c.mpn_addmod_2expp1_1"><code class="docutils literal notranslate"><span class="pre">mpn_addmod_2expp1_1()</span></code></a></li>
<li><a class="reference internal" href="#c.mpn_normmod_2expp1"><code class="docutils literal notranslate"><span class="pre">mpn_normmod_2expp1()</span></code></a></li>
<li><a class="reference internal" href="#c.mpn_mul_2expmod_2expp1"><code class="docutils literal notranslate"><span class="pre">mpn_mul_2expmod_2expp1()</span></code></a></li>
<li><a class="reference internal" href="#c.mpn_div_2expmod_2expp1"><code class="docutils literal notranslate"><span class="pre">mpn_div_2expmod_2expp1()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-butterflies">Generic butterflies</a><ul>
<li><a class="reference internal" href="#c.fft_adjust"><code class="docutils literal notranslate"><span class="pre">fft_adjust()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_adjust_sqrt2"><code class="docutils literal notranslate"><span class="pre">fft_adjust_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.butterfly_lshB"><code class="docutils literal notranslate"><span class="pre">butterfly_lshB()</span></code></a></li>
<li><a class="reference internal" href="#c.butterfly_rshB"><code class="docutils literal notranslate"><span class="pre">butterfly_rshB()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#radix-2-transforms">Radix 2 transforms</a><ul>
<li><a class="reference internal" href="#c.fft_butterfly"><code class="docutils literal notranslate"><span class="pre">fft_butterfly()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_butterfly"><code class="docutils literal notranslate"><span class="pre">ifft_butterfly()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_radix2"><code class="docutils literal notranslate"><span class="pre">fft_radix2()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_truncate"><code class="docutils literal notranslate"><span class="pre">fft_truncate()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_truncate1"><code class="docutils literal notranslate"><span class="pre">fft_truncate1()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_radix2"><code class="docutils literal notranslate"><span class="pre">ifft_radix2()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_truncate"><code class="docutils literal notranslate"><span class="pre">ifft_truncate()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_truncate1"><code class="docutils literal notranslate"><span class="pre">ifft_truncate1()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_butterfly_sqrt2"><code class="docutils literal notranslate"><span class="pre">fft_butterfly_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_butterfly_sqrt2"><code class="docutils literal notranslate"><span class="pre">ifft_butterfly_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">fft_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">ifft_truncate_sqrt2()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-fourier-transforms">Matrix Fourier Transforms</a><ul>
<li><a class="reference internal" href="#c.fft_butterfly_twiddle"><code class="docutils literal notranslate"><span class="pre">fft_butterfly_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_butterfly_twiddle"><code class="docutils literal notranslate"><span class="pre">ifft_butterfly_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_radix2_twiddle"><code class="docutils literal notranslate"><span class="pre">fft_radix2_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_radix2_twiddle"><code class="docutils literal notranslate"><span class="pre">ifft_radix2_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_truncate1_twiddle"><code class="docutils literal notranslate"><span class="pre">fft_truncate1_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_truncate1_twiddle"><code class="docutils literal notranslate"><span class="pre">ifft_truncate1_twiddle()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_mfa_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">fft_mfa_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_mfa_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">ifft_mfa_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_mfa_truncate_sqrt2_outer"><code class="docutils literal notranslate"><span class="pre">fft_mfa_truncate_sqrt2_outer()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_mfa_truncate_sqrt2_inner"><code class="docutils literal notranslate"><span class="pre">fft_mfa_truncate_sqrt2_inner()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_mfa_truncate_sqrt2_outer"><code class="docutils literal notranslate"><span class="pre">ifft_mfa_truncate_sqrt2_outer()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#negacyclic-multiplication">Negacyclic multiplication</a><ul>
<li><a class="reference internal" href="#c.fft_negacyclic"><code class="docutils literal notranslate"><span class="pre">fft_negacyclic()</span></code></a></li>
<li><a class="reference internal" href="#c.ifft_negacyclic"><code class="docutils literal notranslate"><span class="pre">ifft_negacyclic()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_naive_convolution_1"><code class="docutils literal notranslate"><span class="pre">fft_naive_convolution_1()</span></code></a></li>
<li><a class="reference internal" href="#c._fft_mulmod_2expp1"><code class="docutils literal notranslate"><span class="pre">_fft_mulmod_2expp1()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_adjust_limbs"><code class="docutils literal notranslate"><span class="pre">fft_adjust_limbs()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_mulmod_2expp1"><code class="docutils literal notranslate"><span class="pre">fft_mulmod_2expp1()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#integer-multiplication">Integer multiplication</a><ul>
<li><a class="reference internal" href="#c.mul_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">mul_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.mul_mfa_truncate_sqrt2"><code class="docutils literal notranslate"><span class="pre">mul_mfa_truncate_sqrt2()</span></code></a></li>
<li><a class="reference internal" href="#c.flint_mpn_mul_fft_main"><code class="docutils literal notranslate"><span class="pre">flint_mpn_mul_fft_main()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#convolution">Convolution</a><ul>
<li><a class="reference internal" href="#c.fft_convolution"><code class="docutils literal notranslate"><span class="pre">fft_convolution()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fft-precaching">FFT Precaching</a><ul>
<li><a class="reference internal" href="#c.fft_precache"><code class="docutils literal notranslate"><span class="pre">fft_precache()</span></code></a></li>
<li><a class="reference internal" href="#c.fft_convolution_precache"><code class="docutils literal notranslate"><span class="pre">fft_convolution_precache()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  
</div>
          </div>
        </div>
      </div>

      <!-- ========================================================== -->
      <!-- Primary drawer after markup -->
      <!-- ========================================================== -->
    </div>

    <div class="drawer-side">
      <label
        for="primary-drawer"
        aria-label="Close primary sidebar"
        class="drawer-overlay"
      ></label>
      <div
        class="bg-base-100 text-base-content mt-[var(--header-height)] min-h-full w-80 overflow-y-auto p-4"
      >
        <!-- ===================================================== -->
        <!-- Primary drawer (mobile) content -->
        <!-- ===================================================== -->
        <div class="text-xs">


  <div class="global-toc">
    <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html"><strong>Introduction</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html"><strong>Building, testing and installing</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="bug_reporting.html"><strong>Bug reporting</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html"><strong>Contributing to FLINT</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html"><strong>Contributors</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html"><strong>Memory management</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="portability.html"><strong>Portability</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="threading.html"><strong>Threading</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">General utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="flint.html"><strong>flint.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="profiler.html"><strong>profiler.h</strong> – performance profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="thread_pool.html"><strong>thread_pool.h</strong> – thread pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpoly.html"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="machine_vectors.html"><strong>machine_vectors.h</strong> – SIMD-accelerated operations on fixed-length vectors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Generic rings</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gr.html"><strong>gr.h</strong> – generic structures and their elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_implementing.html"><strong>gr.h (continued)</strong> – implementing rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_domains.html"><strong>gr.h (continued)</strong> – builtin domains and types</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_generic.html"><strong>gr_generic.h</strong> – basic algorithms and fallback implementations for generic elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_special.html"><strong>gr_special.h</strong> – special arithmetic and transcendental functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_vec.html"><strong>gr_vec.h</strong> – vectors over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mat.html"><strong>gr_mat.h</strong> – dense matrices over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_poly.html"><strong>gr_poly.h</strong> – dense univariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_mpoly.html"><strong>gr_mpoly.h</strong> – sparse multivariate polynomials over generic rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gr_series.html"><strong>gr_series.h</strong> – formal power series over generic rings</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_generic.html"><strong>Generic rings</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ulong_extras.html"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz.html"><strong>fmpz.h</strong> – integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_vec.html"><strong>fmpz_vec.h</strong> – vectors of integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_factor.html"><strong>fmpz_factor.h</strong> – integer factorisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mat.html"><strong>fmpz_mat.h</strong> – matrices over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_lll.html"><strong>fmpz_lll.h</strong> – LLL reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly.html"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_mat.html"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_factor.html"><strong>fmpz_poly_factor.h</strong> – factorisation of polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly.html"><strong>fmpz_mpoly.h</strong> – multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_factor.html"><strong>fmpz_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="long_extras.html"><strong>long_extras.h</strong> – support functions for signed word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="longlong.html"><strong>longlong.h</strong> – support functions for multi-word arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_extras.html"><strong>mpn_extras.h</strong> – support functions for limb arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="aprcl.html"><strong>aprcl.h</strong> – APRCL primality testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="arith.html"><strong>arith.h</strong> – arithmetic and special functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="fft_small.html"><strong>fft_small.h</strong> – FFT modulo word-size primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="qsieve.html"><strong>qsieve.h</strong> – Quadratic sieve</a></li>
<li class="toctree-l1"><a class="reference internal" href="radix.html"><strong>radix.h</strong> – multiprecision arithmetic in general radix</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index_integers.html"><strong>Integers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Rational numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fmpq.html"><strong>fmpq.h</strong> – rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_vec.html"><strong>fmpq_vec.h</strong> – vectors over rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mat.html"><strong>fmpq_mat.h</strong> – matrices over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_poly.html"><strong>fmpq_poly.h</strong> – univariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly_factor.html"><strong>fmpq_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpq_mpoly.html"><strong>fmpq_mpoly.h</strong> – multivariate polynomials over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_poly_q.html"><strong>fmpz_poly_q.h</strong> – rational functions over the rational numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mpoly_q.html"><strong>fmpz_mpoly_q.h</strong> – multivariate rational functions over Q</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_rationals.html"><strong>Rational numbers</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Integers mod n</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nmod.html"><strong>nmod.h</strong> – integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_vec.html"><strong>nmod_vec.h</strong> – vectors over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mat.html"><strong>nmod_mat.h</strong> – matrices over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly.html"><strong>nmod_poly.h</strong> – univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_mat.html"><strong>nmod_poly_mat.h</strong> – matrices of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_poly_factor.html"><strong>nmod_poly_factor.h</strong> – factorisation of univariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly.html"><strong>nmod_mpoly.h</strong> – multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="nmod_mpoly_factor.html"><strong>nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over integers mod n (word-size n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="mpn_mod.html"><strong>mpn_mod.h</strong> – integers mod n (packed multi-word n)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod.html"><strong>fmpz_mod.h</strong> – arithmetic modulo integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_vec.html"><strong>fmpz_mod_vec.h</strong> – vectors over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mat.html"><strong>fmpz_mod_mat.h</strong> – matrices over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly.html"><strong>fmpz_mod_poly.h</strong> – polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_poly_factor.html"><strong>fmpz_mod_poly_factor.h</strong> – factorisation of polynomials over integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly.html"><strong>fmpz_mod_mpoly.h</strong> – polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_factor.html"><strong>fmpz_mod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over the integers mod n</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_mod_mpoly_q.html"><strong>fmpz_mod_mpoly_q.h</strong> – multivariate rational functions over Z/mZ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_integers_mod.html"><strong>Integers mod n</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Groups and other structures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="perm.html"><strong>perm.h</strong> – permutations</a></li>
<li class="toctree-l1"><a class="reference internal" href="qfb.html"><strong>qfb.h</strong> – binary quadratic forms</a></li>
<li class="toctree-l1"><a class="reference internal" href="dirichlet.html"><strong>dirichlet.h</strong> – Dirichlet characters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dlog.html"><strong>dlog.h</strong> – discrete logarithms mod ulong primes</a></li>
<li class="toctree-l1"><a class="reference internal" href="bool_mat.html"><strong>bool_mat.h</strong> – matrices over booleans</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Number fields and algebraic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="nf.html"><strong>nf.h</strong> – number fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="nf_elem.html"><strong>nf_elem.h</strong> – number field elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpzi.html"><strong>fmpzi.h</strong> – Gaussian integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qqbar.html"><strong>qqbar.h</strong> – algebraic numbers represented by minimal polynomials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Feature overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="using.html">Using ball arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="issues.html">Technical conventions and potential issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_arb.html">Arb example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="mag.html"><strong>mag.h</strong> – fixed-precision unsigned floating-point numbers for bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="nfloat.html"><strong>nfloat.h</strong> – packed floating-point numbers with n-word precision</a></li>
<li class="toctree-l1"><a class="reference internal" href="arf.html"><strong>arf.h</strong> – arbitrary-precision floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acf.html"><strong>acf.h</strong> – complex floating-point numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb.html"><strong>arb.h</strong> – real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb.html"><strong>acb.h</strong> – complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_poly.html"><strong>arb_poly.h</strong> – polynomials over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_poly.html"><strong>acb_poly.h</strong> – polynomials over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fmpz_poly.html"><strong>arb_fmpz_poly.h</strong> – extra methods for integer polynomials</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dft.html"><strong>acb_dft.h</strong> – Discrete Fourier transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_mat.html"><strong>arb_mat.h</strong> – matrices over the real numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_mat.html"><strong>acb_mat.h</strong> – matrices over the complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_hypgeom.html"><strong>acb_hypgeom.h</strong> – hypergeometric functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_hypgeom.html"><strong>arb_hypgeom.h</strong> – hypergeometric functions of real variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_elliptic.html"><strong>acb_elliptic.h</strong> – elliptic integrals and functions of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_modular.html"><strong>acb_modular.h</strong> – modular forms of complex variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_theta.html"><strong>acb_theta.h</strong> – Riemann theta functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_dirichlet.html"><strong>acb_dirichlet.h</strong> – Dirichlet L-functions, Riemann zeta and related functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bernoulli.html"><strong>bernoulli.h</strong> – support for Bernoulli numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypgeom.html"><strong>hypgeom.h</strong> – support for hypergeometric series</a></li>
<li class="toctree-l1"><a class="reference internal" href="partitions.html"><strong>partitions.h</strong> – computation of the partition function</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_calc.html"><strong>arb_calc.h</strong> – calculus with real-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="acb_calc.html"><strong>acb_calc.h</strong> – calculus with complex-valued functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="arb_fpwrap.html"><strong>arb_fpwrap.h</strong> – floating-point wrappers of Arb mathematical functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fmpz_extras.html"><strong>fmpz_extras.h</strong> – extra methods for FLINT integers</a></li>
<li class="toctree-l1"><a class="reference internal" href="formulas.html">General formulas and bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants.html">Algorithms for mathematical constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="gamma.html">Algorithms for the gamma function</a></li>
<li class="toctree-l1"><a class="reference internal" href="hurwitz.html">Algorithms for the Hurwitz zeta function</a></li>
<li class="toctree-l1"><a class="reference internal" href="polylogarithms.html">Algorithms for polylogarithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergeometric.html">Algorithms for hypergeometric functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="agm.html">Algorithms for the arithmetic-geometric mean</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index_arb.html"><strong>Real and complex numbers (Arb)</strong> : <em>detailed table of contents</em></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Exact real and complex numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction_calcium.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_calcium.html">Calcium example programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="calcium.html"><strong>calcium.h</strong> – global definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca.html"><strong>ca.h</strong> – exact real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_vec.html"><strong>ca_vec.h</strong> – vectors of real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_poly.html"><strong>ca_poly.h</strong> – dense univariate polynomials over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_mat.html"><strong>ca_mat.h</strong> – matrices over the real and complex numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_ext.html"><strong>ca_ext.h</strong> – real and complex extension numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="ca_field.html"><strong>ca_field.h</strong> – extension fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr.html"><strong>fexpr.h</strong> – flat-packed symbolic expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fexpr_builtin.html"><strong>fexpr_builtin.h</strong> – builtin symbols</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite fields</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq.html"><strong>fq.h</strong> – finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default.html"><strong>fq_default.h</strong> – unified finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_vec.html"><strong>fq_vec.h</strong> – vectors over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_mat.html"><strong>fq_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_mat.html"><strong>fq_default_mat.h</strong> – matrices over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly.html"><strong>fq_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly.html"><strong>fq_default_poly.h</strong> – univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_poly_factor.html"><strong>fq_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_default_poly_factor.html"><strong>fq_default_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_embed.html"><strong>fq_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod.html"><strong>fq_nmod.h</strong> – finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_vec.html"><strong>fq_nmod_vec.h</strong> – vectors over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mat.html"><strong>fq_nmod_mat.h</strong> – matrices over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly.html"><strong>fq_nmod_poly.h</strong> – univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_poly_factor.html"><strong>fq_nmod_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (word-size characteristic)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_embed.html"><strong>fq_nmod_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly.html"><strong>fq_nmod_mpoly.h</strong> – multivariate polynomials over finite fields of word-sized characteristic</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_nmod_mpoly_factor.html"><strong>fq_nmod_mpoly_factor.h</strong> – factorisation of multivariate polynomials over finite fields of word-sized characteristic</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="fq_zech.html"><strong>fq_zech.h</strong> – finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_vec.html"><strong>fq_zech_vec.h</strong> – vectors over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_mat.html"><strong>fq_zech_mat.h</strong> – matrices over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly.html"><strong>fq_zech_poly.h</strong> – univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_poly_factor.html"><strong>fq_zech_poly_factor.h</strong> – factorisation of univariate polynomials over finite fields (Zech logarithm representation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="fq_zech_embed.html"><strong>fq_zech_embed.h</strong> – Computing isomorphisms and embeddings of finite fields</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">p-adic numbers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="padic.html"><strong>padic.h</strong> – p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_poly.html"><strong>padic_poly.h</strong> – polynomials over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="padic_mat.html"><strong>padic_mat.h</strong> – matrices over p-adic numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="qadic.html"><strong>qadic.h</strong> – unramified extensions over p-adic numbers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Floating-point support code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="double_extras.html"><strong>double_extras.h</strong> – support functions for double arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="double_interval.html"><strong>double_interval.h</strong> – double-precision interval arithmetic and helpers</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_vec.html"><strong>d_vec.h</strong> – double precision vectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="d_mat.html"><strong>d_mat.h</strong> – double precision matrices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_flint.html"><strong>flint_ctypes</strong> - Python interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Version history</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="history.html">History and changes</a></li>
</ul>

  </div>
</div>
      </div>
    </div>
  </div>


    
    <script
  defer
  src="_static/scripts/scroll-to-top.js"
></script>

<script>
  window.ScrollspyConfig = {
    rootMargin: "-120px 0px -60% 0px",
  };
</script>
<script defer src="_static/scripts/scrollspy.js"></script>
  <script src="_static/documentation_options.js?v=4cb41d1b"></script>
  <script src="_static/doctools.js?v=c73fddf3"></script>
  <script src="_static/sphinx_highlight.js?v=36527ec2"></script>
  <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    </body>
</html>